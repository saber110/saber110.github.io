<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saber110</title>
  
  <subtitle>越努力,越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huhaobin.cn/"/>
  <updated>2018-04-29T09:13:42.143Z</updated>
  <id>http://blog.huhaobin.cn/</id>
  
  <author>
    <name>Hu haobin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习之神经网络</title>
    <link href="http://blog.huhaobin.cn/2018/04/29/machine-learning4/"/>
    <id>http://blog.huhaobin.cn/2018/04/29/machine-learning4/</id>
    <published>2018-04-29T13:56:20.000Z</published>
    <updated>2018-04-29T09:13:42.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>a在这里表示神经网络中的神经元</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>二元分类(Binary classification)</li><li>多分类(Multi-class classification)</li></ol><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="/image/costfunctionBetweenLRandNeuralNetwork.png" alt=""></p><ul><li>L: 网络中的总层数</li><li>K: 输出层神经元的数量</li><li>S<sub>l</sub>: l 层的总神经元数量(不算偏置单元)额<!-- 注意： 这是单个 -->为了计算代价函数的最小值，我们使用反向传播算法</li></ul><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>(计算出代价函数下降最快的方向)<br>给出训练集{(x<sup>(1)</sup>,y<sup>(1)</sup>)⋯(x<sup>(m)</sup>,y<sup>(m)</sup>)}</p><p>令 Δ<sub>i,j</sub><sup>(l)</sup> := 0 for all (l,i,j), (hence you end up having a matrix full of zeros)</p><p>For training example t =1 to m:</p><ol><li>Set a<sup>(1)</sup>:=x<sup>(t)</sup></li><li>Perform forward propagation to compute a<sup>(l)</sup> for l=2,3,…,L<br><img src="/image/GradientForNeuralNetwork.png" alt=""></li><li>Using y(t), compute δ<sup>(L)</sup>=a<sup>(L)</sup>−y<sup>(t)</sup></li><li>Compute δ<sup>(L−1)</sup>,δ<sup>(L−2)</sup>,…,δ<sup>(2)</sup> using δ<sup>(l)</sup>=((Θ<sup>(l)</sup>)<sup>T</sup>δ<sup>(l+1)</sup>) .∗ a<sup>(l)</sup> .∗ (1−a<sup>(l)</sup>)</li><li>Δ<sub>i,j</sub><sup>(l)</sup>:=Δ<sub>i,j</sub><sup>(l)</sup>+a<sub>j</sub><sup>(l)</sup>δ<sub>i</sub><sup>(l+1)</sup> or with vectorization, Δ<sup>(l)</sup>:=Δ<sup>(l)</sup>+δ<sup>(l+1)</sup>(a<sup>(l)</sup>)<sup>T</sup></li></ol><p>Hence we update our new Δ matrix.</p><ul><li>D<sub>i,j</sub>(l):=1/m(Δ<sub>i,j</sub><sup>(l)</sup>+λΘ<sub>i,j</sub><sup>(l)</sup>), if j≠0.</li><li>D<sub>i,j</sub><sup>(l)</sup>:=1/mΔ<sub>i,j</sub><sup>(l)</sup> If j=0</li></ul><p>所以得出J的微分为<img src="/image/partialDerivativeOfJInNN.png" alt=""></p><h2 id="向量展开"><a href="#向量展开" class="headerlink" title="向量展开"></a>向量展开</h2><p>在之前的学习过程中我们总是使用fminunc来优化参数，但是他要求所有的输入和输出均是向量，我们在神经网络中使用的时候只能把Theta矩阵和Gradient矩阵进行向量化</p><ul><li>size(Theta1) = 10 * 11</li><li>size(Theta2) = 10 * 11</li><li>size(Theta3) = 1 * 11<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thetaVector = [ Theta1(:); Theta2(:); Theta3(:); ]</div><div class="line">deltaVector = [ D1(:); D2(:); D3(:) ]</div></pre></td></tr></table></figure></li></ul><p>恢复为矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Theta1 = reshape(thetaVector(1:110),10,11)</div><div class="line">Theta2 = reshape(thetaVector(111:220),10,11)</div><div class="line">Theta3 = reshape(thetaVector(221:231),1,11)</div></pre></td></tr></table></figure></p><h2 id="梯度计算结果校验"><a href="#梯度计算结果校验" class="headerlink" title="梯度计算结果校验"></a>梯度计算结果校验</h2><p>反向传播算法复杂多变，我们使用导数的定义来校验反向传播得到的结果是否正确(相差很小)，当确定正确之后关掉梯度校验。因为他很 <strong>慢</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">epsilon = 1e-4;</div><div class="line">for i = 1:n,</div><div class="line">  thetaPlus = theta;</div><div class="line">  thetaPlus(i) += epsilon;</div><div class="line">  thetaMinus = theta;</div><div class="line">  thetaMinus(i) -= epsilon;</div><div class="line">  gradApprox(i) = (J(thetaPlus) - J(thetaMinus))/(2*epsilon)</div><div class="line">end;</div></pre></td></tr></table></figure><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>为了避免神经网络因为相同的Theta而陷入冗余的计算，范围是[-INIT_EPSILON,INIT_EPSILON]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.</div><div class="line"></div><div class="line">Theta1 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div><div class="line">Theta2 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div><div class="line">Theta3 = rand(1,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div></pre></td></tr></table></figure></p><h2 id="网络选择-的步骤"><a href="#网络选择-的步骤" class="headerlink" title="网络选择 的步骤"></a>网络选择 的步骤</h2><ul><li>Number of input units = dimension of features x(i)</li><li>Number of output units = number of classes</li><li>Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units)</li><li>Defaults: 1 hidden layer. If you have more than 1 hidden layer, then it is recommended that you have the same number of units in every hidden layer.<h2 id="网络训练的步骤"><a href="#网络训练的步骤" class="headerlink" title="网络训练的步骤"></a>网络训练的步骤</h2></li><li>Randomly initialize the weights</li><li>Implement forward propagation to get hΘ(x<sup>(i)</sup>) for any x<sup>(i)</sup></li><li>Implement the cost function</li><li>Implement backpropagation to compute partial derivatives</li><li>Use gradient checking to confirm that your backpropagation works. Then disable gradient checking.</li><li>Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta.</li></ul><p>When we perform forward and back propagation, we loop on every training example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i = 1:m,</div><div class="line">   Perform forward propagation and backpropagation using example (x(i),y(i))</div><div class="line">   (Get activations a(l) and delta terms d(l) for l = 2,...,L</div></pre></td></tr></table></figure></p><p>(There are m training sets)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;a在这里表示神经网络中的神经元&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二元分类(Binary classificati
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之神经网络介绍</title>
    <link href="http://blog.huhaobin.cn/2018/04/28/machine-learning3/"/>
    <id>http://blog.huhaobin.cn/2018/04/28/machine-learning3/</id>
    <published>2018-04-28T13:56:20.000Z</published>
    <updated>2018-04-29T05:57:51.219Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。</p><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><ol><li>层： 输入层、隐藏层、输出层</li><li><p>仍然使用sigmoid函数<br>3.<br><img src="/image/AppearanceOfNeuronNetwork.png" alt="基本形式"></p><ul><li>a<sub>i</sub><sup>j</sup>: 第j层的第i个元素</li><li><p>Θ<sup>(j)</sup>: j层到j+1层的权重映射矩阵</p><p><strong>如果网络在j层有s<sub>j</sub>个单元，j+1层有s<sub>j+1</sub>个单元，那么Θ<sup>(j)</sup>的维度为s<sub>j+1</sub>×(s<sub>j</sub>+1)</strong></p></li></ul></li><li>向量化<br>对于中间层的计算，我们可以定义Z使得<br><img src="/image/neuralNetworkHiddenCompute.png" alt=""> 变形为<img src="/image/neuralNetworkHiddenCompute-z.png" alt=""><br>进行向量化之后<br><img src="/image/NeuralNetworkVectlize.png" alt=""><br>也就是说<br><img src="/image/ZNeuralNetwork.png" alt=""> <img src="/image/HNeuralNetwork.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。&lt;/p&gt;
&lt;h2 id=&quot;表示&quot;&gt;&lt;a href=&quot;#表示&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之逻辑分类问题</title>
    <link href="http://blog.huhaobin.cn/2018/04/27/machine-learning2/"/>
    <id>http://blog.huhaobin.cn/2018/04/27/machine-learning2/</id>
    <published>2018-04-27T13:56:20.000Z</published>
    <updated>2018-04-28T08:20:46.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑回归问题"><a href="#逻辑回归问题" class="headerlink" title="逻辑回归问题"></a>逻辑回归问题</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><ol><li>逻辑回归<br><img src="/image/HypothesisRepresentation.png" alt="逻辑回归"></li><li><p>线性回归</p><p>线性回归中 <strong>g(z)=1</strong></p></li></ol><h2 id="决策边界-Decision-boundary"><a href="#决策边界-Decision-boundary" class="headerlink" title="决策边界(Decision boundary)"></a>决策边界(Decision boundary)</h2><p>  一条分割y=0和y=1的线</p><h2 id="代价函数-cost-function"><a href="#代价函数-cost-function" class="headerlink" title="代价函数(cost function)"></a>代价函数(cost function)</h2><p>  <img src="/image/CostFunctionInLogisticRegression.png" alt="代价函数"><br>  整合之后<br>  <img src="/image/CostFunctionForLRM.png" alt="整合代价函数"><br>  gradient计算<br>  <img src="/image/GradientForLogstic.png" alt="gradient"></p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>  <img src="/image/GradientDescentForLRM.png" alt="梯度下降法"></p><h2 id="过度拟合"><a href="#过度拟合" class="headerlink" title="过度拟合"></a>过度拟合</h2><p>  过度拟合只会充分的拟合训练数据集，对数据预测并不会得到想要的值</p><ul><li>解决方法(regularization)</li></ul><h2 id="regularization"><a href="#regularization" class="headerlink" title="regularization"></a>regularization</h2><ol><li>重新设置代价函数(cost function)J<br><img src="/image/RegularizedLinerRegression.png" alt="J"><br>给每个theta做惩罚，用足够大的lambda去削弱theta的作用，从而平滑h。但是lambda太大的话将导致欠拟合，太大的时候得到的仅仅是一条扁平的直线</li><li>梯度下降法<br><img src="/image/RegularizationGradientDescent.png" alt=""><br>将theta分开更新是因为在重新设计代价函数的时候没有给theta惩罚，简化之后为<img src="/image/RegularizationGradientDescentJ.png" alt=""></li><li>归一化求代价函数的最小值<br><img src="/image/RegularizationNormalEquation.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑回归问题&quot;&gt;&lt;a href=&quot;#逻辑回归问题&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归问题&quot;&gt;&lt;/a&gt;逻辑回归问题&lt;/h1&gt;&lt;h2 id=&quot;系统函数&quot;&gt;&lt;a href=&quot;#系统函数&quot; class=&quot;headerlink&quot; title=&quot;系
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之线性回归问题</title>
    <link href="http://blog.huhaobin.cn/2018/04/23/machine-learning1/"/>
    <id>http://blog.huhaobin.cn/2018/04/23/machine-learning1/</id>
    <published>2018-04-23T13:56:20.000Z</published>
    <updated>2018-04-28T08:20:01.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性回归问题"><a href="#线性回归问题" class="headerlink" title="线性回归问题"></a>线性回归问题</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><ol><li>假设系统函数<br><img src="/image/Hypothesis.png" alt="系统函数"></li><li><p>代价函数<br><img src="/image/costFunction.png" alt="代价函数"></p><p> alpha: 学习效率</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2></li><li>普适算法<br><img src="/image/GradientDescentAlgo.png" alt="普适算法"></li><li><p>线性回归中<br><img src="/image/GradientDescentForLinearRegression.png" alt="线性回归"><br><img src="/image/GDALRS.png" alt="去微分"></p><p> <strong>记得同步更新theta</strong></p><h2 id="多变量的线性回归问题"><a href="#多变量的线性回归问题" class="headerlink" title="多变量的线性回归问题"></a>多变量的线性回归问题</h2><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3></li><li><p>数据缩放()</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X = X/MAX(X);</div></pre></td></tr></table></figure><p> 使得X <strong>接近</strong>[-1,1]区间</p></li><li><p>平均值正常化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X = (X-U)/(max(X)-MIN(x)) // U是X的平均值</div></pre></td></tr></table></figure></li><li><p>数据归一化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theta = pinv(X&apos;*X)*X&apos;*y;</div></pre></td></tr></table></figure></li></ol><p>可以用正态方程求解代价函数最小值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性回归问题&quot;&gt;&lt;a href=&quot;#线性回归问题&quot; class=&quot;headerlink&quot; title=&quot;线性回归问题&quot;&gt;&lt;/a&gt;线性回归问题&lt;/h1&gt;&lt;h2 id=&quot;代价函数&quot;&gt;&lt;a href=&quot;#代价函数&quot; class=&quot;headerlink&quot; title=&quot;代
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>qt画图</title>
    <link href="http://blog.huhaobin.cn/2018/04/21/qtPainting/"/>
    <id>http://blog.huhaobin.cn/2018/04/21/qtPainting/</id>
    <published>2018-04-21T06:15:31.118Z</published>
    <updated>2018-04-21T06:15:31.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QcustomPlot"><a href="#QcustomPlot" class="headerlink" title="QcustomPlot"></a>QcustomPlot</h2><ol><li><p>下载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.qcustomplot.com</div></pre></td></tr></table></figure></li><li><p>把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可</p></li><li>pro文件中QT += widgets printsupport</li><li><p>使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">QVector x(101), y(101); // initialize with entries 0..100</div><div class="line">for (int i=0; i&lt;101; ++i)</div><div class="line">&#123;</div><div class="line">x[i] = i/50.0 – 1; // x goes from -1 to 1</div><div class="line">y[i] = x[i]*x[i]; // let’s plot a quadratic function</div><div class="line">&#125;</div><div class="line">qDebug()&lt;&lt;“data has been created”;</div><div class="line">ui-&gt;black_line-&gt;addGraph();</div><div class="line">qDebug()&lt;&lt;“begin painting”;</div><div class="line">ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);</div><div class="line">ui-&gt;black_line-&gt;replot();</div><div class="line">qDebug()&lt;&lt;“finish”;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QcustomPlot&quot;&gt;&lt;a href=&quot;#QcustomPlot&quot; class=&quot;headerlink&quot; title=&quot;QcustomPlot&quot;&gt;&lt;/a&gt;QcustomPlot&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载&lt;/p&gt;
 &lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Qt" scheme="http://blog.huhaobin.cn/categories/Qt/"/>
    
    
      <category term="上位机 Qt" scheme="http://blog.huhaobin.cn/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA-Qt/"/>
    
  </entry>
  
  <entry>
    <title>mysqldb安装</title>
    <link href="http://blog.huhaobin.cn/2018/04/19/MySQLdb/"/>
    <id>http://blog.huhaobin.cn/2018/04/19/MySQLdb/</id>
    <published>2018-04-19T13:56:20.000Z</published>
    <updated>2018-04-19T08:35:09.917Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install python3-mysqldb</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="python" scheme="http://blog.huhaobin.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>新博客站的第一篇文章</title>
    <link href="http://blog.huhaobin.cn/2018/04/19/about/"/>
    <id>http://blog.huhaobin.cn/2018/04/19/about/</id>
    <published>2018-04-19T07:49:39.519Z</published>
    <updated>2017-09-30T08:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百废待兴"><a href="#百废待兴" class="headerlink" title="百废待兴"></a>百废待兴</h2><p>自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本</p><h2 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h2><p>虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺.</p><h2 id="后悔莫及"><a href="#后悔莫及" class="headerlink" title="后悔莫及"></a>后悔莫及</h2><p>前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞</p><h3 id="有时间继续更新"><a href="#有时间继续更新" class="headerlink" title="有时间继续更新"></a>有时间继续更新</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百废待兴&quot;&gt;&lt;a href=&quot;#百废待兴&quot; class=&quot;headerlink&quot; title=&quot;百废待兴&quot;&gt;&lt;/a&gt;百废待兴&lt;/h2&gt;&lt;p&gt;自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名
      
    
    </summary>
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/categories/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/tags/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>搭建ssr</title>
    <link href="http://blog.huhaobin.cn/2018/04/19/shadowsocksr/"/>
    <id>http://blog.huhaobin.cn/2018/04/19/shadowsocksr/</id>
    <published>2018-04-18T16:36:51.000Z</published>
    <updated>2018-04-19T02:58:49.394Z</updated>
    
    <content type="html"><![CDATA[<ol><li>服务部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum -y install wget</div><div class="line"></div><div class="line">wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</div></pre></td></tr></table></figure></li></ol><p>备用脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum -y install wget</div><div class="line"></div><div class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</div></pre></td></tr></table></figure></p><ol><li><p>脚本安装<br>需要注意的有</p><ol><li>protocol 最好选择auth_chain_a</li><li>obfs(混淆) 千万不要选择tls <strong>有被墙的风险</strong></li></ol></li><li><p>添加开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.local</div><div class="line"></div><div class="line">python /usr/local/shadowsocksr/shadowsocks/server.py -c /etc/shadowsocksr/user-config.json a &amp;</div></pre></td></tr></table></figure></li><li><p>加速服务(BBR)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</div><div class="line"></div><div class="line">chmod +x bbr.sh</div><div class="line"></div><div class="line">./bbr.sh</div></pre></td></tr></table></figure></li><li><p>客户端地址<br>windows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases/download/4.7.0/ShadowsocksR-4.7.0-win.7z</div></pre></td></tr></table></figure></li></ol><p>linux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install python-pip</div><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure></p><p>android<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.5.6/shadowsocks--universal-4.5.6.apk</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;服务部署&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux定时执行任务</title>
    <link href="http://blog.huhaobin.cn/2018/04/18/SystemTimer/"/>
    <id>http://blog.huhaobin.cn/2018/04/18/SystemTimer/</id>
    <published>2018-04-18T14:11:07.000Z</published>
    <updated>2018-04-18T08:12:50.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户级任务"><a href="#用户级任务" class="headerlink" title="用户级任务"></a>用户级任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab -e</div></pre></td></tr></table></figure><p>格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">min hour dayofmonth monthofyear dayofweek  command</div></pre></td></tr></table></figure></p><ol><li>会进行语法检查<h2 id="系统级任务"><a href="#系统级任务" class="headerlink" title="系统级任务"></a>系统级任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nano /etc/crontab</div></pre></td></tr></table></figure></li></ol><p>格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">min hour dayofmonth monthofyear dayofweek user command</div></pre></td></tr></table></figure></p><ol><li>不会进行语法检查</li></ol><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li>配置之后需要重启crond服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service cron restart</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用户级任务&quot;&gt;&lt;a href=&quot;#用户级任务&quot; class=&quot;headerlink&quot; title=&quot;用户级任务&quot;&gt;&lt;/a&gt;用户级任务&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux网络连接后执行脚本</title>
    <link href="http://blog.huhaobin.cn/2018/04/18/DoThingsAfterInternetConnetc/"/>
    <id>http://blog.huhaobin.cn/2018/04/18/DoThingsAfterInternetConnetc/</id>
    <published>2018-04-18T14:11:07.000Z</published>
    <updated>2018-04-18T02:31:08.111Z</updated>
    
    <content type="html"><![CDATA[<p>在Debian/Ubuntu的发行版本里，网络建立前、后和网络断开前、后都会到/etc/network/里运行相应目录下的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if-down.d -- 网络关闭前</div><div class="line">if-post-down.d -- 网络关闭后</div><div class="line">if-pre-up.d -- 网络建立前</div><div class="line">if-up.d -- 网络建立后</div></pre></td></tr></table></figure></p><p>所以把自己的脚本放在/etc/network/if-up.d/目录下面就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Debian/Ubuntu的发行版本里，网络建立前、后和网络断开前、后都会到/etc/network/里运行相应目录下的脚本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;di
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo个人博客的美化</title>
    <link href="http://blog.huhaobin.cn/2018/04/11/ButifyBlog/"/>
    <id>http://blog.huhaobin.cn/2018/04/11/ButifyBlog/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-21T06:41:26.118Z</updated>
    
    <content type="html"><![CDATA[<p>SEO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure></p><p>在【站点配置文件】hexo_blog_config.yml 中添加如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># hexo sitemap</div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">  path: baidusitemap.xml</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SEO&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
      <category term="hexo" scheme="http://blog.huhaobin.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.huhaobin.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ssh反向代理进行内网穿透</title>
    <link href="http://blog.huhaobin.cn/2018/04/10/SSHReverseproxy/"/>
    <id>http://blog.huhaobin.cn/2018/04/10/SSHReverseproxy/</id>
    <published>2018-04-09T18:00:55.000Z</published>
    <updated>2018-04-15T12:42:59.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公网主机配置"><a href="#公网主机配置" class="headerlink" title="公网主机配置"></a>公网主机配置</h3><ol><li><p>修改sshd的配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nano /etc/ssh/sshd_config</div></pre></td></tr></table></figure><p>在最后面添加GatewayPorts yes,重启sshd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service sshd restart</div></pre></td></tr></table></figure><p><strong>作用：设置反向代理的ip是0.0.0.0，而不是127.0.0.1</strong></p><h3 id="内网主机配置"><a href="#内网主机配置" class="headerlink" title="内网主机配置"></a>内网主机配置</h3><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -NfR &lt;公网端口&gt;:&lt;要代理的ip&gt;:&lt;要代理的端口&gt; &lt;用户名&gt;@公网主机ip (-i /path/to/privatekey)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-N：ssh不执行命令</div><div class="line">-f：后台执行</div><div class="line">-R：反向代理</div></pre></td></tr></table></figure><p><strong>private key 应该时600权限</strong><br>查看是否启动，在公网主机上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">netstat -tnl|grep &lt;公网端口&gt;</div><div class="line"></div><div class="line">tcp        0      0 0.0.0.0:&lt;公网端口&gt;            0.0.0.0:*               LISTEN</div><div class="line">tcp6       0      0 :::&lt;公网端口&gt;                 :::*                    LISTEN</div></pre></td></tr></table></figure><p>说明执行成功</p><h3 id="免密，稳定通道"><a href="#免密，稳定通道" class="headerlink" title="免密，稳定通道"></a>免密，稳定通道</h3></li><li><p>免密<br>在内网主机上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id &lt;用户名&gt;@公网主机ip</div></pre></td></tr></table></figure></li><li><p>稳定通道(两种方法)</p><ol><li>autossh<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install autossh</div><div class="line">autossh -M 2333 &lt;公网端口&gt;:&lt;要代理的ip&gt;:&lt;要代理的端口&gt; &lt;用户名&gt;@公网主机ip (-i /path/to/publickey)</div></pre></td></tr></table></figure></li></ol><p><em>-M : 回显测试</em></p><ol><li><p>ssh心跳包</p><ul><li>单独客户设置（方法1）<br>修改/etc/ssh/ssh_config，添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ServerAliveInterval 60</div><div class="line">ServerAliveCountMax 9999999999</div></pre></td></tr></table></figure><ul><li>服务器设置（方法二）{新客户端可以不用设置，服务器负责维护}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/ssh/sshd_config</div><div class="line"># 添加</div><div class="line">ClientAliveInterval 30</div><div class="line">ClientAliveCountMax 6</div></pre></td></tr></table></figure></li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;公网主机配置&quot;&gt;&lt;a href=&quot;#公网主机配置&quot; class=&quot;headerlink&quot; title=&quot;公网主机配置&quot;&gt;&lt;/a&gt;公网主机配置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改sshd的配置文件，&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="反向代理" scheme="http://blog.huhaobin.cn/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>分治策略</title>
    <link href="http://blog.huhaobin.cn/2018/04/07/CA3/"/>
    <id>http://blog.huhaobin.cn/2018/04/07/CA3/</id>
    <published>2018-04-07T14:11:07.000Z</published>
    <updated>2018-04-09T08:46:58.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h2><h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><p>给定函数来计算n个输入， <strong>分治策略</strong> 建议将输入分成k个子集，1&lt;k&lt;=n,得到k个子问题</p><h4 id="解递归关系"><a href="#解递归关系" class="headerlink" title="解递归关系"></a>解递归关系</h4><p>很多分治算法的复杂度是这样的</p><p>$$T(n)= a_{1}^n $$</p><h3 id="残缺棋盘"><a href="#残缺棋盘" class="headerlink" title="残缺棋盘"></a>残缺棋盘</h3><p>描述: 有2<sup>k</sup>* 2<sup>k</sup>个方格的棋盘中恰好有一个方格是坏的</p><p>要求：用三方块把残缺棋盘铺满，三方块不能重叠，不能盖住坏的方格</p><p>—–&gt; 需要用(2<sup>2k</sup>-1)/3个三方块</p><p>解决思路(分治法)：</p><ol><li>划分成小棋盘比如4个2<sup>k-1</sup>* 2<sup>k-1</sup>，这样只有一个小棋盘有坏的</li><li>我们用一个三方块盖住没有坏方格的三个棋盘</li><li>递归</li><li>棋盘的大小缩为1*1时，递归终止</li></ol><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>描述： 在n个已经按升序/降序排列好的元素中搜索是否存在元素x</p><p>要求： 已经按 <strong>升序/降序</strong> 排列好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分治策略&quot;&gt;&lt;a href=&quot;#分治策略&quot; class=&quot;headerlink&quot; title=&quot;分治策略&quot;&gt;&lt;/a&gt;分治策略&lt;/h2&gt;&lt;h3 id=&quot;一般方法&quot;&gt;&lt;a href=&quot;#一般方法&quot; class=&quot;headerlink&quot; title=&quot;一般方法&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://blog.huhaobin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法 C++描述 第二章</title>
    <link href="http://blog.huhaobin.cn/2018/04/07/CA2/"/>
    <id>http://blog.huhaobin.cn/2018/04/07/CA2/</id>
    <published>2018-04-07T14:11:07.000Z</published>
    <updated>2018-04-07T12:15:13.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="template-模板"><a href="#template-模板" class="headerlink" title="template 模板"></a>template 模板</h2><ol><li><p>类模板<br>假设一个类中数据成员的数据类型不能确定。或者是某个成员函数的參数或返回值的类型不能确定。就必须将此类声明为模板，它的存在不是代表一个详细的、实际的类，而是代表着一类类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class Type&gt;</div><div class="line">class foo</div><div class="line">&#123;</div><div class="line">  private:</div><div class="line">    Type a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>类模板的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类名&lt;实际的类型&gt;</div></pre></td></tr></table></figure><p>类模板的使用实际上是将类模板实例化成一个详细的类</p></li><li><p>在类外面定义函数模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename（或class) T&gt;</div><div class="line">&lt;返回类型&gt;&lt;函数名&gt;(參数表)</div><div class="line">&#123;</div><div class="line">    函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename（或class) T&gt;</div><div class="line">T fuc(T x, T y)</div><div class="line">&#123;</div><div class="line">    T x;</div><div class="line">    //……</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>模板函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">double d;</div><div class="line">    int a;</div><div class="line">    fuc(d,a);</div><div class="line">则系统将用实參d的数据类型double去取代函数模板中的T生成函数：</div><div class="line"></div><div class="line">double fuc(double x,int y)</div><div class="line">&#123;</div><div class="line">   double x;</div><div class="line">   //……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>模板函数的生成就是将函数模板的类型形參实例化的过程。</p></li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>  队列的一种有效表示方法是用数组，把他看成环形结构</p><ul><li>判断队列为空  rear == front</li><li>队尾插入操作  rear = (++rear)%MaxSize</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol><li><p>引理</p><ul><li><p>一棵二叉树第i层上最多结点个数为2<sup>i-1</sup>, 一个深度为k的二叉树最多节点数为2<sup>k</sup>-1</p><p>n个节点的完全二叉树可以存放在一维数组tree[n+1]中</p></li><li>任何一个包含n个节点的完全二叉树，如果采用上述的方法表示，对于任何下标的节点i来说，1 &lt;= i &lt;= n有：<ol><li>当 i != 1 时，parent(i)在 ⌊i/2⌋。当i == 1时，i是树根没有parent</li><li>当 2i &lt;= n 时，lchild(i)在2i。如果2i &gt; n，i没有左孩子</li><li>当 2i + 1 &lt;= n 时，rchild(i)在2i+1，否则没有右孩子</li></ol></li></ul></li><li><p><strong>二叉搜索树</strong></p><p>特征</p><ol><li>每个元素都有一个键值，并且没有两个元素键值相同</li><li>左子树的键值(如果有的话)都小于树根的键值</li><li>右子树的键值(如果有的话)都大于树根的键值</li><li>左右子树也都是二叉搜索树</li></ol></li><li><p>堆(Heap)</p><ol><li>堆性质：每个节点的值都至少与其孩子一样大（一样小） —&gt;  依次递增（减）</li><li>堆排序：这可真的是一个秀的头疼的操作。靠其自身的insert和deletemax构建新堆获得旧堆的顺序</li></ol></li><li><p>集合与 <strong>不相交</strong> 集合的并集</p><ol><li>用森林表示集合，每个集合都可以表示为一棵树。把孩子节点链接到父节点上</li><li>为了得到两个集合的并集，我们可以把一课树的树根的父节点域设置为另一棵树的树根( <strong>不相交</strong>)</li><li>忽略集合的名字并且用表示集合的树的树根来标志该集合</li><li><em>权重规则</em> ： 如果以i为树根的树所包含的节点少于以j为树根的树，那么就令j成为i的父节点。否则i成为j的父节点</li><li><em>收缩规则</em> ： 如果节点j在节点i到树根的路径上，并且p[i] != root[i],那么将p[i]置为root[i]<br>—–&gt; p[j]及路径上所有节点的父节点置为root[i]</li></ol></li><li><p>图</p><ol><li>图的定义和特点<ol><li>欧拉定义定点的度等于与他相接的边的条数</li></ol><ul><li>对于有向图来说：V的入/出度是以v为头/尾的所有边的条数</li></ul><ol><li>当且仅当所有定点的度数都是偶数，满足这样条件的路径被成为 <strong>欧拉路径</strong></li><li>我们通常用G=(V, E)来表示一个图</li></ol><ul><li>V 是有穷非空的定点的集合</li><li>E 是顶点对称的集合，又被称为边</li><li>无向图中任意边的顶点对都是无序的 (u, v)</li><li>有向图中任意边的顶点对都是有序的 <u, v="">， u是头，v是尾</u,></li></ul><ol><li>图不能包含定点v到自己的边。这样的边被称为自边或者自环</li><li>图不能有一条边重复多次，如果去掉这个限制那么我们得到的是多图</li></ol><ul><li>任意包含n个顶点的无向图的最大边数为 n(n-1)/2，包含最大边数的无向图是完全的</li><li>任意包含n个顶点的有向图的最大边数为 n(n-1)</li></ul><ol><li>路径的长度就是其中的边数</li><li>简单路径： 路径中可能除了第一个和最后一个都是不同的顶点（只有可能第一个和最后一个相同，其他的都不同）</li><li>环： 第一个和最后一个相同的路径</li></ol></li><li>图的表示<ol><li>邻接矩阵</li></ol><ul><li>邻接矩阵是一个n*n的矩阵</li><li>若存在边(i, j)，则a[i, j] = 1,其他的等于0</li><li>无向图的邻接矩阵是对称的</li><li>无向图上的顶点i其度数等于它对应的行之和</li><li>有向图上行之和是出度，列之和是入度</li></ul><ol><li>邻接表<br><img src="/image/linjiebiao.jpg" alt="邻接表"></li><li>邻接多重表</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;template-模板&quot;&gt;&lt;a href=&quot;#template-模板&quot; class=&quot;headerlink&quot; title=&quot;template 模板&quot;&gt;&lt;/a&gt;template 模板&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类模板&lt;br&gt;假设一个类中数据成员的数据类型不能确
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://blog.huhaobin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读书记录</title>
    <link href="http://blog.huhaobin.cn/2018/04/06/TheCollectOfReading/"/>
    <id>http://blog.huhaobin.cn/2018/04/06/TheCollectOfReading/</id>
    <published>2018-04-06T12:45:12.000Z</published>
    <updated>2018-04-06T07:04:44.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机类"><a href="#计算机类" class="headerlink" title="计算机类"></a>计算机类</h2><ol><li>计算机算法(C++语言描述) 第二版</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机类&quot;&gt;&lt;a href=&quot;#计算机类&quot; class=&quot;headerlink&quot; title=&quot;计算机类&quot;&gt;&lt;/a&gt;计算机类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;计算机算法(C++语言描述) 第二版&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://blog.huhaobin.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>编程珠玑</title>
    <link href="http://blog.huhaobin.cn/2018/04/01/ProgrammingPearlsKnown/"/>
    <id>http://blog.huhaobin.cn/2018/04/01/ProgrammingPearlsKnown/</id>
    <published>2018-04-01T14:11:07.000Z</published>
    <updated>2018-03-31T05:00:48.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程珠玑新知识点记录"><a href="#编程珠玑新知识点记录" class="headerlink" title="编程珠玑新知识点记录"></a><a href="./ProgrammingPearls/chapter.md">编程珠玑</a>新知识点记录</h2><h3 id="第一章-开篇"><a href="#第一章-开篇" class="headerlink" title="第一章 开篇"></a>第一章 开篇</h3><ol><li>位图，位向量<ul><li>位向量(亦作位图，不过与图形学中的位图混淆，下作位向量)。一个n位的二进制数据，数据i如果出现在该二进制的第i位，则该位置为1，否则为0。如：用一个10位长的二进制数据表示元素都小于10的集合，{1,2,3,5,8},该集合用二进制数据的表现形式：0111010010</li><li>算法分析<ol><li>初始化集合，每个位都置为0；</li><li>读入文件的每个整数，将对应的位置为1；</li><li>遍历二进制数据，如果该位为1，则输出相应的整数。</li></ol></li></ul></li><li><p>bitset<br>C++语言的一个类库，用来方便地管理一系列的bit位而不用程序员自己来写代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bitset&lt;N&gt;varm (M)</div><div class="line">其中varm为变量名。</div><div class="line">N表示该类型在内存中占的位数，是二进制。</div><div class="line">M表示变量varm的初始值。</div></pre></td></tr></table></figure><ul><li>相关函数</li></ul><ol><li>any(); //当bitset对象的一位或多个位被设置为1 时any()返回true</li><li>none(); // 如果bitset 对象的所有位都被设置为0 ,则none()操作返回true</li><li>count(); // count()操作返回被设置为1的位的个数.</li><li>set(); //我们可以用set()操作或者下标操作符来设置某个单独的位</li><li>test(); //测试某个单独的位是否为1 test()操作。用位置做参数，返回true或false</li><li>reset(); // 要将某个单独的位设置为0 ,我们可以用reset()或下标操作符</li></ol></li><li>wc -l/c/w filename 统计文件行/字节/字数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编程珠玑新知识点记录&quot;&gt;&lt;a href=&quot;#编程珠玑新知识点记录&quot; class=&quot;headerlink&quot; title=&quot;编程珠玑新知识点记录&quot;&gt;&lt;/a&gt;&lt;a href=&quot;./ProgrammingPearls/chapter.md&quot;&gt;编程珠玑&lt;/a&gt;新知识点记录&lt;
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.huhaobin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="http://blog.huhaobin.cn/2018/04/01/processCom/"/>
    <id>http://blog.huhaobin.cn/2018/04/01/processCom/</id>
    <published>2018-04-01T14:11:07.000Z</published>
    <updated>2018-03-31T07:45:41.704Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>信号</p><ul><li>由于某些错误而产生的事件</li><li>可以设定信号触发之后的处理方式，但信号是系统已经确定的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void (*signals(int signum, void(*hangdler)(int)))(int);</div><div class="line">int sigaction(int signum, const struct sigaction * act, struct sigaction * addr)</div></pre></td></tr></table></figure></li></ul></li><li><p>管道和命名管道<br><strong>实质是先进先出，半双工的数据结构，双方通信需要两个管道</strong></p><ul><li>管道：只能用于相互关联的进程间通信，如：父子进程</li><li>命名管道： = 特殊文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkfifo(const char * pathname, mode_t mode); //建立管道文件</div><div class="line">read() write() close() 均可操作</div></pre></td></tr></table></figure></li></ul></li><li><p>信号量<br>主要用于控制多个线程对临界区资源的访问</p></li><li><p>消息队列<br>将消息按队列方式组成的链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int msgget(key_t key, int msgflg);</div><div class="line">int msgsnd(int msgid, const void * msgptr, int msgsz, int msgflg);</div><div class="line">int msgrcv(int msgid, const void * msgptr, int msgsz, long msgtyp, int msgflg);</div><div class="line">int msgctl(int msgid, int cmd, struct msgid_ds *buf);</div></pre></td></tr></table></figure></li><li><p>共享内存<br>直接操作内存，不用复制文件 <strong>系统创建的特殊地址空间，允许多个不相关的进程使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int shmget(key_t key, int shmflg);</div><div class="line">int shmat(int shmid, const void * shmaddr, int shmflg);</div><div class="line">int shmdt(const void * shmaddr);</div><div class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于某些错误而产生的事件&lt;/li&gt;
&lt;li&gt;可以设定信号触发之后的处理方式，但信号是系统已经确定的&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux关机前执行脚本</title>
    <link href="http://blog.huhaobin.cn/2018/03/31/DOBeforeShutdownInLinux/"/>
    <id>http://blog.huhaobin.cn/2018/03/31/DOBeforeShutdownInLinux/</id>
    <published>2018-03-31T14:11:07.000Z</published>
    <updated>2018-03-30T09:04:54.068Z</updated>
    
    <content type="html"><![CDATA[<ol><li>建立关机需要执行的脚本文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/init.d/K99shutdownbefore.sh</div></pre></td></tr></table></figure></li></ol><p>K99文件名用来保证运行优先级</p><ol><li><p>赋予执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod +x /etc/init.d/K99shutdownbefore.sh</div></pre></td></tr></table></figure></li><li><p>创建关机和重启软连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo ln -s /etc/init.d/K99shutdownbefore.sh  /etc/rc0.d/K99shutdownbefore</div><div class="line">sudo ln -s /etc/init.d/K99shutdownbefore.sh  /etc/rc6.d/K99shutdownbefore</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;建立关机需要执行的脚本文件&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C语言大坑</title>
    <link href="http://blog.huhaobin.cn/2018/03/24/a_bigHole_ofC/"/>
    <id>http://blog.huhaobin.cn/2018/03/24/a_bigHole_ofC/</id>
    <published>2018-03-24T04:10:48.019Z</published>
    <updated>2018-03-24T04:10:48.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接下来就开始看看坑"><a href="#接下来就开始看看坑" class="headerlink" title="接下来就开始看看坑"></a>接下来就开始看看坑</h2><ol><li><p>单引号表示表示整数值</p><ul><li>双引号表示字符串首的地址</li><li>以0开头的整数默认为八进制</li><li>注意使用移位运算加快程序执行速度</li><li>if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致</li><li>a[i] = i[a]</li><li>C语言的不对称边界</li><li>errno 外部出错变量，可以检测出错信息</li><li>break 跳出离他最近的那层循环或switch</li><li>C 语言不能省略形参，即使不使用</li></ul></li><li><p>C语言的数据存储空间</p><ul><li>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）</li><li>局部变量在return之后出栈销毁，不要尝试返回局部指针地址</li><li>堆  申请、释放原则 <strong>哪儿申请哪儿释放</strong><br> 记得判断 堆 申请成功与否</li></ul></li><li><p>一个程序将操作系统分配给其运行的内存块分为4个区域：<br>　　(1)代码区，存放程序的代码，即程序中的各个函数代码块。<br>　　(2)全局数据区，存放程序的全局数据和静态数据。<br>　　(3)堆区，存放程序的动态数据。<br>　　(4)栈区，存放程序的局部数据，即各个函数中的数据。</p></li><li><p>强制类型转换</p></li></ol><ul><li>占用空间大的转化为占用空间小的： 考虑字节序（大小端），所使用的部分可能在不同机器上截然不同</li><li>占用空间小的转化为占用空间大的： 考虑内存越界访问</li><li>结构体强制转换             ： 考虑字节对齐</li></ul><ol><li>字符串</li></ol><ul><li>通过索引读取字符串时，一定要判断索引的正确性</li></ul><ol><li>多线程编程</li></ol><ul><li>互斥量用来对临界区的互斥进入</li><li>条件变量用于线程的阻塞等待</li></ul><ol><li><p>指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int * p = NULL;</div><div class="line"></div><div class="line">&amp;p 表示p的地址</div><div class="line">p 表示变量p的内容</div><div class="line">*p 表示p指向的存储单元的内容</div></pre></td></tr></table></figure><ul><li><strong>数字0是唯一能输给指针的数值</strong>(相当于NULL)  </li><li>void * :指向任何类型的指针</li><li><strong>注意深复制和浅复制的区别</strong><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p, *q;</div><div class="line">*p = 58;</div><div class="line">q = p;        // q 和 P 指向同一内存单元</div><div class="line">free(q);</div><div class="line">printf(&quot;%d\n&quot;,p); //异常。p的内存已经被q释放</div></pre></td></tr></table></figure></li></ul></li><li><p>动态变量</p><p>在程序运行过程中产生的变量称为动态变量</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int * p; char *q;</div><div class="line">p = new int;  // 在内存中创建一个变量，存储所分配的内存地址到p中</div><div class="line">q = new char[19];   // 在内存中创建一个数组，并将数组地址存储到q中</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p = 28;</div><div class="line">*q = &quot;hello&quot;;</div></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete p;</div><div class="line">delete [] q;</div></pre></td></tr></table></figure></li></ul></li><li><p>动态数组</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int *p;</div><div class="line">p = new int[10];</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* p = 25;   //25存到第一个存储空间里  = p[0] = 25；</div><div class="line">p ++;</div><div class="line">* p = 35;   //35存到第二个存储空间里  = p[1] = 35；</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接下来就开始看看坑&quot;&gt;&lt;a href=&quot;#接下来就开始看看坑&quot; class=&quot;headerlink&quot; title=&quot;接下来就开始看看坑&quot;&gt;&lt;/a&gt;接下来就开始看看坑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单引号表示表示整数值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号表示字符串首
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>sizeof与strlen的区别</title>
    <link href="http://blog.huhaobin.cn/2018/03/11/sizeofstrlen/"/>
    <id>http://blog.huhaobin.cn/2018/03/11/sizeofstrlen/</id>
    <published>2018-03-11T07:47:26.000Z</published>
    <updated>2018-04-21T05:19:57.341Z</updated>
    
    <content type="html"><![CDATA[<ol><li>sizeof是一个操作符,结果类型是size_t，它在头文件中typedef为unsigned　int类型。该类型保证能容纳实现所建立的最大对象的字节大小.而strlen是一个库函数,使用需要包含<string.h>头文件.</string.h></li><li>sizeof的参数可以是数据类型或变量,而strlen函数只能以结尾为’\0’的字符串的作为参数.</li><li>sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数</li><li>编译器在编译的时候就计算出了sizeof的结果.而strlen函数必须在运行的时候才能计算出来.</li><li>sizeof计算的是数据类型占用的内存的大小,而strlen计算的字符串实际的长度,不包括’\0’;</li><li>数组作为sizeof的参数不会退化,而作为strlen的参数的时候会退化为一个字符指针.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;sizeof是一个操作符,结果类型是size_t，它在头文件中typedef为unsigned　int类型。该类型保证能容纳实现所建立的最大对象的字节大小.而strlen是一个库函数,使用需要包含&lt;string.h&gt;头文件.&lt;/string.h&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="C" scheme="http://blog.huhaobin.cn/categories/C/"/>
    
    
      <category term="C" scheme="http://blog.huhaobin.cn/tags/C/"/>
    
  </entry>
  
</feed>
