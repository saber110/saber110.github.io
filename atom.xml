<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saber110</title>
  
  <subtitle>越努力,越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huhaobin.cn/"/>
  <updated>2018-05-13T06:31:30.694Z</updated>
  <id>http://blog.huhaobin.cn/</id>
  
  <author>
    <name>Hu haobin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员的自我修养</title>
    <link href="http://blog.huhaobin.cn/2018/05/13/Programmer&#39;sSelfCultivation2/"/>
    <id>http://blog.huhaobin.cn/2018/05/13/Programmer&#39;sSelfCultivation2/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-05-13T06:31:30.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在优先级调度的环境下，线程优先级改变的方式有</p><ul><li>用户制定优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级</li><li>长时间得不到执行而提升优先级<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2></li></ul><p>基本结构如图所示<img src="/image/objSample.png" alt=""></p><ul><li>初始化的全局变量和局部静态变量保存在.data</li><li>未初始化的全局变量和局部静态变量保存在.bss</li><li>File Header 里面包含一个段表<br>除此之外还可以自定义段<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__attribute__((section(&quot;FOO&quot;))) int global = 42;</div><div class="line">__attribute__((section(&quot;BAR&quot;))) void foo()</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 这样就可以把相应的变量或者函数放在以“FOO”/&quot;BAR&quot;作为段名的段中</div><div class="line">// 名字可以自定义</div></pre></td></tr></table></figure></li></ul><h2 id="C-和C的兼容"><a href="#C-和C的兼容" class="headerlink" title="C++和C的兼容"></a>C++和C的兼容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot;&#123;</div><div class="line">  int func(int);</div><div class="line">  int var;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C++ 编译器会将在extern “C”大括号内部的代码当作C语言来处理</p><p>为了处理C++调用了C函数，但认为是C++函数，经过名称修饰之后无法正确引用的问题，C++编译器会在便宜C++的程序时默认定义宏”__cplusplus”.我们可以使用条件宏来判断当前便宜单元是不是C++代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">#endif</div><div class="line"></div><div class="line">void *memset(void *, int, size_t);    // C语言内容</div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程调度&quot;&gt;&lt;a href=&quot;#线程调度&quot; class=&quot;headerlink&quot; title=&quot;线程调度&quot;&gt;&lt;/a&gt;线程调度&lt;/h2&gt;&lt;p&gt;在优先级调度的环境下，线程优先级改变的方式有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户制定优先级&lt;/li&gt;
&lt;li&gt;根据进入等待状态的
      
    
    </summary>
    
      <category term="程序员的自我修养" scheme="http://blog.huhaobin.cn/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="程序员的自我修养" scheme="http://blog.huhaobin.cn/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>信息的表示和处理</title>
    <link href="http://blog.huhaobin.cn/2018/05/11/OS2/"/>
    <id>http://blog.huhaobin.cn/2018/05/11/OS2/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-05-13T01:59:51.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><ol><li><p>数据大小</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C类型      字节（32位）  字节（64位）</div><div class="line">char            1        1</div><div class="line">short int       2        2</div><div class="line">int             4        4</div><div class="line">long int        4        8</div><div class="line">long long int   8        8</div><div class="line">float           4        4</div><div class="line">double          8        8</div><div class="line">char *          4        8</div></pre></td></tr></table></figure></li><li><p>移位</p><p> 假如进行x&gt;&gt;k,这里的k很大,实际偏移量是通过k mod v得到的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int lval = 0xede875 &gt;&gt; 32;</div><div class="line">int aval = 0xede875 &gt;&gt; 36;</div><div class="line">unsigned int uval = 0xede875 &gt;&gt; 40;</div></pre></td></tr></table></figure><p> 在32位机器上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lval = 0xede875;            // 32 mod 32 = 0</div><div class="line">aval = 0xfede87;            // 36 mod 32 = 4</div><div class="line">uval = 0x00ede8;</div></pre></td></tr></table></figure><p> <strong>几乎所有的编译器/机器都对有符号数据使用算术右移，无符号数据必须是逻辑右移</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信息存储&quot;&gt;&lt;a href=&quot;#信息存储&quot; class=&quot;headerlink&quot; title=&quot;信息存储&quot;&gt;&lt;/a&gt;信息存储&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据大小&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://blog.huhaobin.cn/2018/05/09/OS1/"/>
    <id>http://blog.huhaobin.cn/2018/05/09/OS1/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-05-09T13:24:04.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h2><ol><li><p>进程的创建</p><p>原因：</p><ul><li>系统初始化</li><li>正在运行的进程执行了创建进程的系统调用</li><li>用户请求创建一个新进程</li><li>批处理作业的初始化</li></ul></li><li><p>进程的终止</p><p>原因：</p><ul><li>正常退出（自愿）</li><li>出错退出（自愿）</li><li>严重错误（非自愿）</li><li>被其他进程杀死（非自愿）</li></ul></li><li><p>进程的状态</p><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li></ul></li><li><p>线程可以在内核和用户空间中进行管理，但不论是在哪儿都会引来很多问题</p><h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2></li><li><p>临界区</p><p>一个好的临界区解决方案需要具备以下四个条件：</p><ul><li>任何两个进程不能同时处于临界区</li><li>不应对CPU的速度和数目做任何假设</li><li>临界区外的进程不能阻塞其他进程</li><li>不能让进程在临界区外面无休止的等待</li></ul></li><li><p>忙等待形式的互斥</p><ol><li><p>关闭中断</p><p> 在进入临界区之前先关中断，退出之后开中断。这样把开关中断的权限交给用户是不明智的</p></li><li><p>锁变量</p><p> 设置一个共享锁变量，0表示临界区内没有进程，1表示有。每次进入之前先测试，如果此时为0则设置为1，退出临界区设置为0。遗憾的是这个方法也<strong>不是线程安全</strong>的</p></li><li><p>严格交替法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WHILE(TRUE)</div><div class="line">&#123;</div><div class="line">  WHILE(turn != 0);</div><div class="line">  critical_region();</div><div class="line">  turn = 1;</div><div class="line">  noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WHILE(TRUE)</div><div class="line">&#123;</div><div class="line">  WHILE(turn != 1);</div><div class="line">  critical_region();</div><div class="line">  turn = 0;</div><div class="line">  noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 整型变量turn的初值为零，用于跟踪轮到哪个进程进入临界区。一开始进程0检查turn，发现是0，所以进入临界区。同时进程1也在检查turn，不停的检查是否变为1。这样就产生了<a href="https://baike.baidu.com/item/%E5%BF%99%E7%A2%8C%E7%AD%89%E5%BE%85/16256157?fr=aladdin" target="_blank" rel="external">忙等待</a>。还有一种情况就是进程0退出临界区并将turn设置为1，此时进程0和1都在忙非临界区的任务，但是进程0先忙完需要进入临界区，由于turn为1所以进程0不能进入临界区</p></li><li>Peterson解决方案</li><li>TSL语句</li></ol></li><li><p>信号量</p><p> 用一个整型变量来累计唤醒次数，供以后使用。<br> 在这个解决方案中用了三个信号量。</p><ul><li>full 用来记录满的缓冲槽的数目，初值为0</li><li>empty 用来记录空的缓冲槽的数目，初值为缓冲区内槽的数目</li><li><p>mutex 用来确保生产者和消费者不会同时访问缓冲区，初值为1</p><p>多个进程使用初值为1的信号量可以保证同时只有一个进程可以进入临界区，如果每个进程在进入临界区之前执行一个down，退出之后执行一个up就可以保证互斥</p></li></ul></li><li><p>互斥</p><p> 若不需要信号量的计数能力，有时可以使用信号量的另一个版本—-互斥<br> 互斥是一个可以处于两态之一的变量：解锁(mutex_unlock)和加锁(mutex_lock)</p></li><li>管程<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3></li><li>先到先服务</li><li>最短作业优先</li><li>最短剩余时间优先</li><li>三级调度<ul><li>准入调度器</li><li>内存调度器</li><li>CPU调度器<h3 id="交互系统中的调度"><a href="#交互系统中的调度" class="headerlink" title="交互系统中的调度"></a>交互系统中的调度</h3></li></ul></li><li>时间片轮转调度</li><li><p>优先级调度</p><p> 注意时常对优先级进行调整，防止低优先级的进程饿死</p></li><li>多重队列</li><li>最短进程优先（老化算法预估进程运行所需时间）</li><li>保证调度算法</li><li>彩票调度算法</li><li>公平分享调度<h3 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h3></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程介绍&quot;&gt;&lt;a href=&quot;#进程介绍&quot; class=&quot;headerlink&quot; title=&quot;进程介绍&quot;&gt;&lt;/a&gt;进程介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程的创建&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统初始化&lt;/li&gt;
&lt;li&gt;正在运行的进程执
      
    
    </summary>
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Octave安装forge</title>
    <link href="http://blog.huhaobin.cn/2018/04/30/OctaveInstallforge/"/>
    <id>http://blog.huhaobin.cn/2018/04/30/OctaveInstallforge/</id>
    <published>2018-04-30T13:56:20.000Z</published>
    <updated>2018-04-30T02:26:40.678Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装缺少的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install liboctave-dev</div></pre></td></tr></table></figure></li><li><p>安装control</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">octave-cli</div><div class="line">pkg install -forge fuzzy-logic-toolkit</div><div class="line">pkg install -forge control</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装缺少的库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="Octave" scheme="http://blog.huhaobin.cn/categories/Octave/"/>
    
    
      <category term="Octave" scheme="http://blog.huhaobin.cn/tags/Octave/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之神经网络</title>
    <link href="http://blog.huhaobin.cn/2018/04/29/machine-learning4/"/>
    <id>http://blog.huhaobin.cn/2018/04/29/machine-learning4/</id>
    <published>2018-04-29T13:56:20.000Z</published>
    <updated>2018-04-29T09:13:42.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>a在这里表示神经网络中的神经元</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>二元分类(Binary classification)</li><li>多分类(Multi-class classification)</li></ol><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="/image/costfunctionBetweenLRandNeuralNetwork.png" alt=""></p><ul><li>L: 网络中的总层数</li><li>K: 输出层神经元的数量</li><li>S<sub>l</sub>: l 层的总神经元数量(不算偏置单元)额<!-- 注意： 这是单个 -->为了计算代价函数的最小值，我们使用反向传播算法</li></ul><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>(计算出代价函数下降最快的方向)<br>给出训练集{(x<sup>(1)</sup>,y<sup>(1)</sup>)⋯(x<sup>(m)</sup>,y<sup>(m)</sup>)}</p><p>令 Δ<sub>i,j</sub><sup>(l)</sup> := 0 for all (l,i,j), (hence you end up having a matrix full of zeros)</p><p>For training example t =1 to m:</p><ol><li>Set a<sup>(1)</sup>:=x<sup>(t)</sup></li><li>Perform forward propagation to compute a<sup>(l)</sup> for l=2,3,…,L<br><img src="/image/GradientForNeuralNetwork.png" alt=""></li><li>Using y(t), compute δ<sup>(L)</sup>=a<sup>(L)</sup>−y<sup>(t)</sup></li><li>Compute δ<sup>(L−1)</sup>,δ<sup>(L−2)</sup>,…,δ<sup>(2)</sup> using δ<sup>(l)</sup>=((Θ<sup>(l)</sup>)<sup>T</sup>δ<sup>(l+1)</sup>) .∗ a<sup>(l)</sup> .∗ (1−a<sup>(l)</sup>)</li><li>Δ<sub>i,j</sub><sup>(l)</sup>:=Δ<sub>i,j</sub><sup>(l)</sup>+a<sub>j</sub><sup>(l)</sup>δ<sub>i</sub><sup>(l+1)</sup> or with vectorization, Δ<sup>(l)</sup>:=Δ<sup>(l)</sup>+δ<sup>(l+1)</sup>(a<sup>(l)</sup>)<sup>T</sup></li></ol><p>Hence we update our new Δ matrix.</p><ul><li>D<sub>i,j</sub>(l):=1/m(Δ<sub>i,j</sub><sup>(l)</sup>+λΘ<sub>i,j</sub><sup>(l)</sup>), if j≠0.</li><li>D<sub>i,j</sub><sup>(l)</sup>:=1/mΔ<sub>i,j</sub><sup>(l)</sup> If j=0</li></ul><p>所以得出J的微分为<img src="/image/partialDerivativeOfJInNN.png" alt=""></p><h2 id="向量展开"><a href="#向量展开" class="headerlink" title="向量展开"></a>向量展开</h2><p>在之前的学习过程中我们总是使用fminunc来优化参数，但是他要求所有的输入和输出均是向量，我们在神经网络中使用的时候只能把Theta矩阵和Gradient矩阵进行向量化</p><ul><li>size(Theta1) = 10 * 11</li><li>size(Theta2) = 10 * 11</li><li>size(Theta3) = 1 * 11<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thetaVector = [ Theta1(:); Theta2(:); Theta3(:); ]</div><div class="line">deltaVector = [ D1(:); D2(:); D3(:) ]</div></pre></td></tr></table></figure></li></ul><p>恢复为矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Theta1 = reshape(thetaVector(1:110),10,11)</div><div class="line">Theta2 = reshape(thetaVector(111:220),10,11)</div><div class="line">Theta3 = reshape(thetaVector(221:231),1,11)</div></pre></td></tr></table></figure></p><h2 id="梯度计算结果校验"><a href="#梯度计算结果校验" class="headerlink" title="梯度计算结果校验"></a>梯度计算结果校验</h2><p>反向传播算法复杂多变，我们使用导数的定义来校验反向传播得到的结果是否正确(相差很小)，当确定正确之后关掉梯度校验。因为他很 <strong>慢</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">epsilon = 1e-4;</div><div class="line">for i = 1:n,</div><div class="line">  thetaPlus = theta;</div><div class="line">  thetaPlus(i) += epsilon;</div><div class="line">  thetaMinus = theta;</div><div class="line">  thetaMinus(i) -= epsilon;</div><div class="line">  gradApprox(i) = (J(thetaPlus) - J(thetaMinus))/(2*epsilon)</div><div class="line">end;</div></pre></td></tr></table></figure><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>为了避免神经网络因为相同的Theta而陷入冗余的计算，范围是[-INIT_EPSILON,INIT_EPSILON]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.</div><div class="line"></div><div class="line">Theta1 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div><div class="line">Theta2 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div><div class="line">Theta3 = rand(1,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div></pre></td></tr></table></figure></p><h2 id="网络选择-的步骤"><a href="#网络选择-的步骤" class="headerlink" title="网络选择 的步骤"></a>网络选择 的步骤</h2><ul><li>Number of input units = dimension of features x(i)</li><li>Number of output units = number of classes</li><li>Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units)</li><li>Defaults: 1 hidden layer. If you have more than 1 hidden layer, then it is recommended that you have the same number of units in every hidden layer.<h2 id="网络训练的步骤"><a href="#网络训练的步骤" class="headerlink" title="网络训练的步骤"></a>网络训练的步骤</h2></li><li>Randomly initialize the weights</li><li>Implement forward propagation to get hΘ(x<sup>(i)</sup>) for any x<sup>(i)</sup></li><li>Implement the cost function</li><li>Implement backpropagation to compute partial derivatives</li><li>Use gradient checking to confirm that your backpropagation works. Then disable gradient checking.</li><li>Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta.</li></ul><p>When we perform forward and back propagation, we loop on every training example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i = 1:m,</div><div class="line">   Perform forward propagation and backpropagation using example (x(i),y(i))</div><div class="line">   (Get activations a(l) and delta terms d(l) for l = 2,...,L</div></pre></td></tr></table></figure></p><p>(There are m training sets)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;a在这里表示神经网络中的神经元&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二元分类(Binary classificati
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之神经网络介绍</title>
    <link href="http://blog.huhaobin.cn/2018/04/28/machine-learning3/"/>
    <id>http://blog.huhaobin.cn/2018/04/28/machine-learning3/</id>
    <published>2018-04-28T13:56:20.000Z</published>
    <updated>2018-04-29T05:57:51.219Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。</p><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><ol><li>层： 输入层、隐藏层、输出层</li><li><p>仍然使用sigmoid函数<br>3.<br><img src="/image/AppearanceOfNeuronNetwork.png" alt="基本形式"></p><ul><li>a<sub>i</sub><sup>j</sup>: 第j层的第i个元素</li><li><p>Θ<sup>(j)</sup>: j层到j+1层的权重映射矩阵</p><p><strong>如果网络在j层有s<sub>j</sub>个单元，j+1层有s<sub>j+1</sub>个单元，那么Θ<sup>(j)</sup>的维度为s<sub>j+1</sub>×(s<sub>j</sub>+1)</strong></p></li></ul></li><li>向量化<br>对于中间层的计算，我们可以定义Z使得<br><img src="/image/neuralNetworkHiddenCompute.png" alt=""> 变形为<img src="/image/neuralNetworkHiddenCompute-z.png" alt=""><br>进行向量化之后<br><img src="/image/NeuralNetworkVectlize.png" alt=""><br>也就是说<br><img src="/image/ZNeuralNetwork.png" alt=""> <img src="/image/HNeuralNetwork.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。&lt;/p&gt;
&lt;h2 id=&quot;表示&quot;&gt;&lt;a href=&quot;#表示&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之逻辑分类问题</title>
    <link href="http://blog.huhaobin.cn/2018/04/27/machine-learning2/"/>
    <id>http://blog.huhaobin.cn/2018/04/27/machine-learning2/</id>
    <published>2018-04-27T13:56:20.000Z</published>
    <updated>2018-04-28T08:20:46.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑回归问题"><a href="#逻辑回归问题" class="headerlink" title="逻辑回归问题"></a>逻辑回归问题</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><ol><li>逻辑回归<br><img src="/image/HypothesisRepresentation.png" alt="逻辑回归"></li><li><p>线性回归</p><p>线性回归中 <strong>g(z)=1</strong></p></li></ol><h2 id="决策边界-Decision-boundary"><a href="#决策边界-Decision-boundary" class="headerlink" title="决策边界(Decision boundary)"></a>决策边界(Decision boundary)</h2><p>  一条分割y=0和y=1的线</p><h2 id="代价函数-cost-function"><a href="#代价函数-cost-function" class="headerlink" title="代价函数(cost function)"></a>代价函数(cost function)</h2><p>  <img src="/image/CostFunctionInLogisticRegression.png" alt="代价函数"><br>  整合之后<br>  <img src="/image/CostFunctionForLRM.png" alt="整合代价函数"><br>  gradient计算<br>  <img src="/image/GradientForLogstic.png" alt="gradient"></p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>  <img src="/image/GradientDescentForLRM.png" alt="梯度下降法"></p><h2 id="过度拟合"><a href="#过度拟合" class="headerlink" title="过度拟合"></a>过度拟合</h2><p>  过度拟合只会充分的拟合训练数据集，对数据预测并不会得到想要的值</p><ul><li>解决方法(regularization)</li></ul><h2 id="regularization"><a href="#regularization" class="headerlink" title="regularization"></a>regularization</h2><ol><li>重新设置代价函数(cost function)J<br><img src="/image/RegularizedLinerRegression.png" alt="J"><br>给每个theta做惩罚，用足够大的lambda去削弱theta的作用，从而平滑h。但是lambda太大的话将导致欠拟合，太大的时候得到的仅仅是一条扁平的直线</li><li>梯度下降法<br><img src="/image/RegularizationGradientDescent.png" alt=""><br>将theta分开更新是因为在重新设计代价函数的时候没有给theta惩罚，简化之后为<img src="/image/RegularizationGradientDescentJ.png" alt=""></li><li>归一化求代价函数的最小值<br><img src="/image/RegularizationNormalEquation.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑回归问题&quot;&gt;&lt;a href=&quot;#逻辑回归问题&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归问题&quot;&gt;&lt;/a&gt;逻辑回归问题&lt;/h1&gt;&lt;h2 id=&quot;系统函数&quot;&gt;&lt;a href=&quot;#系统函数&quot; class=&quot;headerlink&quot; title=&quot;系
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之线性回归问题</title>
    <link href="http://blog.huhaobin.cn/2018/04/23/machine-learning1/"/>
    <id>http://blog.huhaobin.cn/2018/04/23/machine-learning1/</id>
    <published>2018-04-23T13:56:20.000Z</published>
    <updated>2018-04-28T08:20:01.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性回归问题"><a href="#线性回归问题" class="headerlink" title="线性回归问题"></a>线性回归问题</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><ol><li>假设系统函数<br><img src="/image/Hypothesis.png" alt="系统函数"></li><li><p>代价函数<br><img src="/image/costFunction.png" alt="代价函数"></p><p> alpha: 学习效率</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2></li><li>普适算法<br><img src="/image/GradientDescentAlgo.png" alt="普适算法"></li><li><p>线性回归中<br><img src="/image/GradientDescentForLinearRegression.png" alt="线性回归"><br><img src="/image/GDALRS.png" alt="去微分"></p><p> <strong>记得同步更新theta</strong></p><h2 id="多变量的线性回归问题"><a href="#多变量的线性回归问题" class="headerlink" title="多变量的线性回归问题"></a>多变量的线性回归问题</h2><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3></li><li><p>数据缩放()</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X = X/MAX(X);</div></pre></td></tr></table></figure><p> 使得X <strong>接近</strong>[-1,1]区间</p></li><li><p>平均值正常化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X = (X-U)/(max(X)-MIN(x)) // U是X的平均值</div></pre></td></tr></table></figure></li><li><p>数据归一化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theta = pinv(X&apos;*X)*X&apos;*y;</div></pre></td></tr></table></figure></li></ol><p>可以用正态方程求解代价函数最小值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性回归问题&quot;&gt;&lt;a href=&quot;#线性回归问题&quot; class=&quot;headerlink&quot; title=&quot;线性回归问题&quot;&gt;&lt;/a&gt;线性回归问题&lt;/h1&gt;&lt;h2 id=&quot;代价函数&quot;&gt;&lt;a href=&quot;#代价函数&quot; class=&quot;headerlink&quot; title=&quot;代
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>qt画图</title>
    <link href="http://blog.huhaobin.cn/2018/04/21/qtPainting/"/>
    <id>http://blog.huhaobin.cn/2018/04/21/qtPainting/</id>
    <published>2018-04-21T06:15:31.118Z</published>
    <updated>2018-04-21T06:15:31.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QcustomPlot"><a href="#QcustomPlot" class="headerlink" title="QcustomPlot"></a>QcustomPlot</h2><ol><li><p>下载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.qcustomplot.com</div></pre></td></tr></table></figure></li><li><p>把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可</p></li><li>pro文件中QT += widgets printsupport</li><li><p>使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">QVector x(101), y(101); // initialize with entries 0..100</div><div class="line">for (int i=0; i&lt;101; ++i)</div><div class="line">&#123;</div><div class="line">x[i] = i/50.0 – 1; // x goes from -1 to 1</div><div class="line">y[i] = x[i]*x[i]; // let’s plot a quadratic function</div><div class="line">&#125;</div><div class="line">qDebug()&lt;&lt;“data has been created”;</div><div class="line">ui-&gt;black_line-&gt;addGraph();</div><div class="line">qDebug()&lt;&lt;“begin painting”;</div><div class="line">ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);</div><div class="line">ui-&gt;black_line-&gt;replot();</div><div class="line">qDebug()&lt;&lt;“finish”;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QcustomPlot&quot;&gt;&lt;a href=&quot;#QcustomPlot&quot; class=&quot;headerlink&quot; title=&quot;QcustomPlot&quot;&gt;&lt;/a&gt;QcustomPlot&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载&lt;/p&gt;
 &lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Qt" scheme="http://blog.huhaobin.cn/categories/Qt/"/>
    
    
      <category term="上位机 Qt" scheme="http://blog.huhaobin.cn/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA-Qt/"/>
    
  </entry>
  
  <entry>
    <title>mysqldb安装</title>
    <link href="http://blog.huhaobin.cn/2018/04/19/MySQLdb/"/>
    <id>http://blog.huhaobin.cn/2018/04/19/MySQLdb/</id>
    <published>2018-04-19T13:56:20.000Z</published>
    <updated>2018-04-19T08:35:09.917Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install python3-mysqldb</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="python" scheme="http://blog.huhaobin.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>新博客站的第一篇文章</title>
    <link href="http://blog.huhaobin.cn/2018/04/19/about/"/>
    <id>http://blog.huhaobin.cn/2018/04/19/about/</id>
    <published>2018-04-19T07:49:39.519Z</published>
    <updated>2017-09-30T08:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百废待兴"><a href="#百废待兴" class="headerlink" title="百废待兴"></a>百废待兴</h2><p>自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本</p><h2 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h2><p>虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺.</p><h2 id="后悔莫及"><a href="#后悔莫及" class="headerlink" title="后悔莫及"></a>后悔莫及</h2><p>前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞</p><h3 id="有时间继续更新"><a href="#有时间继续更新" class="headerlink" title="有时间继续更新"></a>有时间继续更新</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百废待兴&quot;&gt;&lt;a href=&quot;#百废待兴&quot; class=&quot;headerlink&quot; title=&quot;百废待兴&quot;&gt;&lt;/a&gt;百废待兴&lt;/h2&gt;&lt;p&gt;自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名
      
    
    </summary>
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/categories/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/tags/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>搭建ssr</title>
    <link href="http://blog.huhaobin.cn/2018/04/19/shadowsocksr/"/>
    <id>http://blog.huhaobin.cn/2018/04/19/shadowsocksr/</id>
    <published>2018-04-18T16:36:51.000Z</published>
    <updated>2018-04-19T02:58:49.394Z</updated>
    
    <content type="html"><![CDATA[<ol><li>服务部署<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum -y install wget</div><div class="line"></div><div class="line">wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</div></pre></td></tr></table></figure></li></ol><p>备用脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum -y install wget</div><div class="line"></div><div class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</div></pre></td></tr></table></figure></p><ol><li><p>脚本安装<br>需要注意的有</p><ol><li>protocol 最好选择auth_chain_a</li><li>obfs(混淆) 千万不要选择tls <strong>有被墙的风险</strong></li></ol></li><li><p>添加开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/rc.local</div><div class="line"></div><div class="line">python /usr/local/shadowsocksr/shadowsocks/server.py -c /etc/shadowsocksr/user-config.json a &amp;</div></pre></td></tr></table></figure></li><li><p>加速服务(BBR)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh</div><div class="line"></div><div class="line">chmod +x bbr.sh</div><div class="line"></div><div class="line">./bbr.sh</div></pre></td></tr></table></figure></li><li><p>客户端地址<br>windows</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases/download/4.7.0/ShadowsocksR-4.7.0-win.7z</div></pre></td></tr></table></figure></li></ol><p>linux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install python-pip</div><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure></p><p>android<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.5.6/shadowsocks--universal-4.5.6.apk</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;服务部署&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux定时执行任务</title>
    <link href="http://blog.huhaobin.cn/2018/04/18/SystemTimer/"/>
    <id>http://blog.huhaobin.cn/2018/04/18/SystemTimer/</id>
    <published>2018-04-18T14:11:07.000Z</published>
    <updated>2018-04-18T08:12:50.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户级任务"><a href="#用户级任务" class="headerlink" title="用户级任务"></a>用户级任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab -e</div></pre></td></tr></table></figure><p>格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">min hour dayofmonth monthofyear dayofweek  command</div></pre></td></tr></table></figure></p><ol><li>会进行语法检查<h2 id="系统级任务"><a href="#系统级任务" class="headerlink" title="系统级任务"></a>系统级任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nano /etc/crontab</div></pre></td></tr></table></figure></li></ol><p>格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">min hour dayofmonth monthofyear dayofweek user command</div></pre></td></tr></table></figure></p><ol><li>不会进行语法检查</li></ol><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li>配置之后需要重启crond服务<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service cron restart</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用户级任务&quot;&gt;&lt;a href=&quot;#用户级任务&quot; class=&quot;headerlink&quot; title=&quot;用户级任务&quot;&gt;&lt;/a&gt;用户级任务&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux网络连接后执行脚本</title>
    <link href="http://blog.huhaobin.cn/2018/04/18/DoThingsAfterInternetConnetc/"/>
    <id>http://blog.huhaobin.cn/2018/04/18/DoThingsAfterInternetConnetc/</id>
    <published>2018-04-18T14:11:07.000Z</published>
    <updated>2018-04-18T02:31:08.111Z</updated>
    
    <content type="html"><![CDATA[<p>在Debian/Ubuntu的发行版本里，网络建立前、后和网络断开前、后都会到/etc/network/里运行相应目录下的脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if-down.d -- 网络关闭前</div><div class="line">if-post-down.d -- 网络关闭后</div><div class="line">if-pre-up.d -- 网络建立前</div><div class="line">if-up.d -- 网络建立后</div></pre></td></tr></table></figure></p><p>所以把自己的脚本放在/etc/network/if-up.d/目录下面就可以了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在Debian/Ubuntu的发行版本里，网络建立前、后和网络断开前、后都会到/etc/network/里运行相应目录下的脚本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;di
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>hexo个人博客的美化</title>
    <link href="http://blog.huhaobin.cn/2018/04/11/ButifyBlog/"/>
    <id>http://blog.huhaobin.cn/2018/04/11/ButifyBlog/</id>
    <published>2018-04-10T16:00:00.000Z</published>
    <updated>2018-04-21T06:41:26.118Z</updated>
    
    <content type="html"><![CDATA[<p>SEO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure></p><p>在【站点配置文件】hexo_blog_config.yml 中添加如下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># hexo sitemap</div><div class="line">sitemap:</div><div class="line">  path: sitemap.xml</div><div class="line">baidusitemap:</div><div class="line">  path: baidusitemap.xml</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SEO&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
      <category term="hexo" scheme="http://blog.huhaobin.cn/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://blog.huhaobin.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>ssh反向代理进行内网穿透</title>
    <link href="http://blog.huhaobin.cn/2018/04/10/SSHReverseproxy/"/>
    <id>http://blog.huhaobin.cn/2018/04/10/SSHReverseproxy/</id>
    <published>2018-04-09T18:00:55.000Z</published>
    <updated>2018-04-15T12:42:59.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="公网主机配置"><a href="#公网主机配置" class="headerlink" title="公网主机配置"></a>公网主机配置</h3><ol><li><p>修改sshd的配置文件，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nano /etc/ssh/sshd_config</div></pre></td></tr></table></figure><p>在最后面添加GatewayPorts yes,重启sshd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service sshd restart</div></pre></td></tr></table></figure><p><strong>作用：设置反向代理的ip是0.0.0.0，而不是127.0.0.1</strong></p><h3 id="内网主机配置"><a href="#内网主机配置" class="headerlink" title="内网主机配置"></a>内网主机配置</h3><p>命令格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -NfR &lt;公网端口&gt;:&lt;要代理的ip&gt;:&lt;要代理的端口&gt; &lt;用户名&gt;@公网主机ip (-i /path/to/privatekey)</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-N：ssh不执行命令</div><div class="line">-f：后台执行</div><div class="line">-R：反向代理</div></pre></td></tr></table></figure><p><strong>private key 应该时600权限</strong><br>查看是否启动，在公网主机上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">netstat -tnl|grep &lt;公网端口&gt;</div><div class="line"></div><div class="line">tcp        0      0 0.0.0.0:&lt;公网端口&gt;            0.0.0.0:*               LISTEN</div><div class="line">tcp6       0      0 :::&lt;公网端口&gt;                 :::*                    LISTEN</div></pre></td></tr></table></figure><p>说明执行成功</p><h3 id="免密，稳定通道"><a href="#免密，稳定通道" class="headerlink" title="免密，稳定通道"></a>免密，稳定通道</h3></li><li><p>免密<br>在内网主机上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id &lt;用户名&gt;@公网主机ip</div></pre></td></tr></table></figure></li><li><p>稳定通道(两种方法)</p><ol><li>autossh<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install autossh</div><div class="line">autossh -M 2333 &lt;公网端口&gt;:&lt;要代理的ip&gt;:&lt;要代理的端口&gt; &lt;用户名&gt;@公网主机ip (-i /path/to/publickey)</div></pre></td></tr></table></figure></li></ol><p><em>-M : 回显测试</em></p><ol><li><p>ssh心跳包</p><ul><li>单独客户设置（方法1）<br>修改/etc/ssh/ssh_config，添加</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ServerAliveInterval 60</div><div class="line">ServerAliveCountMax 9999999999</div></pre></td></tr></table></figure><ul><li>服务器设置（方法二）{新客户端可以不用设置，服务器负责维护}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/ssh/sshd_config</div><div class="line"># 添加</div><div class="line">ClientAliveInterval 30</div><div class="line">ClientAliveCountMax 6</div></pre></td></tr></table></figure></li></ul></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;公网主机配置&quot;&gt;&lt;a href=&quot;#公网主机配置&quot; class=&quot;headerlink&quot; title=&quot;公网主机配置&quot;&gt;&lt;/a&gt;公网主机配置&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修改sshd的配置文件，&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="反向代理" scheme="http://blog.huhaobin.cn/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法 C++描述 第二章</title>
    <link href="http://blog.huhaobin.cn/2018/04/07/CA2/"/>
    <id>http://blog.huhaobin.cn/2018/04/07/CA2/</id>
    <published>2018-04-07T14:11:07.000Z</published>
    <updated>2018-04-07T12:15:13.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="template-模板"><a href="#template-模板" class="headerlink" title="template 模板"></a>template 模板</h2><ol><li><p>类模板<br>假设一个类中数据成员的数据类型不能确定。或者是某个成员函数的參数或返回值的类型不能确定。就必须将此类声明为模板，它的存在不是代表一个详细的、实际的类，而是代表着一类类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template &lt;class Type&gt;</div><div class="line">class foo</div><div class="line">&#123;</div><div class="line">  private:</div><div class="line">    Type a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>类模板的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">类名&lt;实际的类型&gt;</div></pre></td></tr></table></figure><p>类模板的使用实际上是将类模板实例化成一个详细的类</p></li><li><p>在类外面定义函数模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename（或class) T&gt;</div><div class="line">&lt;返回类型&gt;&lt;函数名&gt;(參数表)</div><div class="line">&#123;</div><div class="line">    函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">template&lt;typename（或class) T&gt;</div><div class="line">T fuc(T x, T y)</div><div class="line">&#123;</div><div class="line">    T x;</div><div class="line">    //……</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>模板函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">double d;</div><div class="line">    int a;</div><div class="line">    fuc(d,a);</div><div class="line">则系统将用实參d的数据类型double去取代函数模板中的T生成函数：</div><div class="line"></div><div class="line">double fuc(double x,int y)</div><div class="line">&#123;</div><div class="line">   double x;</div><div class="line">   //……</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>模板函数的生成就是将函数模板的类型形參实例化的过程。</p></li></ol><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>  队列的一种有效表示方法是用数组，把他看成环形结构</p><ul><li>判断队列为空  rear == front</li><li>队尾插入操作  rear = (++rear)%MaxSize</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ol><li><p>引理</p><ul><li><p>一棵二叉树第i层上最多结点个数为2<sup>i-1</sup>, 一个深度为k的二叉树最多节点数为2<sup>k</sup>-1</p><p>n个节点的完全二叉树可以存放在一维数组tree[n+1]中</p></li><li>任何一个包含n个节点的完全二叉树，如果采用上述的方法表示，对于任何下标的节点i来说，1 &lt;= i &lt;= n有：<ol><li>当 i != 1 时，parent(i)在 ⌊i/2⌋。当i == 1时，i是树根没有parent</li><li>当 2i &lt;= n 时，lchild(i)在2i。如果2i &gt; n，i没有左孩子</li><li>当 2i + 1 &lt;= n 时，rchild(i)在2i+1，否则没有右孩子</li></ol></li></ul></li><li><p><strong>二叉搜索树</strong></p><p>特征</p><ol><li>每个元素都有一个键值，并且没有两个元素键值相同</li><li>左子树的键值(如果有的话)都小于树根的键值</li><li>右子树的键值(如果有的话)都大于树根的键值</li><li>左右子树也都是二叉搜索树</li></ol></li><li><p>堆(Heap)</p><ol><li>堆性质：每个节点的值都至少与其孩子一样大（一样小） —&gt;  依次递增（减）</li><li>堆排序：这可真的是一个秀的头疼的操作。靠其自身的insert和deletemax构建新堆获得旧堆的顺序</li></ol></li><li><p>集合与 <strong>不相交</strong> 集合的并集</p><ol><li>用森林表示集合，每个集合都可以表示为一棵树。把孩子节点链接到父节点上</li><li>为了得到两个集合的并集，我们可以把一课树的树根的父节点域设置为另一棵树的树根( <strong>不相交</strong>)</li><li>忽略集合的名字并且用表示集合的树的树根来标志该集合</li><li><em>权重规则</em> ： 如果以i为树根的树所包含的节点少于以j为树根的树，那么就令j成为i的父节点。否则i成为j的父节点</li><li><em>收缩规则</em> ： 如果节点j在节点i到树根的路径上，并且p[i] != root[i],那么将p[i]置为root[i]<br>—–&gt; p[j]及路径上所有节点的父节点置为root[i]</li></ol></li><li><p>图</p><ol><li>图的定义和特点<ol><li>欧拉定义定点的度等于与他相接的边的条数</li></ol><ul><li>对于有向图来说：V的入/出度是以v为头/尾的所有边的条数</li></ul><ol><li>当且仅当所有定点的度数都是偶数，满足这样条件的路径被成为 <strong>欧拉路径</strong></li><li>我们通常用G=(V, E)来表示一个图</li></ol><ul><li>V 是有穷非空的定点的集合</li><li>E 是顶点对称的集合，又被称为边</li><li>无向图中任意边的顶点对都是无序的 (u, v)</li><li>有向图中任意边的顶点对都是有序的 <u, v="">， u是头，v是尾</u,></li></ul><ol><li>图不能包含定点v到自己的边。这样的边被称为自边或者自环</li><li>图不能有一条边重复多次，如果去掉这个限制那么我们得到的是多图</li></ol><ul><li>任意包含n个顶点的无向图的最大边数为 n(n-1)/2，包含最大边数的无向图是完全的</li><li>任意包含n个顶点的有向图的最大边数为 n(n-1)</li></ul><ol><li>路径的长度就是其中的边数</li><li>简单路径： 路径中可能除了第一个和最后一个都是不同的顶点（只有可能第一个和最后一个相同，其他的都不同）</li><li>环： 第一个和最后一个相同的路径</li></ol></li><li>图的表示<ol><li>邻接矩阵</li></ol><ul><li>邻接矩阵是一个n*n的矩阵</li><li>若存在边(i, j)，则a[i, j] = 1,其他的等于0</li><li>无向图的邻接矩阵是对称的</li><li>无向图上的顶点i其度数等于它对应的行之和</li><li>有向图上行之和是出度，列之和是入度</li></ul><ol><li>邻接表<br><img src="/image/linjiebiao.jpg" alt="邻接表"></li><li>邻接多重表</li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;template-模板&quot;&gt;&lt;a href=&quot;#template-模板&quot; class=&quot;headerlink&quot; title=&quot;template 模板&quot;&gt;&lt;/a&gt;template 模板&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类模板&lt;br&gt;假设一个类中数据成员的数据类型不能确
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://blog.huhaobin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治策略</title>
    <link href="http://blog.huhaobin.cn/2018/04/07/CA3/"/>
    <id>http://blog.huhaobin.cn/2018/04/07/CA3/</id>
    <published>2018-04-07T14:11:07.000Z</published>
    <updated>2018-04-09T08:46:58.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h2><h3 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h3><p>给定函数来计算n个输入， <strong>分治策略</strong> 建议将输入分成k个子集，1&lt;k&lt;=n,得到k个子问题</p><h4 id="解递归关系"><a href="#解递归关系" class="headerlink" title="解递归关系"></a>解递归关系</h4><p>很多分治算法的复杂度是这样的</p><p>$$T(n)= a_{1}^n $$</p><h3 id="残缺棋盘"><a href="#残缺棋盘" class="headerlink" title="残缺棋盘"></a>残缺棋盘</h3><p>描述: 有2<sup>k</sup>* 2<sup>k</sup>个方格的棋盘中恰好有一个方格是坏的</p><p>要求：用三方块把残缺棋盘铺满，三方块不能重叠，不能盖住坏的方格</p><p>—–&gt; 需要用(2<sup>2k</sup>-1)/3个三方块</p><p>解决思路(分治法)：</p><ol><li>划分成小棋盘比如4个2<sup>k-1</sup>* 2<sup>k-1</sup>，这样只有一个小棋盘有坏的</li><li>我们用一个三方块盖住没有坏方格的三个棋盘</li><li>递归</li><li>棋盘的大小缩为1*1时，递归终止</li></ol><h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><p>描述： 在n个已经按升序/降序排列好的元素中搜索是否存在元素x</p><p>要求： 已经按 <strong>升序/降序</strong> 排列好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分治策略&quot;&gt;&lt;a href=&quot;#分治策略&quot; class=&quot;headerlink&quot; title=&quot;分治策略&quot;&gt;&lt;/a&gt;分治策略&lt;/h2&gt;&lt;h3 id=&quot;一般方法&quot;&gt;&lt;a href=&quot;#一般方法&quot; class=&quot;headerlink&quot; title=&quot;一般方法&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="计算机算法" scheme="http://blog.huhaobin.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>读书记录</title>
    <link href="http://blog.huhaobin.cn/2018/04/06/TheCollectOfReading/"/>
    <id>http://blog.huhaobin.cn/2018/04/06/TheCollectOfReading/</id>
    <published>2018-04-06T12:45:12.000Z</published>
    <updated>2018-04-06T07:04:44.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机类"><a href="#计算机类" class="headerlink" title="计算机类"></a>计算机类</h2><ol><li>计算机算法(C++语言描述) 第二版</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机类&quot;&gt;&lt;a href=&quot;#计算机类&quot; class=&quot;headerlink&quot; title=&quot;计算机类&quot;&gt;&lt;/a&gt;计算机类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;计算机算法(C++语言描述) 第二版&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="笔记" scheme="http://blog.huhaobin.cn/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>进程间通信</title>
    <link href="http://blog.huhaobin.cn/2018/04/01/processCom/"/>
    <id>http://blog.huhaobin.cn/2018/04/01/processCom/</id>
    <published>2018-04-01T14:11:07.000Z</published>
    <updated>2018-03-31T07:45:41.704Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>信号</p><ul><li>由于某些错误而产生的事件</li><li>可以设定信号触发之后的处理方式，但信号是系统已经确定的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void (*signals(int signum, void(*hangdler)(int)))(int);</div><div class="line">int sigaction(int signum, const struct sigaction * act, struct sigaction * addr)</div></pre></td></tr></table></figure></li></ul></li><li><p>管道和命名管道<br><strong>实质是先进先出，半双工的数据结构，双方通信需要两个管道</strong></p><ul><li>管道：只能用于相互关联的进程间通信，如：父子进程</li><li>命名管道： = 特殊文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkfifo(const char * pathname, mode_t mode); //建立管道文件</div><div class="line">read() write() close() 均可操作</div></pre></td></tr></table></figure></li></ul></li><li><p>信号量<br>主要用于控制多个线程对临界区资源的访问</p></li><li><p>消息队列<br>将消息按队列方式组成的链表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int msgget(key_t key, int msgflg);</div><div class="line">int msgsnd(int msgid, const void * msgptr, int msgsz, int msgflg);</div><div class="line">int msgrcv(int msgid, const void * msgptr, int msgsz, long msgtyp, int msgflg);</div><div class="line">int msgctl(int msgid, int cmd, struct msgid_ds *buf);</div></pre></td></tr></table></figure></li><li><p>共享内存<br>直接操作内存，不用复制文件 <strong>系统创建的特殊地址空间，允许多个不相关的进程使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int shmget(key_t key, int shmflg);</div><div class="line">int shmat(int shmid, const void * shmaddr, int shmflg);</div><div class="line">int shmdt(const void * shmaddr);</div><div class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;信号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于某些错误而产生的事件&lt;/li&gt;
&lt;li&gt;可以设定信号触发之后的处理方式，但信号是系统已经确定的&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
</feed>
