<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saber110</title>
  
  <subtitle>越努力,越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huhaobin.cn/"/>
  <updated>2019-04-06T14:00:39.539Z</updated>
  <id>http://blog.huhaobin.cn/</id>
  
  <author>
    <name>Hu haobin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://blog.huhaobin.cn/2019/04/04/computernetworking1/"/>
    <id>http://blog.huhaobin.cn/2019/04/04/computernetworking1/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-04-06T14:00:39.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>计算机网络就是互连的、自治的计算机集合<ul><li>通过交换网络进行互连</li></ul></li><li>交换<ul><li>动态转接</li><li>动态资源分配和传输</li></ul></li><li><p>电路交换（电路建立—数据传输—电路拆除）</p><ul><li><p>多路复用</p><ul><li>频分复用（FDM）— 同轴电缆</li><li>时分复用（TDM) — 时间分帧、分片</li><li><p>码分复用（CDM）— 每个用户有个m bit的各个用户相互正交的码片序列</p><p>每个原始信号的bit位被用码片序列编码为m bit;1 -&gt; +1; 0 -&gt; -1;</p></li><li>波分复用（光的频分复用）</li></ul></li></ul></li><li>报文交换<ul><li>一次将一个报文全部传输</li><li>存储转发整个报文</li></ul></li><li><p>分组交换</p><ol><li>报文的拆分和重组</li><li>产生额外开销</li><li>存储转发小分组</li><li>便于实现统计复用</li><li>由于流水线技术，速度比报文交换要快，硬件要求要低</li><li>适用于突发数据传输<ul><li>充分利用资源</li><li>无需建立电路</li></ul></li><li><p>分组延迟</p><ul><li><p>结点处理延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">差错控制</div><div class="line">确定输出链路</div><div class="line">通常小于msec</div></pre></td></tr></table></figure></li><li><p>排队延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">等待输出链路可用</div><div class="line">取决与路由器的当前拥塞状态</div></pre></td></tr></table></figure></li><li><p>传输延迟（发送一个分组所需要的时间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">分组长度</div><div class="line">链路宽度</div></pre></td></tr></table></figure></li><li><p>传播延迟（信号在介质（一个路由器到另一个路由器或端系统）中的传播延迟）</p></li></ul></li></ol></li><li>协议是两个对等实体进行通信的规则的集合，是“水平的”; 同系统的相邻层之间通过接口进行交互，通过服务访问点（SAP—service access point）交换原语，请求特定的服务</li><li>计算机网络结构是分层的（软件和硬件）</li></ol><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><ol><li>七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层<ul><li>一般主机需要实现所有层，路由器只需要实现最基本的三层<br><img src="/image/osi.jpg" alt="数据传输过程"></li><li>数据在上层向下层传递的过程中除了数据链路层向物理层不增加帧头之外，其他的层都需要增加，<strong>并且数据链路层加帧头和帧尾</strong></li><li>数据封装的目的<ul><li>差错检测</li><li>地址信息</li><li>协议控制</li></ul></li></ul></li><li>物理层（解决单一比特的传输问题）<ul><li>接口特性、比特编码、数据率、比特同步、传输模式（单工通信、半双工、双工通信）</li></ul></li><li>数据链路层（结点到结点的数据传输）<ul><li>组帧（便于接受信息）</li><li>物理寻址（物理层不能寻址）</li><li>流量控制（匹配发送和接受速度）</li><li>差错控制</li><li>接入控制（访问控制）</li></ul></li><li>网络层<ul><li>逻辑寻址（ip）—全局的唯一逻辑地址</li><li>路由</li><li>分组转发</li></ul></li><li>传输层的功能（负责源-&gt;目的（端到端）（进程间）的完整报文传输）<ul><li>报文的分段和重组</li><li>SAP寻址（保证交给正确的进程）</li><li>可以实现端到端的链接控制，流量控制，差错控制</li></ul></li><li>会话层（主要负责对话管理，同步等）<ul><li>不单独存在</li></ul></li><li>表示层（处理两个系统之间交换信息的语法和语义问题）<ul><li>数据表示转化（大小端）</li><li>加解密，压缩，解压缩</li><li>不单独存在</li></ul></li><li>应用层</li></ol><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><ol><li>网络接口层、网际层、运输层、应用层</li><li><p>Everything over IP</p></li><li><p>5层参考模型</p><ul><li>物理层</li><li>数据链路层</li><li>网络层（源到目的的数据分组路由和转发）</li><li>传输层（TCP、UDP）{进程之间的通信}</li><li>应用层（支持各种网络应用）</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;计算机网络就是互连的、自治的计算机集合&lt;ul&gt;
&lt;li&gt;通过交换网络进行互连&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换&lt;u
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复试</title>
    <link href="http://blog.huhaobin.cn/2019/03/01/oj/"/>
    <id>http://blog.huhaobin.cn/2019/03/01/oj/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-04-04T07:59:19.241Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>sort<br><algorithm><br>bool ZuSort(testee t1, testee t2) {<br>if(t1.score == t2.score) return t1.id &lt; t2.id;<br>return t1.score &gt; t2.score;<br>}<br>sort(result, result + resultPos, ZuSort); // result[MAX]</algorithm></p></li><li><p>时间、日期等周期性数据应该从最小位自加，逐步控制更高一层的周期</p></li><li><p>空间换取时间：(散列)</p><ul><li><p>查找集合N 中的元素在集合M{2,6,7}中是否出现以及出现的次数</p><p> 可以用bool M[MAX], M[2] = true; M[6] = true; M[7] = true;</p><p> 求出现的次数时，可以用int M[MAX], M[2] ++; M[6] ++; M[7] ++;</p></li></ul></li><li><p>老哥，一定要记得多组数组共享变量的清零</p></li><li><p>利用printf(“%.2f\n” ,ans);格式化输出保留小数点两位</p></li><li><p>所有单调性函数求解问题都可以用二分法</p></li><li><p>最大公约数用辗转相除法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcd(a, b) = gcd(b, a%b);</div><div class="line">gcd(a, 0) = a</div></pre></td></tr></table></figure></li><li><p>最小公倍数的计算</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lcm(a, b) = (a/ gcd(a, b)) * b;</div></pre></td></tr></table></figure></li><li><p>分数表示</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct franction &#123;</div><div class="line">long long up,  down;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们约定，若分母(down)小于0,则令分子，分母为本身的相反数<br>约分即是分子分母同除以他们的最大公约数<br>若分子为0，则令分母为1<br>带分数：整数部分是up/down, 分子是abs(up)%down, 分母是down</p></li><li><p>求素数的方法:<br> 方法一：</p><ul><li>如果n对i, (i 属于[2,sqrt(n)]) 有约数（余数为0），则n不是素数</li><li><p>如果n对i, (i 属于[2,sqrt(n)]) 没有约数（余数不为0），则n是素数</p><p>方法二：</p></li><li>最小的素数的倍数肯定不是素数</li><li>2是素数</li><li>循环筛选</li></ul></li><li><p>求质因子的方法<br>质因子要么全部在[2,sqrt(n)]， 要么只有一个在[sqrt(n), n]。将前面的小于sqrt(n)的质因子全部除掉，剩下的如果！=1，那就是大于sqrt（n）的唯一的质因子</p></li><li><p>vector是一个边长数组<br>set是一个内部自动有序（递增）且不含重复元素的容器<br>set只能通过迭代器来访问， set<typename>::iterator it  // 通过* it访问内容</typename></p><p><em>multiset</em>可以处理元素不唯一的情况<br><em>unordered_set</em> 处理只去重但不排序的需求，速度比set快得多</p></li><li><p>除了vector和string之外的STL都不支持*(it + i)这种形式，只能通过图iteratorBianli.png形式来访问，<br>其他STL的各种操作都要通过迭代器来实现</p></li><li><p>map可以通过it-&gt;first来访问键，it-&gt;second 来访问值。并且map内部会自动按键从小到大排列，</p><p>unordered_map 用来处理只映射而不排序的需求（用散列代替map中的红黑树）</p></li><li><p>queue在top/pop前要先判断是否为空，</p></li><li><p>pair可以将两个元素绑在一起合成一个新的元素</p><ul><li>需要include<utility> 或者<map></map></utility></li><li>可以使用p.first p.second来访问</li><li>可以用作二维排序，一维相等时比较第二维</li><li>pair可以用作map的插入键值对</li></ul></li><li><p>algorithm头文件下的有用函数</p><ul><li>max(x,y)  min(x,y)</li><li>abs(x)  // 对整数求绝对值</li><li>fabs(x) // 对浮点数求绝对值</li><li>swap(x,y) //交换xy的值</li><li>find(x,y,c) // [x,y)查找元素c</li><li>reverse(it,it2) //将数组指针或者迭代器在[it,it2)之间的数组元素或者容器元素进行反转(逆序)</li><li>next_permutation(&amp;begin, &amp;end) // 给出序列[begin,end)在全排列中的下一个序列</li><li>fill() // 可以把容器或数组某一段区间赋为某个相同的值</li><li>对容器进行sort时，参数类型用容器的类型就好(对容器里面的元素进行排序)，实参一般要用迭代器</li><li>lower_bound(first, last, value) // 寻找数组或容器的[first, last)范围内第一个<strong>值大于或等于</strong> value的元素的位置，返回指针或迭代器</li><li>upper_bound(first, last, value) // 寻找数组或容器的[first, last)范围内第一个<strong>值大于</strong> value的元素的位置，返回指针或迭代器</li></ul></li><li><p>求联通分量的个数或者树的个数用并查集</p></li><li>错排公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">F(n) = (n-1)*F(n-1) + (n-1)*F(n-2)</div></pre></td></tr></table></figure></li></ol><h2 id="主要数据结构的实现"><a href="#主要数据结构的实现" class="headerlink" title="主要数据结构的实现"></a>主要数据结构的实现</h2><ol><li>哈夫曼树<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt; &gt; Q;</div></pre></td></tr></table></figure></li></ol><p>哈夫曼代价<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ans += a + b;</div></pre></td></tr></table></figure></p><ol><li>最小生成树可以用并查集实现</li><li>BFS<ul><li>一般用来求解最优解问题</li><li>将n元问题建模为n+1（自变量加结果）元问题的状态变化，通常需要一个n+1元结构体来做状态寄存；和一个原数据存储变量<br>一般每个样本点只用处理一次，注意处理次数和样品条件的剪枝</li></ul></li><li>DFS<ul><li>一般用来求解是否有解</li><li>是按层进行搜索和便历，故参数应该传层，递归的时候应该是<strong>层数加一</strong>，数据应该是本层数据取值i</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;sort&lt;br&gt;&lt;algorithm&gt;&lt;br&gt;bool ZuSort(testee t1, testee t2) {&lt;br&gt;if(t1.score == t2.score) return t1.id &amp;lt; t2.id;&lt;br&gt;return t1.sco
      
    
    </summary>
    
      <category term="考研" scheme="http://blog.huhaobin.cn/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="oj" scheme="http://blog.huhaobin.cn/tags/oj/"/>
    
  </entry>
  
  <entry>
    <title>红米note增强版刷入android7.1</title>
    <link href="http://blog.huhaobin.cn/2019/01/24/HMnote1s/"/>
    <id>http://blog.huhaobin.cn/2019/01/24/HMnote1s/</id>
    <published>2019-01-23T16:00:00.000Z</published>
    <updated>2019-01-24T14:43:26.103Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>root</p><p>参考链接<a href="http://en.miui.com/thread-208274-1-1.html" target="_blank" rel="external">http://en.miui.com/thread-208274-1-1.html</a></p><p>基本上就是先下载HMnote1S.zip这个压缩包，然后打开系统更新点击右上角的三个点选择从安装包更新，选择之前下载的压缩包更新即可。重启之后即可获得root</p></li><li><p>刷入twrp</p><p>需要下载的东西</p><ul><li><a href="https://drive.google.com/file/d/0B2sSKg3aizyzVXFQZVJ0UU5tTDg/view?pref=2&amp;pli=1" target="_blank" rel="external">https://drive.google.com/file/d/0B2sSKg3aizyzVXFQZVJ0UU5tTDg/view?pref=2&amp;pli=1</a></li><li>flashify app</li><li><a href="https://download.mokeedev.com/?device=gucci" target="_blank" rel="external">https://download.mokeedev.com/?device=gucci</a></li></ul></li><li><p>刷入</p><p> 下载完之后，打开flashify，刷入TWRP, 从文件安装，选择刚刚下载的recovery.img。刷入成功之后关机长按电源键和音量上键直至出现recovery界面<br> 选择wipe，清除无用数据，至少做到双清。<br> 返回到主界面选择install ，然后定位到 下载的Gucci即可</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;root&lt;/p&gt;
&lt;p&gt;参考链接&lt;a href=&quot;http://en.miui.com/thread-208274-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://en.miui.com/thread-208
      
    
    </summary>
    
      <category term="android" scheme="http://blog.huhaobin.cn/categories/android/"/>
    
    
  </entry>
  
  <entry>
    <title>ssr</title>
    <link href="http://blog.huhaobin.cn/2019/01/07/ssr+frp/"/>
    <id>http://blog.huhaobin.cn/2019/01/07/ssr+frp/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-07T06:26:37.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="访问校内网资源"><a href="#访问校内网资源" class="headerlink" title="访问校内网资源"></a>访问校内网资源</h2><p>需求现状： 回家之后需要访问学校内网资源学习，手头闲置一枚树莓派，用树莓派作转发服务器.</p><p>问题简述：</p><ol><li>树莓派无公网ip，故需要先对树莓派进行内网穿透. 使用frp</li><li>通过树莓派进行http转发</li></ol><p>设备要求： 公网ip的服务器一台，树莓派一个</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>内网穿透 <a href="https://zhuanlan.zhihu.com/p/36156129" target="_blank" rel="external">参考知乎</a></p><ul><li><p>公网服务器配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gz</div><div class="line">tar -zxvf frp_0.22.0_linux_amd64.tar.gz</div><div class="line">cd frp_0.22.0_linux_amd64</div><div class="line">nano frps.ini</div></pre></td></tr></table></figure><p>配置内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[common]</div><div class="line">bind_port = 7000</div><div class="line">vhost_http_port = 80</div><div class="line">dashboard_port = dashboard_port_number</div><div class="line">dashboard_user = dashboard_user_name</div><div class="line">dashboard_pwd = dashboard_pwd_value</div><div class="line">privilege_token = privilege_token_value</div></pre></td></tr></table></figure><p>ctrl+o 保存，之后 回车 确认，然后 ctrl+x 退出。</p><p>参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">bind_port：绑定的端口，需要与客户端中 server_port 参数保持一致</div><div class="line">vhost_http_port：虚拟主机运行在本机的端口，如果 vps 有服务占用了端口，应当更换</div><div class="line">dashboard_port：frp 后台服务页面的端口，如果设置 8000，便可通过 http://yourip:8000 来访问 frps 的后台页面</div><div class="line">dashboard_user：frp 后台服务页面的管理员用户名</div><div class="line">dashboard_pwd：frp 后台服务页面的管理员密码</div><div class="line">privilege_token：自定义值，必须与客户端中的 privilege_token 保持一致</div></pre></td></tr></table></figure><p>配置完成之后，便可以通过如下命令启动 frps：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./frps -c ./frps.ini</div></pre></td></tr></table></figure><p>为了让服务器一直运行 frp 服务，这里还可以将它添加到开机自启脚本中，命令行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/rc.local</div></pre></td></tr></table></figure><p>在 exit 0 前一行，写上命令，其中 <your_frp_path> 为你 frp 存放的目录位置，即：</your_frp_path></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;your_frp_path&gt;/frps -c &lt;your_frp_path&gt;/frps.ini</div></pre></td></tr></table></figure><p>ctrl+o 保存，之后 回车 确认，然后 ctrl+x 退出。</p></li><li><p>客户端配置 - frpc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_arm.tar.gz</div><div class="line">tar -zxvf frp_0.22.0_linux_arm.tar.gz</div><div class="line">cd frp_0.22.0_linux_arm</div><div class="line">nano frpc.ini</div></pre></td></tr></table></figure><p>配置文件内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[common]</div><div class="line">server_addr = your_server_ip</div><div class="line">server_port = 7000</div><div class="line">privilege_token = privilege_token_value</div><div class="line">login_fail_exit = false</div><div class="line">​</div><div class="line">[ssh]</div><div class="line">type = tcp</div><div class="line">local_ip = 127.0.0.1</div><div class="line">local_port = 22</div><div class="line">​</div><div class="line">remote_port = remote_port_number</div></pre></td></tr></table></figure><p>ctrl+o 保存，之后 回车 确认，然后 ctrl+x 退出。</p><p>参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">server_addr：服务器端的 ip</div><div class="line">server_port：服务器端的端口，即 bind_port</div><div class="line">privilege_token：同服务器端的 privilege_token 保持一致</div><div class="line">login_fail_exit：失败时自动重连</div><div class="line">remote_port：远程端口，即 ssh 连接树莓派时的端口</div></pre></td></tr></table></figure><p>配置完成之后，便可以通过如下命令启动 frps：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./frpc -c ./frpc.ini</div></pre></td></tr></table></figure><p>为了让树莓派一直运行 frp 服务，这里还可以将它添加到开机自启脚本中，命令行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo nano /etc/rc.local</div></pre></td></tr></table></figure><p>在 exit 0 前一行，写上命令，其中 <your_frp_path> 为你 frp 存放的目录位置，即：</your_frp_path></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;your_frp_path&gt;/frps -c &lt;your_frp_path&gt;/frps.ini</div></pre></td></tr></table></figure><p>ctrl+o 保存，之后 回车 确认，然后 ctrl+x 退出。</p></li><li><p>ssh 连接</p><p>以上配置完成之后，就可以远程 ssh 连接到树莓派了。命令行如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -oPort=&lt;remote_port_number&gt; pi@&lt;your_server_ip&gt;</div></pre></td></tr></table></figure><p>其中，<remote_port_number> 为树莓派配置中的 remote_port 参数值，<your_server_ip> 为服务器 ip。</your_server_ip></remote_port_number></p><p><strong>注意：重启之后树莓派可能需要一到两分钟才能正常使用</strong></p></li></ul></li><li><p>http 转发</p><p>在树莓派上搭建ss服务端，自己电脑上搭建ss客户端即可，具体请<a href="https://segmentfault.com/a/1190000015243145" target="_blank" rel="external">参考</a></p><p>按照上述教程搭建完成之后，假设服务器端口为<your_ss_port>（默认为9702），<br>将下面内容添加到树莓派的 frpc.ini 中</your_ss_port></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[ssr]</div><div class="line">type = tcp</div><div class="line">local_ip = 127.0.0.1</div><div class="line">local_port = your_ss_port</div><div class="line">remote_port = access_port</div></pre></td></tr></table></figure><p>参数说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">local_port: &lt;your_ss_port&gt;（默认为9702）</div><div class="line">remote_port: 自己电脑上的ss客户端连接树莓派时的端口哦</div></pre></td></tr></table></figure><ul><li>重启树莓派，等待2-3分钟，电脑使用刚刚搭建的ss通路访问学校内网资源</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;访问校内网资源&quot;&gt;&lt;a href=&quot;#访问校内网资源&quot; class=&quot;headerlink&quot; title=&quot;访问校内网资源&quot;&gt;&lt;/a&gt;访问校内网资源&lt;/h2&gt;&lt;p&gt;需求现状： 回家之后需要访问学校内网资源学习，手头闲置一枚树莓派，用树莓派作转发服务器.&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo重新搭建</title>
    <link href="http://blog.huhaobin.cn/2019/01/06/hexoBuild/"/>
    <id>http://blog.huhaobin.cn/2019/01/06/hexoBuild/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-06T08:19:55.023Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install nodejs</div><div class="line">sudo apt install npm</div></pre></td></tr></table></figure></li><li><p>node升级</p><ul><li><p>使用n来下载版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo n lts 长期支持</div><div class="line">sudo n stable 稳定版</div><div class="line">sudo n latest 最新版</div><div class="line">sudo n 8.4.0 直接指定版本下载</div></pre></td></tr></table></figure></li><li><p>用上下键选择版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo n</div></pre></td></tr></table></figure></li><li><p>在新开的终端来面验证版本更改是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure></li></ul></li><li><p>升级npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm i -g npm</div></pre></td></tr></table></figure></li><li><p>全局安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd hexo</div><div class="line">sudo npm install -g hexo-cli</div><div class="line">hexo init</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装nodejs&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/di
      
    
    </summary>
    
      <category term="hexo" scheme="http://blog.huhaobin.cn/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>ssr</title>
    <link href="http://blog.huhaobin.cn/2018/11/02/ssr/"/>
    <id>http://blog.huhaobin.cn/2018/11/02/ssr/</id>
    <published>2018-11-01T16:00:00.000Z</published>
    <updated>2018-11-01T15:30:08.205Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</div></pre></td></tr></table></figure><p>bbr安装之后无法开机<br>安装完不要立即重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo &apos;add_drivers+=&quot;virtio_blk&quot;&apos; &gt;/etc/dracut.conf.d/force-vitio_blk-to-ensure-boot.conf</div><div class="line">cd /boot</div><div class="line">dracut -f /boot/initramfs-4.13.5-1.el6.elrepo.i686.img 4.13.5-1.el6.elrepo.i686</div><div class="line">reboot</div></pre></td></tr></table></figure></p><p>img 的名字是/boot下面较大的一个，前缀initramfs</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu搭建交叉编译环境</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/ubuntu-arm/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/ubuntu-arm/</id>
    <published>2018-09-24T05:53:47.888Z</published>
    <updated>2017-09-30T08:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.<em>*</em> mixed implicit and normal rules: deprecated syntax<br>  修改Makefile 452 修改后：<br>  %config: scripts_basic outputmakefile FORCE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;em&gt;*&lt;/em&gt; mixed implicit and normal rules: deprecated syntax&lt;br&gt;  修改Makefile 452 修改后：&lt;br&gt;  %config: scripts_basic outputmakefile FORCE
      
    
    </summary>
    
      <category term="未分类" scheme="http://blog.huhaobin.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="交叉编译" scheme="http://blog.huhaobin.cn/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>qt画图</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/qtPainting/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/qtPainting/</id>
    <published>2018-09-24T05:53:47.784Z</published>
    <updated>2018-04-21T06:15:31.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QcustomPlot"><a href="#QcustomPlot" class="headerlink" title="QcustomPlot"></a>QcustomPlot</h2><ol><li><p>下载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.qcustomplot.com</div></pre></td></tr></table></figure></li><li><p>把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可</p></li><li>pro文件中QT += widgets printsupport</li><li><p>使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">QVector x(101), y(101); // initialize with entries 0..100</div><div class="line">for (int i=0; i&lt;101; ++i)</div><div class="line">&#123;</div><div class="line">x[i] = i/50.0 – 1; // x goes from -1 to 1</div><div class="line">y[i] = x[i]*x[i]; // let’s plot a quadratic function</div><div class="line">&#125;</div><div class="line">qDebug()&lt;&lt;“data has been created”;</div><div class="line">ui-&gt;black_line-&gt;addGraph();</div><div class="line">qDebug()&lt;&lt;“begin painting”;</div><div class="line">ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);</div><div class="line">ui-&gt;black_line-&gt;replot();</div><div class="line">qDebug()&lt;&lt;“finish”;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QcustomPlot&quot;&gt;&lt;a href=&quot;#QcustomPlot&quot; class=&quot;headerlink&quot; title=&quot;QcustomPlot&quot;&gt;&lt;/a&gt;QcustomPlot&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载&lt;/p&gt;
 &lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Qt" scheme="http://blog.huhaobin.cn/categories/Qt/"/>
    
    
      <category term="上位机 Qt" scheme="http://blog.huhaobin.cn/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA-Qt/"/>
    
  </entry>
  
  <entry>
    <title>新博客站的第一篇文章</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/about/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/about/</id>
    <published>2018-09-24T05:53:47.768Z</published>
    <updated>2017-09-30T08:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百废待兴"><a href="#百废待兴" class="headerlink" title="百废待兴"></a>百废待兴</h2><p>自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本</p><h2 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h2><p>虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺.</p><h2 id="后悔莫及"><a href="#后悔莫及" class="headerlink" title="后悔莫及"></a>后悔莫及</h2><p>前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞</p><h3 id="有时间继续更新"><a href="#有时间继续更新" class="headerlink" title="有时间继续更新"></a>有时间继续更新</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百废待兴&quot;&gt;&lt;a href=&quot;#百废待兴&quot; class=&quot;headerlink&quot; title=&quot;百废待兴&quot;&gt;&lt;/a&gt;百废待兴&lt;/h2&gt;&lt;p&gt;自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名
      
    
    </summary>
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/categories/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/tags/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/git/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/git/</id>
    <published>2018-09-24T05:53:47.732Z</published>
    <updated>2017-09-28T15:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">git push origin 本地分支名:远程分支名</div><div class="line">git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</div><div class="line"></div><div class="line">git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面加“*”号标记</div><div class="line">git checkout BRANCH_ID 切换分支</div><div class="line">git branch -r 列出远程分支</div><div class="line">git branch -a</div><div class="line">git branch name 新建分支</div><div class="line">git branch -d | -D branchname 删除branchname分支</div><div class="line">git branch -d -r branchname 删除远程branchname分支</div><div class="line"></div><div class="line">git <span class="built_in">log</span></div><div class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></div><div class="line">git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line">git diff --name-status OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line"></div><div class="line">git checkout COMMIT_ID 版本回退</div><div class="line"></div><div class="line">git stash list 查看堆栈情况</div><div class="line">git stash 将当前工作压栈</div><div class="line">git stash pop stash<span class="variable">$&#123;id&#125;</span> 弹出工作栈</div><div class="line">git stash clear 清除栈</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>集成库的学习</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/lib_int/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/lib_int/</id>
    <published>2018-09-24T05:53:47.732Z</published>
    <updated>2017-09-30T08:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol><li><p>在PCB library和SCH library里面可以更改器件的名字</p></li><li><p>在model manager里面进行原理图元器件和PCB元器件的映射</p></li><li><p>board insight提供了PCB图观察的各种视图</p></li><li><p>同时布多条线，放置—–交互式多跟布线</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;p&gt;个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="硬件" scheme="http://blog.huhaobin.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="AD" scheme="http://blog.huhaobin.cn/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>ci  library</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/ci-library/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/ci-library/</id>
    <published>2018-09-24T05:53:47.676Z</published>
    <updated>2017-09-30T08:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>调用时库名必须全部小写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调用时库名必须全部小写&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.huhaobin.cn/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言大坑</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/a_bigHole_ofC/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/a_bigHole_ofC/</id>
    <published>2018-09-24T05:53:47.636Z</published>
    <updated>2018-03-24T04:10:48.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接下来就开始看看坑"><a href="#接下来就开始看看坑" class="headerlink" title="接下来就开始看看坑"></a>接下来就开始看看坑</h2><ol><li><p>单引号表示表示整数值</p><ul><li>双引号表示字符串首的地址</li><li>以0开头的整数默认为八进制</li><li>注意使用移位运算加快程序执行速度</li><li>if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致</li><li>a[i] = i[a]</li><li>C语言的不对称边界</li><li>errno 外部出错变量，可以检测出错信息</li><li>break 跳出离他最近的那层循环或switch</li><li>C 语言不能省略形参，即使不使用</li></ul></li><li><p>C语言的数据存储空间</p><ul><li>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）</li><li>局部变量在return之后出栈销毁，不要尝试返回局部指针地址</li><li>堆  申请、释放原则 <strong>哪儿申请哪儿释放</strong><br> 记得判断 堆 申请成功与否</li></ul></li><li><p>一个程序将操作系统分配给其运行的内存块分为4个区域：<br>　　(1)代码区，存放程序的代码，即程序中的各个函数代码块。<br>　　(2)全局数据区，存放程序的全局数据和静态数据。<br>　　(3)堆区，存放程序的动态数据。<br>　　(4)栈区，存放程序的局部数据，即各个函数中的数据。</p></li><li><p>强制类型转换</p></li></ol><ul><li>占用空间大的转化为占用空间小的： 考虑字节序（大小端），所使用的部分可能在不同机器上截然不同</li><li>占用空间小的转化为占用空间大的： 考虑内存越界访问</li><li>结构体强制转换             ： 考虑字节对齐</li></ul><ol><li>字符串</li></ol><ul><li>通过索引读取字符串时，一定要判断索引的正确性</li></ul><ol><li>多线程编程</li></ol><ul><li>互斥量用来对临界区的互斥进入</li><li>条件变量用于线程的阻塞等待</li></ul><ol><li><p>指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int * p = NULL;</div><div class="line"></div><div class="line">&amp;p 表示p的地址</div><div class="line">p 表示变量p的内容</div><div class="line">*p 表示p指向的存储单元的内容</div></pre></td></tr></table></figure><ul><li><strong>数字0是唯一能输给指针的数值</strong>(相当于NULL)  </li><li>void * :指向任何类型的指针</li><li><strong>注意深复制和浅复制的区别</strong><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p, *q;</div><div class="line">*p = 58;</div><div class="line">q = p;        // q 和 P 指向同一内存单元</div><div class="line">free(q);</div><div class="line">printf(&quot;%d\n&quot;,p); //异常。p的内存已经被q释放</div></pre></td></tr></table></figure></li></ul></li><li><p>动态变量</p><p>在程序运行过程中产生的变量称为动态变量</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int * p; char *q;</div><div class="line">p = new int;  // 在内存中创建一个变量，存储所分配的内存地址到p中</div><div class="line">q = new char[19];   // 在内存中创建一个数组，并将数组地址存储到q中</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p = 28;</div><div class="line">*q = &quot;hello&quot;;</div></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete p;</div><div class="line">delete [] q;</div></pre></td></tr></table></figure></li></ul></li><li><p>动态数组</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int *p;</div><div class="line">p = new int[10];</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* p = 25;   //25存到第一个存储空间里  = p[0] = 25；</div><div class="line">p ++;</div><div class="line">* p = 35;   //35存到第二个存储空间里  = p[1] = 35；</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接下来就开始看看坑&quot;&gt;&lt;a href=&quot;#接下来就开始看看坑&quot; class=&quot;headerlink&quot; title=&quot;接下来就开始看看坑&quot;&gt;&lt;/a&gt;接下来就开始看看坑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单引号表示表示整数值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号表示字符串首
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2018/09/24/UnistallPip/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/UnistallPip/</id>
    <published>2018-09-24T05:53:47.556Z</published>
    <updated>2018-06-19T03:53:09.789Z</updated>
    
    <content type="html"><![CDATA[<p>python -m pip uninstall pip</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python -m pip uninstall pip&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>socksV5转化为http代理</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/sockstohttp/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/sockstohttp/</id>
    <published>2018-09-24T05:53:47.556Z</published>
    <updated>2018-07-06T11:52:07.801Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用工具  privoxy</li></ol><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install privoxy</div></pre></td></tr></table></figure></p><p>更改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/privoxy/config</div></pre></td></tr></table></figure></p><p>并在里面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forward-socks5   /               127.0.0.1:1080 .</div></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service privoxy restart</div></pre></td></tr></table></figure></p><p>给系统设置http代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div></pre></td></tr></table></figure></p><p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=http://127.0.0.1:8118/</div></pre></td></tr></table></figure></p><p>使更改生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用工具  privoxy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre
      
    
    </summary>
    
      <category term="代理" scheme="http://blog.huhaobin.cn/categories/%E4%BB%A3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2018/09/24/csu/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/csu/</id>
    <published>2018-09-24T05:53:47.492Z</published>
    <updated>2018-03-04T05:31:56.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://123.206.64.174" target="_blank" rel="external">http://123.206.64.174</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://123.206.64.174&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://123.206.64.174&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养</title>
    <link href="http://blog.huhaobin.cn/2018/05/13/Programmer&#39;sSelfCultivation2/"/>
    <id>http://blog.huhaobin.cn/2018/05/13/Programmer&#39;sSelfCultivation2/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-05-13T06:31:30.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在优先级调度的环境下，线程优先级改变的方式有</p><ul><li>用户制定优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级</li><li>长时间得不到执行而提升优先级<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2></li></ul><p>基本结构如图所示<img src="/image/objSample.png" alt=""></p><ul><li>初始化的全局变量和局部静态变量保存在.data</li><li>未初始化的全局变量和局部静态变量保存在.bss</li><li>File Header 里面包含一个段表<br>除此之外还可以自定义段<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__attribute__((section(&quot;FOO&quot;))) int global = 42;</div><div class="line">__attribute__((section(&quot;BAR&quot;))) void foo()</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 这样就可以把相应的变量或者函数放在以“FOO”/&quot;BAR&quot;作为段名的段中</div><div class="line">// 名字可以自定义</div></pre></td></tr></table></figure></li></ul><h2 id="C-和C的兼容"><a href="#C-和C的兼容" class="headerlink" title="C++和C的兼容"></a>C++和C的兼容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot;&#123;</div><div class="line">  int func(int);</div><div class="line">  int var;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C++ 编译器会将在extern “C”大括号内部的代码当作C语言来处理</p><p>为了处理C++调用了C函数，但认为是C++函数，经过名称修饰之后无法正确引用的问题，C++编译器会在便宜C++的程序时默认定义宏”__cplusplus”.我们可以使用条件宏来判断当前便宜单元是不是C++代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">#endif</div><div class="line"></div><div class="line">void *memset(void *, int, size_t);    // C语言内容</div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程调度&quot;&gt;&lt;a href=&quot;#线程调度&quot; class=&quot;headerlink&quot; title=&quot;线程调度&quot;&gt;&lt;/a&gt;线程调度&lt;/h2&gt;&lt;p&gt;在优先级调度的环境下，线程优先级改变的方式有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户制定优先级&lt;/li&gt;
&lt;li&gt;根据进入等待状态的
      
    
    </summary>
    
      <category term="程序员的自我修养" scheme="http://blog.huhaobin.cn/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="程序员的自我修养" scheme="http://blog.huhaobin.cn/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>信息的表示和处理</title>
    <link href="http://blog.huhaobin.cn/2018/05/11/OS2/"/>
    <id>http://blog.huhaobin.cn/2018/05/11/OS2/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-05-13T01:59:51.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><ol><li><p>数据大小</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C类型      字节（32位）  字节（64位）</div><div class="line">char            1        1</div><div class="line">short int       2        2</div><div class="line">int             4        4</div><div class="line">long int        4        8</div><div class="line">long long int   8        8</div><div class="line">float           4        4</div><div class="line">double          8        8</div><div class="line">char *          4        8</div></pre></td></tr></table></figure></li><li><p>移位</p><p> 假如进行x&gt;&gt;k,这里的k很大,实际偏移量是通过k mod v得到的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int lval = 0xede875 &gt;&gt; 32;</div><div class="line">int aval = 0xede875 &gt;&gt; 36;</div><div class="line">unsigned int uval = 0xede875 &gt;&gt; 40;</div></pre></td></tr></table></figure><p> 在32位机器上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lval = 0xede875;            // 32 mod 32 = 0</div><div class="line">aval = 0xfede87;            // 36 mod 32 = 4</div><div class="line">uval = 0x00ede8;</div></pre></td></tr></table></figure><p> <strong>几乎所有的编译器/机器都对有符号数据使用算术右移，无符号数据必须是逻辑右移</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信息存储&quot;&gt;&lt;a href=&quot;#信息存储&quot; class=&quot;headerlink&quot; title=&quot;信息存储&quot;&gt;&lt;/a&gt;信息存储&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据大小&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://blog.huhaobin.cn/2018/05/09/OS1/"/>
    <id>http://blog.huhaobin.cn/2018/05/09/OS1/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-05-09T13:24:04.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h2><ol><li><p>进程的创建</p><p>原因：</p><ul><li>系统初始化</li><li>正在运行的进程执行了创建进程的系统调用</li><li>用户请求创建一个新进程</li><li>批处理作业的初始化</li></ul></li><li><p>进程的终止</p><p>原因：</p><ul><li>正常退出（自愿）</li><li>出错退出（自愿）</li><li>严重错误（非自愿）</li><li>被其他进程杀死（非自愿）</li></ul></li><li><p>进程的状态</p><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li></ul></li><li><p>线程可以在内核和用户空间中进行管理，但不论是在哪儿都会引来很多问题</p><h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2></li><li><p>临界区</p><p>一个好的临界区解决方案需要具备以下四个条件：</p><ul><li>任何两个进程不能同时处于临界区</li><li>不应对CPU的速度和数目做任何假设</li><li>临界区外的进程不能阻塞其他进程</li><li>不能让进程在临界区外面无休止的等待</li></ul></li><li><p>忙等待形式的互斥</p><ol><li><p>关闭中断</p><p> 在进入临界区之前先关中断，退出之后开中断。这样把开关中断的权限交给用户是不明智的</p></li><li><p>锁变量</p><p> 设置一个共享锁变量，0表示临界区内没有进程，1表示有。每次进入之前先测试，如果此时为0则设置为1，退出临界区设置为0。遗憾的是这个方法也<strong>不是线程安全</strong>的</p></li><li><p>严格交替法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WHILE(TRUE)</div><div class="line">&#123;</div><div class="line">  WHILE(turn != 0);</div><div class="line">  critical_region();</div><div class="line">  turn = 1;</div><div class="line">  noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WHILE(TRUE)</div><div class="line">&#123;</div><div class="line">  WHILE(turn != 1);</div><div class="line">  critical_region();</div><div class="line">  turn = 0;</div><div class="line">  noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 整型变量turn的初值为零，用于跟踪轮到哪个进程进入临界区。一开始进程0检查turn，发现是0，所以进入临界区。同时进程1也在检查turn，不停的检查是否变为1。这样就产生了<a href="https://baike.baidu.com/item/%E5%BF%99%E7%A2%8C%E7%AD%89%E5%BE%85/16256157?fr=aladdin" target="_blank" rel="external">忙等待</a>。还有一种情况就是进程0退出临界区并将turn设置为1，此时进程0和1都在忙非临界区的任务，但是进程0先忙完需要进入临界区，由于turn为1所以进程0不能进入临界区</p></li><li>Peterson解决方案</li><li>TSL语句</li></ol></li><li><p>信号量</p><p> 用一个整型变量来累计唤醒次数，供以后使用。<br> 在这个解决方案中用了三个信号量。</p><ul><li>full 用来记录满的缓冲槽的数目，初值为0</li><li>empty 用来记录空的缓冲槽的数目，初值为缓冲区内槽的数目</li><li><p>mutex 用来确保生产者和消费者不会同时访问缓冲区，初值为1</p><p>多个进程使用初值为1的信号量可以保证同时只有一个进程可以进入临界区，如果每个进程在进入临界区之前执行一个down，退出之后执行一个up就可以保证互斥</p></li></ul></li><li><p>互斥</p><p> 若不需要信号量的计数能力，有时可以使用信号量的另一个版本—-互斥<br> 互斥是一个可以处于两态之一的变量：解锁(mutex_unlock)和加锁(mutex_lock)</p></li><li>管程<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3></li><li>先到先服务</li><li>最短作业优先</li><li>最短剩余时间优先</li><li>三级调度<ul><li>准入调度器</li><li>内存调度器</li><li>CPU调度器<h3 id="交互系统中的调度"><a href="#交互系统中的调度" class="headerlink" title="交互系统中的调度"></a>交互系统中的调度</h3></li></ul></li><li>时间片轮转调度</li><li><p>优先级调度</p><p> 注意时常对优先级进行调整，防止低优先级的进程饿死</p></li><li>多重队列</li><li>最短进程优先（老化算法预估进程运行所需时间）</li><li>保证调度算法</li><li>彩票调度算法</li><li>公平分享调度<h3 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h3></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程介绍&quot;&gt;&lt;a href=&quot;#进程介绍&quot; class=&quot;headerlink&quot; title=&quot;进程介绍&quot;&gt;&lt;/a&gt;进程介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程的创建&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统初始化&lt;/li&gt;
&lt;li&gt;正在运行的进程执
      
    
    </summary>
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Octave安装forge</title>
    <link href="http://blog.huhaobin.cn/2018/04/30/OctaveInstallforge/"/>
    <id>http://blog.huhaobin.cn/2018/04/30/OctaveInstallforge/</id>
    <published>2018-04-30T13:56:20.000Z</published>
    <updated>2018-04-30T02:26:40.678Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装缺少的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install liboctave-dev</div></pre></td></tr></table></figure></li><li><p>安装control</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">octave-cli</div><div class="line">pkg install -forge fuzzy-logic-toolkit</div><div class="line">pkg install -forge control</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装缺少的库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="Octave" scheme="http://blog.huhaobin.cn/categories/Octave/"/>
    
    
      <category term="Octave" scheme="http://blog.huhaobin.cn/tags/Octave/"/>
    
  </entry>
  
</feed>
