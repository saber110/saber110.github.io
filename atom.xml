<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saber110</title>
  
  <subtitle>越努力,越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huhaobin.cn/"/>
  <updated>2019-04-17T01:45:37.508Z</updated>
  <id>http://blog.huhaobin.cn/</id>
  
  <author>
    <name>Hu haobin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MAX30102文档</title>
    <link href="http://blog.huhaobin.cn/2019/04/16/MAX30102/"/>
    <id>http://blog.huhaobin.cn/2019/04/16/MAX30102/</id>
    <published>2019-04-16T13:56:20.000Z</published>
    <updated>2019-04-17T01:45:37.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中断状态寄存器"><a href="#中断状态寄存器" class="headerlink" title="中断状态寄存器"></a>中断状态寄存器</h2><p><img src="/image/max30102-1.png" alt="img"></p><p>无论何时触发中断，MAX30102都会将低电平有效的中断引脚拉至低电平状态，直到中断被清除。</p><p><strong>A_FULL: FIFO满标志</strong></p><p>在SpO 2和HR模式下，当FIFO写指针剩余一定数量的空闲空间时，该中断触发。</p><p>触发号可以由FIFO_A_FULL [3：0]寄存器设置。 通过读取中断状态1寄存器（0x00）清除中断。</p><p><strong>PPG_RDY：新的FIFO数据就绪</strong></p><p>在SpO 2和HR模式下，当数据FIFO中有新样本时，此中断将触发。通过读取中断状态1寄存器（0x00）或读取FIFO_DATA寄存器来清除中断。</p><p><strong>ALC_OVF：环境光消除溢出(置位时说明硬件校正失败)</strong></p><p>当SpO 2 / HR光电二极管的环境光消除功能达到其最大限制时，该中断触发，因此，环境光影响ADC的输出。通过读取中断状态1寄存器（0x00）清除中断。</p><p><strong>PWR_RDY：电源就绪标志</strong></p><p>在上电或欠压情况下，当电源电压VDD从欠压锁定（UVLO）电压低于UVLO电压时，电源就绪中断被触发，表示模块已上电并准备好收集数据。</p><p><strong>DIE_TEMP_RDY：内部温度就绪标志</strong></p><p>内部芯片温度转换完成后，将触发此中断，以便处理器可以读取温度数据寄存器。通过读取中断状态2寄存器（0x01）或TFRAC寄存器（0x20）来清除中断。</p><h2 id="中断允许寄存器"><a href="#中断允许寄存器" class="headerlink" title="中断允许寄存器"></a>中断允许寄存器</h2><p>​    保留位应该设置为0</p><h2 id="FIFO数据寄存器"><a href="#FIFO数据寄存器" class="headerlink" title="FIFO数据寄存器"></a><strong>FIFO数据寄存器</strong></h2><p>FIFO深度为32，最多可容纳32个数据样本。样本大小<strong>取决</strong>于配置为活动的LED通道（a.k.a.通道）的数量。由于每个通道信号存储为3字节数据信号，因此FIFO宽度可以是3个字节或6个字节。</p><p>I 2 C寄存器映射中的FIFO_DATA寄存器指向要从FIFO读取的下一个样本。 FIFO_RD_PTR指向此示例。读FIFO_DATA寄存器不会自动递增I 2 C寄存器地址。突发读取该寄存器，一遍又一遍地读取相同的地址。每个样本是每个通道3个字节的数据（即，RED为3个字节，IR为3个字节等）。</p><p>FIFO寄存器（0x04-0x07）都可以写入和读取，但实际上<strong>只应写入FIFO_RD_PTR寄存器</strong>。其他数据由MAX30102自动递增或填充数据。当开始新的SpO 2或心率转换时，建议<strong>首先将FIFO_WR_PTR，OVF_COUNTER和FIFO_RD_PTR寄存器清零为全零</strong>（0x00），以确保FIFO为空并处于已知状态。在一次突发读取I 2 C事务中读取MAX30102寄存器时，寄存器地址指针通常会递增，以便发送的下一个数据字节来自下一个寄存器，等等。例外情况是FIFO数据寄存器寄存器0x07。读取该寄存器时，地址指针不会递增，但FIFO_RD_PTR会递增。因此，发送的下一个数据字节表示FIFO中可用的下一个数据字节</p><p><strong>从FIFO读取</strong></p><p>通常，从I 2 C接口读取寄存器会自动增加寄存器地址指针，因此可以在没有I 2 C启动事件的情况下以突发读取方式读取所有寄存器。 在MAX30102中，除FIFO_DATA寄存器（寄存器0x07）外，所有寄存器都适用。</p><p>读FIFO_DATA寄存器不会自动递增寄存器地址。一遍又一遍地读取该寄存器取来的都是同一地址的数据。 每个样本包含多个字节的数据，因此应从该寄存器（在同一事务中）读取多个字节以获得一个完整样本。</p><p>另一个例外是0xFF。 在0xFF寄存器之后读取更多字节不会使地址指针返回到0x00，并且读取的数据没有意义。</p><p><strong>FIFO数据结构</strong></p><p>数据FIFO由32个样本存储器组组成，可存储IR和RED ADC数据。 由于每个样本由两个通道的数据组成，每个样本有6个字节的数据，因此可以在FIFO中可以存储192个总字节数据。</p><p>FIFO如表1所示进行数据左对齐; 换句话说，无论ADC分辨率设置如何，<em>MSB位始终位于第17位数据位置</em>。 有关FIFO数据结构的直观表示，请参见表2。</p><p><strong>FIFO数据每通道包含3个字节</strong></p><p>FIFO数据是左对齐的，这意味着无论ADC分辨率设置如何，MSB始终位于相同的位置。 FIFO DATA [18]  -  [23]保留。 表2显示了每个三字节字节的结构（包含每个通道的18位ADC数据输出）。</p><p>SpO 2模式下的每个数据样本包含两个数据三元组（每个3个字节）。要读取一个样本，每个字节需要一个I 2 C读取命令。 因此，要在SpO 2模式下读取一个样本，需要6 I 2 C字节读取。 在读取每个样本的第一个字节后，FIFO读指针自动递增。</p><p><strong>写/读指针</strong></p><p>写/读指针用于控制FIFO中的数据流。 每次将新样本添加到FIFO时，写指针都会递增。 每次从FIFO读取样本时，读指针都会递增。 要重新读取FIFO中的样本，请将其值减1并再次读取数据寄存器。</p><p>进入SpO 2模式或HR模式时，应将FIFO写/读指针清零（返回0x00），以便FIFO中不存在旧数据。 如果V DD重新上电或V DD降至低于其UVLO电压，则指针自动清零。</p><p><strong>从FIFO读取数据的伪代码示例</strong></p><p>第一个事务：获取FIFO_WR_PTR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">START;</div><div class="line">Send device address + write mode</div><div class="line">Send address of FIFO_WR_PTR;</div><div class="line">REPEATED_START;</div><div class="line">Send device address + read mode</div><div class="line">Read FIFO_WR_PTR;</div><div class="line">STOP;</div></pre></td></tr></table></figure><p>中央处理器评估要从FIFO读取的样本数：</p><p><strong>NUM_AVAILABLE_SAMPLES</strong> = FIFO_WR_PTR – FIFO_RD_PTR</p><p>(Note: pointer wrap around should be taken into account)</p><p>NUM_SAMPLES_TO_READ = &lt; less than or equal to NUM_AVAILABLE_SAMPLES &gt;</p><p>第二个实务: 从FIFO中读取 NUM_SAMPLES_TO_READ 个样本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">START;</div><div class="line">Send device address + write mode</div><div class="line">Send address of FIFO_DATA;</div><div class="line">REPEATED_START;</div><div class="line">Send device address + read mode</div><div class="line">for (i = 0; i &lt; NUM_SAMPLES_TO_READ; i++) &#123;</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED1[23:16];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED1[15:8];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED1[7:0];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED2[23:16];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED2[15:8];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED2[7:0];</div><div class="line">    Read FIFO_DATA;</div><div class="line">&#125;</div><div class="line">STOP;</div><div class="line">START;</div><div class="line">Send device address + write mode</div><div class="line">Send address of FIFO_RD_PTR;</div><div class="line">Write FIFO_RD_PTR;</div><div class="line">STOP;</div></pre></td></tr></table></figure><p>第三个事务：</p><p>写入FIFO_RD_PTR寄存器。 <strong>如果</strong>第二个事务成功，则FIFO_RD_PTR指向FIFO中的下一个样本，并且不需要第三个事务。 <strong>否则</strong>，<strong>处理器适当地更新</strong>FIFO_RD_PTR，以便重新读取样本。</p><p><strong>FIFO 配置(0x08)</strong></p><p><strong>位 7:5: 样本均值化 (SMP_AVE)</strong></p><p>为了减少数据吞吐量，可以通过设置该寄存器在芯片上对相邻样本（在每个单独的通道中）进行平均和抽取。</p><p><img src="/image/max30102-2.png" alt="img"></p><p><strong>位4: FIFO满时循环(FIFO_ROLLOVER_EN)</strong></p><p>当FIFO完全填满数据时，该位控制FIFO的行为。 如果FIFO_ROLLOVER_EN设置为（1），则FIFO地址将从0开始，FIFO将继续填充新数据。 如果该位未置位（0），则在读取FIFO_DATA或更改WRITE / READ指针位置之前，FIFO不会更新。</p><p><strong>位3：0：FIFO几乎满值（FIFO_A_FULL）</strong></p><p>该寄存器设置发出中断时FIFO中剩余的数据样本数（3个字节/样本）。 例如，如果此字段设置为0x0，则在FIFO中剩余0个数据样本时发出中断（所有32个FIFO字都有未读数据）。 此外，如果此字段设置为0xF，则在FIFO中剩余15个数据样本时发出中断（17个FIFO数据样本具有未读数据）。</p><p><strong>SpO 2 配置 (0x0A)</strong></p><p><strong>Bits 6:5: SpO 2 ADC量程控制</strong></p><p>该寄存器设置SpO 2传感器ADC的满量程范围，如表5所示。</p><p><strong>比特4：2：SpO 2采样率控制</strong></p><p>这些位定义了有效采样率，其中一个样本由一个IR脉冲/转换和一个红色脉冲/转换组成。</p><p>采样率和脉冲宽度是相关的，因为采样率设置脉冲宽度时间的上限。 如果用户选择的采样率对于所选的LED_PW设置来说太高，则可能的最高采样率被编程到寄存器中。</p><p><strong>位1：0：LED脉冲宽度控制和ADC分辨率</strong></p><p>这些位设置LED脉冲宽度（IR和RED具有相同的脉冲宽度），因此间接设置每个样本中ADC的积分时间。 ADC分辨率与积分时间直接相关。</p><h2 id="采样率和性能"><a href="#采样率和性能" class="headerlink" title="采样率和性能"></a>采样率和性能</h2><p>ADC的最大采样速率取决于所选的脉冲宽度，进而决定了ADC的分辨率。 例如，如果脉冲宽度设置为69μs，那么ADC分辨率为15位，并且所有采样率都是可选的。 但是，如果脉冲宽度设置为411μs，则采样率受限。 表11和表12总结了SpO 2和HR模式的允许采样率。</p><p>在<strong>心率模式</strong>下，仅红色LED用于捕获光学数据并确定用户的心率和/或光电容积描记图（PPG）。</p><h2 id="SpO-2温度补偿"><a href="#SpO-2温度补偿" class="headerlink" title="SpO 2温度补偿"></a>SpO 2温度补偿</h2><p>MAX30102具有精确的板载温度传感器，可根据I 2 C主机的命令数字化IC的内部温度。 温度对红色和红外LED的波长有影响。 虽然器件输出数据对IR LED的波长相对不敏感，但红色LED的波长对于正确解释数据至关重要。</p><p>表13显示了红色LED波长与LED温度的相关性。 由于LED管芯以非常短的热时间常数（几十微秒）加热，因此应根据LED的电流水平和IC的温度计算LED波长。 使用表13估算温度。</p><p>MAX30102具有2线I2C / SMBus兼容串行接口，包括串行数据线（SDA）和串行时钟线（SCL）。 SDA和SCL有助于MAX30102与主机之间的通信，时钟速率高达400kHz。 图1显示了2线接口时序图。 主机生成SCL并在总线上启动数据传输。 主器件通过发送正确的从地址和数据将数据写入MAX30102。 每个发送序列由START（S）或REPEATED START（Sr）条件和STOP（P）条件构成。 传输到MAX30102的每个字长为8位，后跟一个应答时钟脉冲。 来自MAX30102的主机读数据传输正确的从机地址，然后发送一系列9个SCL脉冲。</p><p>MAX30102与主机产生的SCL脉冲同步在SDA上传输数据。 主设备确认收到每个数据字节。 每个读取序列由START（S）或REPEATED START（Sr）条件，非应答和STOP（P）条件构成。 SDA既可作为输入，也可作为漏极开路输出。 SDA需要一个上拉电阻，通常大于500Ω。 SCL仅作为输入操作。 如果总线上有多个主机，或者单个主机具有漏极开路SCL输出，则SCL上需要一个上拉电阻，通常大于500Ω。 符合SDA和SCL的串联电阻是可选的。 串联电阻可保护MAX30102的数字输入免受总线上的高压尖峰影响，并最大限度地降低总线信号的串扰和下冲。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>在每个SCL周期期间传输一个数据位。 SDA上的数据必须在SCL脉冲的高电平期间保持稳定。 SCL高时SDA的变化是控制信号。 请参阅START和STOP条件部分。</p><p><strong>启动和停止条件</strong></p><p>当总线不使用时，SDA和SCL空闲。 主设备通过发出START条件来启动通信。 START条件是SCL为高电平时SDA从高到低的转换。 STOP条件是SCL为高电平时SDA从低到高的转换（图7）。 来自主设备的START条件表示传输到设备的开始。 主设备终止传输，并通过发出STOP条件释放总线。 如果生成REPEATED START条件而不是STOP条件，则总线保持活动状态。</p><p><strong>早期停止条件</strong></p><p>MAX30102在数据传输期间的任何时刻都能识别出STOP条件，除非STOP条件出现在与START条件相同的高脉冲中。 为了正常工作，请勿在与START条件相同的SCL高电平脉冲期间发送STOP条件。</p><p><strong>从机地址</strong></p><p>总线主控器通过发出START条件后跟7位从机ID启动与从机设备的通信。空闲时，MAX30102等待START条件后跟从机ID的控制序列。串行接口逐位比较每个从站ID，如果检测到错误的从站ID，则允许接口断电并立即断开与SCL的连接。识别出START条件后跟正确的从机ID序列后，MAX30102被根据ID字的LSB是读还是写（R / W）编程为接受或发送数据。 R / W表示主机是写入还是从MAX30102读取数据（R / W = 0选择写入条件，R / W = 1选择读取条件）。接收到正确的从机ID后，MAX30102通过将SDA拉低一个时钟周期发出<strong>ACK</strong>。 MAX30102从机ID由7个固定位B7-B1（设置为0b1010111）组成。首先发送最重要的从ID位（B7），然后发送剩余的位。表17显示了设备的可能的从ID。</p><p><strong>应答位</strong></p><p>应答位（ACK）是MAX30102在时钟的第9位在写入模式下用于握手接收每个数据字节（图8）。 如果成功接收到前一个字节，MAX30102会在整个主机产生的第9个时钟脉冲期间拉低<strong>SDA</strong>。 监测ACK可以检测失败的数据传输。 如果接收设备繁忙或发生系统故障，则会发生不成功的数据传输。 如果数据传输失败，总线主机将重试通信。 当MAX30102处于<strong>读模式</strong>时，主器件在第9个时钟周期内<strong>拉低SDA</strong>以确认接收数据。 在每个读取字节之后，主机发送应答以允许数据传输继续。 当主机从MAX30102读取数据的最后一个字节，然后是STOP条件时，发送一个未应答。</p><p><strong>写操作</strong></p><p>对于写操作，将从ID作为第一个字节，然后是寄存器地址字节，然后是一个或多个数据字节。 寄存器地址指针在接收到的每个数据字节后自动递增，因此例如可以一次写入整个寄存器库。 使用STOP条件终止数据传输。 写操作如图9所示。</p><p>内部寄存器地址指针自动递增，因此写入附加数据字节按顺序填充数据寄存器。</p><p><img src="/image/max30102-3.png" alt="img"></p><p><strong>读数据格式</strong></p><p>对于读操作，必须执行<strong>两次I 2 C</strong>操作。首先，发送从机地址，然后发送您想要读取的I 2 C寄存器的ID。然后发送REPEAT START（Sr）条件，然后发送读取从机ID。然后，MAX30102开始从第一个操作中选择的寄存器中发送数据。读指针自动递增，因此器件继续按顺序从其他寄存器发送数据，直到收到STOP（P）条件。例外情况是<strong>FIFO_DATA</strong>寄存器，读取指针在读取其他字节时不再递增。要在FIFO_DATA之后读取下一个寄存器，<em>需要I 2 C写命令来更改读指针的位置</em>。图10和图11显示了读取一个字节和多个字节数据的过程。需要进行初始写操作发送读取寄存器地址。从初始I 2 C写操作中选择的寄存器开始，按顺序从寄存器发送数据。如果读取FIFO_DATA寄存器，则读指针不会自动递增，后续的数据字节将包含FIFO的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;中断状态寄存器&quot;&gt;&lt;a href=&quot;#中断状态寄存器&quot; class=&quot;headerlink&quot; title=&quot;中断状态寄存器&quot;&gt;&lt;/a&gt;中断状态寄存器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/image/max30102-1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="硬件" scheme="http://blog.huhaobin.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="毕业设计" scheme="http://blog.huhaobin.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu装机</title>
    <link href="http://blog.huhaobin.cn/2019/04/16/zhuangji/"/>
    <id>http://blog.huhaobin.cn/2019/04/16/zhuangji/</id>
    <published>2019-04-16T07:00:00.000Z</published>
    <updated>2019-04-18T03:21:34.110Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Ubuntu安装之新建autoinstall.sh <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim autoinstall.sh</div></pre></td></tr></table></figure></li></ol><p>2.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">将下列内容写入</div><div class="line">apt install vim</div><div class="line">## theme</div><div class="line">add-apt-repository ppa:noobslab/themes</div><div class="line">apt update</div><div class="line">apt install flatabulous-theme</div><div class="line">## icons</div><div class="line">add-apt-repository ppa:noobslab/icons</div><div class="line">apt update</div><div class="line">apt install ultra-flat-icons</div><div class="line">## pointer</div><div class="line">add-apt-repository ppa:noobslab/macbuntu</div><div class="line">apt update</div><div class="line">apt install macbuntu-os-icons-lts-v7</div><div class="line">apt install macbuntu-os-ithemes-lts-v7</div><div class="line">## fonts</div><div class="line">apt install fonts-wqy-microhei</div><div class="line">##</div><div class="line">apt install unity-tweak-tool</div><div class="line">## docky</div><div class="line">apt install cairo-dock</div><div class="line"></div><div class="line">##</div><div class="line">apt install git</div><div class="line">## python</div><div class="line">apt install python-pip</div><div class="line">pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U</div><div class="line"></div><div class="line">## hexo</div><div class="line">apt install npm</div><div class="line">npm install -g hexo-cli</div><div class="line"></div><div class="line">## network</div><div class="line">apt install --reinstall linux-firmware</div><div class="line">modprobe -r iwlwifi</div><div class="line">modprobe iwlwifi</div></pre></td></tr></table></figure></p><ol><li><p>自动安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./autoinstall.sh</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Ubuntu安装之新建autoinstall.sh &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu搭建交叉编译环境</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/ubuntu-arm/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/ubuntu-arm/</id>
    <published>2019-04-15T06:27:43.805Z</published>
    <updated>2017-09-30T08:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.<em>*</em> mixed implicit and normal rules: deprecated syntax<br>  修改Makefile 452 修改后：<br>  %config: scripts_basic outputmakefile FORCE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;em&gt;*&lt;/em&gt; mixed implicit and normal rules: deprecated syntax&lt;br&gt;  修改Makefile 452 修改后：&lt;br&gt;  %config: scripts_basic outputmakefile FORCE
      
    
    </summary>
    
      <category term="未分类" scheme="http://blog.huhaobin.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="交叉编译" scheme="http://blog.huhaobin.cn/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>qt画图</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/qtPainting/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/qtPainting/</id>
    <published>2019-04-15T06:27:43.737Z</published>
    <updated>2018-04-21T06:15:31.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QcustomPlot"><a href="#QcustomPlot" class="headerlink" title="QcustomPlot"></a>QcustomPlot</h2><ol><li><p>下载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.qcustomplot.com</div></pre></td></tr></table></figure></li><li><p>把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可</p></li><li>pro文件中QT += widgets printsupport</li><li><p>使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">QVector x(101), y(101); // initialize with entries 0..100</div><div class="line">for (int i=0; i&lt;101; ++i)</div><div class="line">&#123;</div><div class="line">x[i] = i/50.0 – 1; // x goes from -1 to 1</div><div class="line">y[i] = x[i]*x[i]; // let’s plot a quadratic function</div><div class="line">&#125;</div><div class="line">qDebug()&lt;&lt;“data has been created”;</div><div class="line">ui-&gt;black_line-&gt;addGraph();</div><div class="line">qDebug()&lt;&lt;“begin painting”;</div><div class="line">ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);</div><div class="line">ui-&gt;black_line-&gt;replot();</div><div class="line">qDebug()&lt;&lt;“finish”;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QcustomPlot&quot;&gt;&lt;a href=&quot;#QcustomPlot&quot; class=&quot;headerlink&quot; title=&quot;QcustomPlot&quot;&gt;&lt;/a&gt;QcustomPlot&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载&lt;/p&gt;
 &lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Qt" scheme="http://blog.huhaobin.cn/categories/Qt/"/>
    
    
      <category term="上位机 Qt" scheme="http://blog.huhaobin.cn/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA-Qt/"/>
    
  </entry>
  
  <entry>
    <title>新博客站的第一篇文章</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/about/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/about/</id>
    <published>2019-04-15T06:27:43.717Z</published>
    <updated>2017-09-30T08:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百废待兴"><a href="#百废待兴" class="headerlink" title="百废待兴"></a>百废待兴</h2><p>自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本</p><h2 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h2><p>虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺.</p><h2 id="后悔莫及"><a href="#后悔莫及" class="headerlink" title="后悔莫及"></a>后悔莫及</h2><p>前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞</p><h3 id="有时间继续更新"><a href="#有时间继续更新" class="headerlink" title="有时间继续更新"></a>有时间继续更新</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百废待兴&quot;&gt;&lt;a href=&quot;#百废待兴&quot; class=&quot;headerlink&quot; title=&quot;百废待兴&quot;&gt;&lt;/a&gt;百废待兴&lt;/h2&gt;&lt;p&gt;自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名
      
    
    </summary>
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/categories/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/tags/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/git/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/git/</id>
    <published>2019-04-15T06:27:43.689Z</published>
    <updated>2017-09-28T15:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">git push origin 本地分支名:远程分支名</div><div class="line">git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</div><div class="line"></div><div class="line">git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面加“*”号标记</div><div class="line">git checkout BRANCH_ID 切换分支</div><div class="line">git branch -r 列出远程分支</div><div class="line">git branch -a</div><div class="line">git branch name 新建分支</div><div class="line">git branch -d | -D branchname 删除branchname分支</div><div class="line">git branch -d -r branchname 删除远程branchname分支</div><div class="line"></div><div class="line">git <span class="built_in">log</span></div><div class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></div><div class="line">git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line">git diff --name-status OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line"></div><div class="line">git checkout COMMIT_ID 版本回退</div><div class="line"></div><div class="line">git stash list 查看堆栈情况</div><div class="line">git stash 将当前工作压栈</div><div class="line">git stash pop stash<span class="variable">$&#123;id&#125;</span> 弹出工作栈</div><div class="line">git stash clear 清除栈</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>集成库的学习</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/lib_int/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/lib_int/</id>
    <published>2019-04-15T06:27:43.689Z</published>
    <updated>2017-09-30T08:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol><li><p>在PCB library和SCH library里面可以更改器件的名字</p></li><li><p>在model manager里面进行原理图元器件和PCB元器件的映射</p></li><li><p>board insight提供了PCB图观察的各种视图</p></li><li><p>同时布多条线，放置—–交互式多跟布线</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;p&gt;个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="硬件" scheme="http://blog.huhaobin.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="AD" scheme="http://blog.huhaobin.cn/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>ci  library</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/ci-library/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/ci-library/</id>
    <published>2019-04-15T06:27:43.621Z</published>
    <updated>2017-09-30T08:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>调用时库名必须全部小写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调用时库名必须全部小写&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.huhaobin.cn/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言大坑</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/a_bigHole_ofC/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/a_bigHole_ofC/</id>
    <published>2019-04-15T06:27:43.601Z</published>
    <updated>2018-03-24T04:10:48.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接下来就开始看看坑"><a href="#接下来就开始看看坑" class="headerlink" title="接下来就开始看看坑"></a>接下来就开始看看坑</h2><ol><li><p>单引号表示表示整数值</p><ul><li>双引号表示字符串首的地址</li><li>以0开头的整数默认为八进制</li><li>注意使用移位运算加快程序执行速度</li><li>if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致</li><li>a[i] = i[a]</li><li>C语言的不对称边界</li><li>errno 外部出错变量，可以检测出错信息</li><li>break 跳出离他最近的那层循环或switch</li><li>C 语言不能省略形参，即使不使用</li></ul></li><li><p>C语言的数据存储空间</p><ul><li>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）</li><li>局部变量在return之后出栈销毁，不要尝试返回局部指针地址</li><li>堆  申请、释放原则 <strong>哪儿申请哪儿释放</strong><br> 记得判断 堆 申请成功与否</li></ul></li><li><p>一个程序将操作系统分配给其运行的内存块分为4个区域：<br>　　(1)代码区，存放程序的代码，即程序中的各个函数代码块。<br>　　(2)全局数据区，存放程序的全局数据和静态数据。<br>　　(3)堆区，存放程序的动态数据。<br>　　(4)栈区，存放程序的局部数据，即各个函数中的数据。</p></li><li><p>强制类型转换</p></li></ol><ul><li>占用空间大的转化为占用空间小的： 考虑字节序（大小端），所使用的部分可能在不同机器上截然不同</li><li>占用空间小的转化为占用空间大的： 考虑内存越界访问</li><li>结构体强制转换             ： 考虑字节对齐</li></ul><ol><li>字符串</li></ol><ul><li>通过索引读取字符串时，一定要判断索引的正确性</li></ul><ol><li>多线程编程</li></ol><ul><li>互斥量用来对临界区的互斥进入</li><li>条件变量用于线程的阻塞等待</li></ul><ol><li><p>指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int * p = NULL;</div><div class="line"></div><div class="line">&amp;p 表示p的地址</div><div class="line">p 表示变量p的内容</div><div class="line">*p 表示p指向的存储单元的内容</div></pre></td></tr></table></figure><ul><li><strong>数字0是唯一能输给指针的数值</strong>(相当于NULL)  </li><li>void * :指向任何类型的指针</li><li><strong>注意深复制和浅复制的区别</strong><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p, *q;</div><div class="line">*p = 58;</div><div class="line">q = p;        // q 和 P 指向同一内存单元</div><div class="line">free(q);</div><div class="line">printf(&quot;%d\n&quot;,p); //异常。p的内存已经被q释放</div></pre></td></tr></table></figure></li></ul></li><li><p>动态变量</p><p>在程序运行过程中产生的变量称为动态变量</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int * p; char *q;</div><div class="line">p = new int;  // 在内存中创建一个变量，存储所分配的内存地址到p中</div><div class="line">q = new char[19];   // 在内存中创建一个数组，并将数组地址存储到q中</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p = 28;</div><div class="line">*q = &quot;hello&quot;;</div></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete p;</div><div class="line">delete [] q;</div></pre></td></tr></table></figure></li></ul></li><li><p>动态数组</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int *p;</div><div class="line">p = new int[10];</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* p = 25;   //25存到第一个存储空间里  = p[0] = 25；</div><div class="line">p ++;</div><div class="line">* p = 35;   //35存到第二个存储空间里  = p[1] = 35；</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接下来就开始看看坑&quot;&gt;&lt;a href=&quot;#接下来就开始看看坑&quot; class=&quot;headerlink&quot; title=&quot;接下来就开始看看坑&quot;&gt;&lt;/a&gt;接下来就开始看看坑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单引号表示表示整数值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号表示字符串首
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>socksV5转化为http代理</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/sockstohttp/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/sockstohttp/</id>
    <published>2019-04-15T06:27:43.553Z</published>
    <updated>2018-07-06T11:52:07.801Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用工具  privoxy</li></ol><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install privoxy</div></pre></td></tr></table></figure></p><p>更改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/privoxy/config</div></pre></td></tr></table></figure></p><p>并在里面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forward-socks5   /               127.0.0.1:1080 .</div></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service privoxy restart</div></pre></td></tr></table></figure></p><p>给系统设置http代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div></pre></td></tr></table></figure></p><p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=http://127.0.0.1:8118/</div></pre></td></tr></table></figure></p><p>使更改生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用工具  privoxy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre
      
    
    </summary>
    
      <category term="代理" scheme="http://blog.huhaobin.cn/categories/%E4%BB%A3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2019/04/15/UnistallPip/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/UnistallPip/</id>
    <published>2019-04-15T06:27:43.553Z</published>
    <updated>2018-06-19T03:53:09.789Z</updated>
    
    <content type="html"><![CDATA[<p>python -m pip uninstall pip</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python -m pip uninstall pip&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2019/04/15/csu/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/csu/</id>
    <published>2019-04-15T06:27:43.465Z</published>
    <updated>2018-03-04T05:31:56.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://123.206.64.174" target="_blank" rel="external">http://123.206.64.174</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://123.206.64.174&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://123.206.64.174&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络4</title>
    <link href="http://blog.huhaobin.cn/2019/04/12/computernetworking4/"/>
    <id>http://blog.huhaobin.cn/2019/04/12/computernetworking4/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-22T06:39:15.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 网络层（数据报--datagram）向传输层（数据段---segment）提供服务2. 端系统和路由器都运行网络层3. **核心功能**: 转发和路由, 连接建立（有些网络不需要建立）       1. 网络层的链接是中间所有设备都参与的, **需要确立一条明确的路径**       2. 传输层的连接是只有通信双方参与的</code></pre><h2 id="网络层服务模型"><a href="#网络层服务模型" class="headerlink" title="网络层服务模型"></a>网络层服务模型</h2><ol><li>无连接服务<ol><li>不事先确定系列分组的传输路径</li><li>每个分组独立确定路径</li><li>不同的分组路径可能不同</li><li>eg：数据报网络</li></ol></li><li>连接服务<ol><li>首先为系列分组的传输确定从源到目的的路径</li><li>然后用该路径进行该系列分组的传输</li><li>传输结束后拆除连接</li><li>eg：虚电路网络（ATM网络）</li></ol></li></ol><h2 id="数据包网络"><a href="#数据包网络" class="headerlink" title="数据包网络"></a>数据包网络</h2><ol><li>特征<ul><li>网络层无连接</li><li>每个分组携带目的地址</li><li>路由器根据分组的目的地址（范围）进行转发分组（internet）<ul><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路</li></ul></li></ul></li><li>转发原则<ul><li>最长前缀匹配优先（优先选择与分组目的地址匹配前缀最长的入口）</li></ul></li></ol><h4 id="简化网络，复杂“边缘”"><a href="#简化网络，复杂“边缘”" class="headerlink" title="简化网络，复杂“边缘”"></a>简化网络，复杂“边缘”</h4><h2 id="internet网络层"><a href="#internet网络层" class="headerlink" title="internet网络层"></a>internet网络层</h2><p><img src="./image/internetNetworking.png" alt="网络层示意"></p><ol><li><p>网络链路层存在最大传输单元（MTU）——链路层数据帧可封装数据的上限</p><ol><li>不同链路的MTU不同</li><li>大ip分组向较小的MTU链路转发时<strong>可以</strong>被“分片”， 若相关标志位(DF)不允许分片，则将起丢掉，并用ICMP回传控制信息</li><li>ip分片到达目的主机才进行组装（路由器只进行拆分，不组装）</li><li>若有分片后的数据收不到，则丢弃整个分组（MF标志位：最后一片或未分片）</li><li>ipv4 片偏移字段以8字节为单位</li></ol></li><li><p>ip编址（<strong>层次化编址</strong>）</p><ol><li><p>ip地址与每个<strong>接口</strong>相关联</p></li><li><p>主机域不能全0也不能全1(广播地址)</p></li><li><p>ip划分：某个组织的网络号（ip地址高位）相同，主机号不同</p></li><li><p>ip子网：ip地址具有相同网络号的设备<strong>接口</strong></p><p>不跨越路由器（第三及以上层网络设备）可以彼此物理联通的设备</p></li></ol></li><li><p>有类ip地址/有类编址</p><p><img src="./image/ipv4Sort.png" alt="ipv4分类"></p><ul><li>D类地址用作多播</li><li>E类保留做研究使用</li><li>A、B、C类也有部分地址不可以被分配</li></ul></li><li><p>ip子网的划分和子网掩码</p><ol><li>将ip地址划分为网络号（NetID），<em>子网号（SubID）</em>，和主机号（HostID）</li><li>子网掩码（用来确定是否分了子网和子网的大小）<ol><li>NetID，SubID全取1</li><li>HostID全取0</li></ol></li><li>子网划分中比不划分子网有更多的不能使用的地址</li></ol></li><li><p>无类域间路由(CIDR: classless InterDomain Routing)</p><ol><li><p>消除传统的A，B，C类地址界限</p><p>将网络号和子网号统称为网络前缀</p></li><li><p>融合子网地址和子网掩码</p><p>格式：a.b.c.d/x,  x为前缀的长度</p></li></ol></li><li><p>DHCP </p><ol><li><p>默认网关：若分组要送出/入该子网则应该先送给网关，再由网关进行转发</p></li><li><p>从服务器动态获取：</p><ol><li>ip地址</li><li>子网掩码</li><li>默认网管地址</li><li>DNS服务器名称和ip地址</li></ol></li><li><p>“即插即用”</p></li><li><p>允许地址重用，在用地址续租</p></li><li><p>允许移动用户加入网络</p></li><li><p>DHCP配置协议</p><ol><li>需要接入网络的主机广播”DHCP discover”（发现报文）</li><li>DHCP服务器（一个子网里面可能有多个也可能没有）利用“DHCP offer“（提供报文）进行响应</li><li>主机向回应offer的DHCP服务器请求ip地址：”DHCP request“（请求报文）</li><li>DHCP服务器分配ip地址:“DHCP ack”（确认报文）</li></ol></li><li><p>DHCP配置过程示例</p><p><img src="./image/DHCPExample.png" alt="DHCP"></p><ul><li>DHCP服务器端口67，客户机端口68</li><li>第一次，第二次数据传输进行广播是因为相互不清楚对方的ip</li><li>第三次数据传输进行广播是为了告诉其他DHCP服务器客户机已经分配了ip，免得占用其他资源</li></ul></li><li><p>DHCP在应用层实现，封装在UDP数据报中</p></li></ol></li><li><p>网络地址转换(NAT)</p><ol><li>实现步骤<ol><li>替换：利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IP地址，源端口号）</li><li>记录：将每对（NAT IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到NAT转换表中</li><li>替换：根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），即（NAT IP地址，新端口号）</li></ol></li><li>NAT穿透问题<ol><li>方法1：静态配置NAT，将特定端口的连接请求转发给服务器</li><li>方法2：利用UPnp（互联网网管设备协议）自动配置</li><li>方法3：中继（代理）<ol><li>NAT内部的客户与中继服务器建立连接</li><li>外部客户也与中继服务器建立连接</li><li>中继服务器桥接两个连接的分组</li></ol></li></ol></li></ol></li><li><p>互联网控制报文协议（ICMP）</p><ol><li>主要功能：支持主机或者路由器进行<strong>差错报告</strong>和<strong>网络探询</strong></li><li>两类ICMP报文：差错报告报文（5种）和网络探询报文（2组）</li><li>不发送ICMp差错报告报文的特殊情况<ul><li>对ICMp差错报告报文不再发送ICMP差错报告报文</li><li>除第一个ip数据报分片外，对所有后续分片均不发送ICMP差错报告报文</li><li>对所有多播ip数据报均不发送</li><li>对具有特殊IP的数据报不发送</li></ul></li><li>ICMP封装在IP数据报中传输</li></ol></li><li><p>IPv6</p><ol><li>IPv4相比的变化<ul><li>彻底移除首部的校验和字段，以减少每跳处理时间</li><li>选项（options）字段从基本首部移出，定义多个选项首部，通过“下一个首部”字段指示</li><li>ICMPv6<ul><li>附加报文类型</li><li>多播组管理功能</li></ul></li></ul></li><li></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;网络层&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下firefox播放HTML5视频</title>
    <link href="http://blog.huhaobin.cn/2019/04/08/ubuntu_Firefox_play_HTML5_vedio/"/>
    <id>http://blog.huhaobin.cn/2019/04/08/ubuntu_Firefox_play_HTML5_vedio/</id>
    <published>2019-04-08T03:19:32.000Z</published>
    <updated>2019-04-11T11:41:21.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>chrome内存吃的太狠，渣笔记本带的很吃力，但是用中国大学mooc不能正常观看教学视频，报错不能正常播放视频[code:6]。</p><h2 id="缺少组件"><a href="#缺少组件" class="headerlink" title="缺少组件"></a>缺少组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install ubuntu-restricted-extras</div></pre></td></tr></table></figure><h2 id="ubuntu-restricted-extras"><a href="#ubuntu-restricted-extras" class="headerlink" title="ubuntu-restricted-extras"></a>ubuntu-restricted-extras</h2><p>通俗来说就是ubuntu下的一些支持库，他可以帮助改善MP3、vedio、DVD等的体验，也可以获得windows下的字体体验和FLASH之类的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;chrome内存吃的太狠，渣笔记本带的很吃力，但是用中国大学mooc不能正常观看教学视频，报错不能正常播放视频[code:6]。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux, ubuntu" scheme="http://blog.huhaobin.cn/tags/linux-ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>扩展/boot分区</title>
    <link href="http://blog.huhaobin.cn/2019/04/07/boot%20partition%20is%20not%20enough/"/>
    <id>http://blog.huhaobin.cn/2019/04/07/boot partition is not enough/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-07T09:13:38.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="how-to-expend-the-capicity-of-boot-partition-in-linux"><a href="#how-to-expend-the-capicity-of-boot-partition-in-linux" class="headerlink" title="how to expend the capicity of /boot partition in linux"></a>how to expend the capicity of /boot partition in linux</h2><ol><li>use the Disks offered in the System to build a partition for new /boot, and click “Mount the filesystem” signed by a triangle icon</li><li>copy all the things form old /boot partition to new /boot partition . new /boot partition willbe mounted in /mnt</li><li>click the old /boot prtition in Disks, click buttons as following<br> “More actions” signed by a gear<br> “Edit Mount Options…”, meanwhile, wtrite the config down for later<br> uncheck “Mount at Startup”<br> modify “Mount Point” to something else, such as “/boot_old”<br> and click OK</li><li>click the old /boot prtition in Disks, and “Unmount the filesystem”. click buttons as following<br> “More actions” signed by a gear, and click “Edit Partition” modify “Type” to linux filesystem and Change<br> “Edit Mount Options…” copy the config form old one<br> OK</li></ol><p>and now it can work almost, but there is something broken likely.to solve this , you can use the Boot Repair. here is its brochure:</p><p>installation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y boot-repair &amp;&amp; boot-repair</div></pre></td></tr></table></figure></p><p>Recommended repair<br>launch Boot-Repair from either :<br>the Dash (the Ubuntu logo at the top-left of the screen)<br>or by typing ‘boot-repair’ in a terminal<br>Then click the “Recommended repair” button. When repair is finished, note the URL (paste.ubuntu.com/XXXXX) that appeared on a paper, then reboot and check if you recovered access to your OSs.</p><p>If the repair did not succeed, indicate the URL to people who help you by email or forum.</p><p>if you have trouble in booting, if you computer is booted by grub2, here is you solutions:</p><ol><li>ls<br>find the boot file location </li><li>set root = (hd0, gpt0)<br>(hd0,gpt0) is your boot file location</li><li>linux /path/to/your/bootfile(vmlinuz*) root=/dev/sda0<br>/dev/sda0 is your root location</li><li>initrd /path/to/your/bootfile(initrd*)</li><li>boot</li></ol><p>now you can boot your computer.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;how-to-expend-the-capicity-of-boot-partition-in-linux&quot;&gt;&lt;a href=&quot;#how-to-expend-the-capicity-of-boot-partition-in-linux&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络3</title>
    <link href="http://blog.huhaobin.cn/2019/04/07/computernetworking3/"/>
    <id>http://blog.huhaobin.cn/2019/04/07/computernetworking3/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-16T02:25:57.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ol><li><p>为运行在不同的端系统上的<strong>进程</strong>提供了一种逻辑通信机制(网络层提供<strong>主机</strong>之间的逻辑通信机制)</p><ul><li>位于网络层之上</li><li>依赖于网络层</li><li>对网络层功能进行加强</li></ul></li><li><p>传输层提供的服务</p><ul><li>可靠的、按序的交付服务（TCP）<ul><li>流量控制</li><li>拥塞控制</li><li>连接建立</li></ul></li><li>不可靠的交付服务（UDP）<ul><li>复用/分用</li><li>简单的错误校验</li><li>尽力而为（best effort）</li><li>不需要建立链接，延迟很小</li><li>上层更好控制（不用顾及拥塞控制之类）</li><li>经常用于流媒体、DNS、SNMP等</li></ul></li><li>不提供延迟、带宽等方面的服务</li></ul></li><li><p>多路复用/分用</p></li></ol><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><ol><li><p>不错、不丢、不乱</p></li><li><p>可靠数据传输协议</p></li><li><p>需要双向的控制信息流实现，上层单向流动到可靠协议，由可靠协议负责和不可靠的UDP双向交互实现可靠传输</p></li><li><p>协议实现（数据错误，位错误）</p><ul><li>有限状态机来刻画传输协议</li><li>确认机制（ACK: 确认; NAK：数据错误; 错误重传机制）— 接收方显式回传控制消息<ul><li>为ACK和NAK增加校验和</li><li>添加额外的控制消息</li><li>NAK/ACK 坏掉重传（产生重复传送的问题）</li><li>增加序列号进行NAK/ACK重传</li></ul></li><li>差错检测（校验和等）</li><li>停-等协议（有限状态机）</li><li>NAK可以在ACK确认消息的时候加入序列号代替（确认最后一个分组）</li></ul><p>5 . 协议实现（丢失分组）</p><ul><li>等待合理的一段时间之后重传（需要定时器）</li><li>停等引起效率低下</li><li>采用流水线机制（连发多个分组再等待ACK）</li><li>使用滑动窗口协议实现流水线</li></ul></li></ol><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><h3 id="GBN（Go-Back-N）协议：一组分组一组分组的滑动"><a href="#GBN（Go-Back-N）协议：一组分组一组分组的滑动" class="headerlink" title="GBN（Go-Back-N）协议：一组分组一组分组的滑动"></a>GBN（Go-Back-N）协议：一组分组一组分组的滑动</h3><ol><li><p>发送方</p><ul><li><p>窗口尺寸为N，最多允许有N个分组未确认，分组头部包含K-bit序列号</p></li><li><p>采用累积确认的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ACK(n)表示确认到n(包含n)的分组均被正确接收</div></pre></td></tr></table></figure></li><li><p>整个窗口设置一个计时器</p></li><li><p>超时则重发序列号大于n还未收到ack的分组</p></li></ul></li><li><p>接收方（没有缓存，没有接收方窗口）</p><ul><li>发送拥有最高序列号的、已被正确接收的分组的ACK<ul><li>可能产生重复的ACK</li></ul></li><li>乱序到达的分组直接丢弃，重新确认正确收到的最大的序列号</li></ul></li></ol><h3 id="SR（selective-repeat-协议：一个分组一个分组的滑动"><a href="#SR（selective-repeat-协议：一个分组一个分组的滑动" class="headerlink" title="SR（selective repeat)协议：一个分组一个分组的滑动"></a>SR（selective repeat)协议：一个分组一个分组的滑动</h3><ol><li>接收方（设置缓冲机制，缓冲乱需到达的分组）<ol><li>添加接收方窗口</li><li>对每个分组单独确认</li></ol></li><li>发送方<ol><li>为每个分组设置单独的计数器</li></ol></li><li>窗口可以跳跃前移</li></ol><h2 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h2><ol><li><p>点对点（一个发送方，一个接收方）</p></li><li><p>可靠的按序的字节流</p></li><li><p>流水线机制（拥塞控制，流量控制，窗口大小设置）</p></li><li><p>发送方/接收方缓存</p></li><li><p>全双工（同一连接中能传输双向数据流）</p></li><li><p>面向连接</p><ol><li>通信双方在发送数据前必须建立连接</li><li>连接状态只在连接的两端维护，沿途 结点并不维护</li><li>TCP连接包括：两台主机上的缓存，连接状态变量、socket等</li></ol></li><li><p>流量控制机制</p></li><li><p>序列号是segment中第一个字节的编号，而不是segment的编号，建立TCP连接时双方随机选择序列号</p></li><li><p>ACKS</p><ol><li>累计确认机制：该序列号之前的所有字节已经被正确处理</li><li>返回是希望接收到的下一个字节的序列号</li></ol></li><li><p>可靠数据传输</p><ol><li>TCP在IP层提供不可靠的服务基础上实现可靠数据传输服务</li><li>使用单一重传定时器</li><li>触发重传的事件（超时，收到重复ACK）</li></ol></li><li><p>快速重传</p><p>​    由于接受断发回的ACK是希望接收到的字节的序列号，当连续收到三个相同的ACK时就执行快速重传而不用等超时再传</p></li><li><p>流量控制（速度匹配机制)</p><p>控制发送方发送速度不要过快以至于淹没接收方的buffer</p><p>receiver 在segment头部告诉sender还有多少buffer</p></li><li><p>多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率</p></li></ol><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><ol><li>一般由TCP的发送端（客户机）请求建立连接，接收端等待客户连接请求</li><li>连接的三次握手<ol><li>客户机向服务器发送一个SYN段（没有数据，包含客户端初始选择的序列号）</li><li>服务器答复SYNACK（选择服务器的初始序列号，分配客户机缓存）</li><li>客户机收到SYNACK，回复ACK（可以包含数据）</li><li>建立TCP连接<strong>两次握手不能确定具体是否成功，四次握手会有资源浪费</strong></li></ol></li><li>关闭的四次握手<ol><li>客户机向服务器发送FIN报文段</li><li>服务器收到FIN，回复ACK，关闭连接，发送FIN</li><li>客户机收到FIN，回复ACK<ol><li>进入等待状态，如果收到FIN，则重新发送ACK</li></ol></li><li>服务器收到ACK，关闭链接</li></ol></li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ol><li><p>表现</p><ol><li>分组丢失</li><li>分组延迟越来越大</li></ol><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ul><li>端到端的拥塞控制（端系统通过观察loss（分组丢失）delay（分组延迟时间等来判断网络是否发生拥塞—-TCP采用这种方法）</li><li>网络辅助的拥塞控制（路由器显式的向发送方反馈网络的用色信息，简单的拥塞指示（1 bit）：指示发送方该采取何种速率—-ATM）</li></ul><h3 id="拥塞控制的基本原理"><a href="#拥塞控制的基本原理" class="headerlink" title="拥塞控制的基本原理"></a>拥塞控制的基本原理</h3><ul><li><p>限制sender的发送速率</p></li><li><p>ConfgWin：（发送窗口的大小）</p><ul><li>动态调整以改变发送速率</li><li>反映所感知到的网络拥塞</li></ul></li><li><p>网络拥塞的感知</p><ul><li>LOSS事件==timeout或者连续3个重复的ACK</li></ul></li><li><p>合理调整发送速率</p><ul><li><p>加性增—乘性减（AIMD)</p><p>谨慎的探测可用带宽，逐渐增加发送速率，直到发生loss事件（每个RTT将CongWin增大一个MSS）;  发生loss之后已经拥塞，需要快速降低发送频率（将CongWin减半）</p></li><li><p>慢启动（SS）</p><p>当链接刚刚建立时（CongWin = 1,  初始速率20k），让CongWin指数增长; 每个RTT将CongWin翻倍–&gt;快速攀升</p></li><li><p>指数增长切换到加性增</p><p>用一个变量Threshold， 设置为LOSS事件前congWin值的1/2.</p><p><img src="/image/loss_event.jpg" alt="loss event"></p><ul><li><p>收到3个重复的ACK(网络还能传输一些segment)</p><p>将congWin切为一半，然后线性增长</p></li><li><p>Timeout事件（<strong>拥塞更严重</strong>)</p><p>CongWin直接设为1,然后指数增长，达到threshold之后再线性增长</p></li></ul></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为运行在不同的端系统上的&lt;strong&gt;进程&lt;/strong&gt;提供了一种逻辑通信机制(网络层提供&lt;strong&gt;主
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络2</title>
    <link href="http://blog.huhaobin.cn/2019/04/07/computernetworking2/"/>
    <id>http://blog.huhaobin.cn/2019/04/07/computernetworking2/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-16T02:37:17.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol><li>网络应用的体系结构<ul><li>客户机/服务器（c/s）</li><li>peer to peer (点对点结构)</li><li>混合结构</li></ul></li><li>TCP/UDP区别<br> <img src="/image/udp_tcp.jpg" alt="tcp/udp"></li><li>HTTP<ul><li>采用无状态的机制（服务器不维护任何有关客户端过去所请求的消息）</li><li>采用请求/响应的模式</li><li>使用TCP传输</li></ul></li></ol><table><thead><tr><th>持久性连接</th><th>非持久性连接</th></tr></thead><tbody><tr><td>    每个tcp连接只允许传送一个对象</td><td>允许传送多个对象</td></tr><tr><td>    HTTP1.0</td><td>HTTP1.1</td></tr></tbody></table><ol><li><p>代理服务器与远程服务器之间的更新</p><ul><li>条件性GET（如果缓存有最新的版本则不需要发送请求对象）<br> 在HTTP请求消息中声明所持有版本的日期 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-modified-since &lt;date&gt;</div></pre></td></tr></table></figure></li></ul></li><li><p>SMTP(邮件)</p><ul><li>采用TCP（可靠）持久性连接</li><li>通过ASCII采用命令/响应的模式</li><li>端口25</li><li>用MIME进行消息内容扩展，使其可以传输非ASCII数据（二进制、多媒体）</li></ul></li><li><p>DNS</p><ol><li><p>是一个<em>多层</em>命名服务器构成的<em>分布式</em>数据库（为什么不用集中式）</p><ul><li>单点失败</li><li>流量问题</li><li>距离问题</li><li>维护性问题</li></ul></li></ol><ul><li>应用层协议：完成名字的解析（在应用层实现Internet的核心服务）</li><li>域名解析过程<ul><li>向本地域名服务器请求，若本地不知道则直接请求根域名服务器</li><li>根域名服务器一般不知道，则返回顶级域名服务器（.com/.cn/.org…..)</li></ul></li><li>全球总共有13个根域名服务器</li><li>域名服务器<ul><li>根域名服务器</li><li>顶级域名服务器（负责.com/.cn/.org…..）</li><li>权威域名服务器（组织的域名服务器，提供组织内部服务器的解析服务）</li><li>本地域名解析服务器<ul><li>每个ISP都有默认的本地域名服务器</li><li>作为代理去查询分层式域名服务器</li></ul></li><li>DNS查询<ul><li>迭代查询（本地域名服务器负责根据指示依次查询域名服务器）</li><li>递归查询（本地域名服务器只向根域名服务器请求，根域名服务器再去请求顶级域名服务器，顶级再去查询权威，然后将结果依次返回）</li></ul></li><li>DNS缓存和更新<ul><li>只要域名解析服务器获得一个新的域名-ip映射，即缓存这一映射</li><li>本地域名服务器一般会缓存顶级域名服务器（根域名服务器一般不会被访问）</li></ul></li></ul></li><li>DNS记录（资源记录 Resource Record)<ul><li>format:(name, value, type, ttl)</li><li>type = A<ul><li>name 主机域名</li><li>value ip地址</li></ul></li><li>type = NS<ul><li>name：域（edu.cn)</li><li>value:该域权威域名解析服务器的主机域名）</li></ul></li><li>type = cname<ul><li>name ：某一真实域名的别名</li><li>value：真实域名</li></ul></li><li>type = MX<ul><li>value是于name相对应的邮件服务器</li></ul></li></ul></li><li>DNS协议（查询/回复）</li></ul></li></ol><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><ol><li>纯p2p架构<ul><li>没有服务器</li><li>任意端系统之间直接通信</li><li>节点阶段性接入internet</li><li>节点可能更换ip地址</li><li>多用户同时下载时性能比C/S优（C/S随着用户数增加耗时线性增长，p2p则是有个阈值）</li></ul></li><li>p2p例子：BitTorrent<ul><li>下载的同时进行发送（可以发送自己的，也可以发送刚刚下载的）</li><li>稀缺文件优先下载（防止端系统离开）</li><li>上传<ul><li>向给自己发送的4个需要下载的端系统发送数据</li><li>每10s重新评估top4</li><li>每30s随机选择一个其他结点，向其发送</li></ul></li></ul></li><li><p>索引技术</p><ol><li><p>集中式索引</p><ul><li>单点失败</li><li>性能瓶颈</li><li>法律</li></ul></li><li><p>完全分布式索引</p><ul><li>完全分布式架构</li><li>每个节点对他共享的文件且只对他共享的文件进行索引</li><li>用<a href="#jump">覆盖网络</a>实现全局性文件搜索</li><li>采用洪泛式查询，查询命中之后反向回传</li></ul></li><li><p>层次式覆盖网络</p><ul><li>介于集中式索引和洪泛式查询的方法</li><li>每个结点或者是一个超级结点，或者被分配一个超级节点</li><li>节点和超级节点之间维持TCP</li><li>某些超级节点对之间维持TCP<ul><li>普通节点向超级节点请求查询</li><li>超级节点之间使用洪泛式查询</li></ul></li><li>超级节点负责跟踪字节点的内容</li></ul></li></ol></li><li><p>危害</p><ul><li>对硬盘的损坏（高温、重复读写、扇区损坏）</li><li>占用网络带宽资源</li><li>助长病毒传播</li><li>盗版</li></ul></li><li><p><span id="jump">覆盖网络<span></span></span></p><ul><li>节点X与节点Y之间若有TCP连接那么构成一条边</li><li>所有活动的节点和边构成覆盖网络</li><li>节点一般邻居数少于十个</li></ul></li></ol><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><ol><li>套接字使用时不用指定端口号，由操作系统负责分配和管理，用套接子描述符即可</li><li><p>windows对unix socket进行封装形成winsock，程序使用时以WSAStartup开头（初始化api），以WSACleanup（释放windows socket DLL）结尾</p></li><li><p>当多个进程同时是使用socket时，socket数据结构里有对其计数的变量，关闭一个则减1，到0才关闭此数据结构</p></li><li>同一个进程中的多个线程不能同时调用一个socket</li><li>当一个主机中有多个ip时，服务器端调用bind时用INADDR_ANY</li><li>listen、accept只用于服务器，监听端口，只是用于tcp</li><li>connect之用于客户端，tcp/udp</li><li>send, recv 适用于TCP或者调用connect的UDP</li><li>sendto, recvfrom用于未调用connect的UDP</li><li><img src="/image/socket_.jpg" alt="socket流程"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;网络应用的体系结构&lt;ul&gt;
&lt;li&gt;客户机/服务器（c/s）&lt;/li&gt;
&lt;li&gt;peer to peer (点对点结构)
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络1</title>
    <link href="http://blog.huhaobin.cn/2019/04/04/computernetworking1/"/>
    <id>http://blog.huhaobin.cn/2019/04/04/computernetworking1/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-04-08T03:10:10.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>计算机网络就是互连的、自治的计算机集合<ul><li>通过交换网络进行互连</li></ul></li><li>交换<ul><li>动态转接</li><li>动态资源分配和传输</li></ul></li><li><p>电路交换（电路建立—数据传输—电路拆除）</p><ul><li><p>多路复用</p><ul><li>频分复用（FDM）— 同轴电缆</li><li>时分复用（TDM) — 时间分帧、分片</li><li><p>码分复用（CDM）— 每个用户有个m bit的各个用户相互正交的码片序列</p><p>每个原始信号的bit位被用码片序列编码为m bit;1 -&gt; +1; 0 -&gt; -1;</p></li><li>波分复用（光的频分复用）</li></ul></li></ul></li><li>报文交换<ul><li>一次将一个报文全部传输</li><li>存储转发整个报文</li></ul></li><li><p>分组交换</p><ol><li>报文的拆分和重组</li><li>产生额外开销</li><li>存储转发小分组</li><li>便于实现统计复用</li><li>由于流水线技术，速度比报文交换要快，硬件要求要低</li><li><p>适用于突发数据传输</p><ul><li>充分利用资源</li><li>无需建立电路</li></ul></li><li><p>分组延迟</p><ul><li><p>结点处理延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">差错控制</div><div class="line">确定输出链路</div><div class="line">通常小于msec</div></pre></td></tr></table></figure></li><li><p>排队延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">等待输出链路可用</div><div class="line">取决与路由器的当前拥塞状态</div></pre></td></tr></table></figure></li><li><p>传输延迟（发送一个分组所需要的时间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">分组长度</div><div class="line">链路宽度</div></pre></td></tr></table></figure></li><li><p>传播延迟（信号在介质（一个路由器到另一个路由器或端系统）中的传播延迟）</p></li></ul></li></ol></li><li>协议是两个对等实体进行通信的规则的集合，是“水平的”; 同系统的相邻层之间通过接口进行交互，通过服务访问点（SAP—service access point）交换原语，请求特定的服务</li><li>计算机网络结构是分层的（软件和硬件）</li></ol><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><ol><li>七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层<ul><li>一般主机需要实现所有层，路由器只需要实现最基本的三层<br><img src="/image/osi.jpg" alt="数据传输过程"></li><li>数据在上层向下层传递的过程中除了数据链路层向物理层不增加帧头之外，其他的层都需要增加，<strong>并且数据链路层加帧头和帧尾</strong></li><li>数据封装的目的<ul><li>差错检测</li><li>地址信息</li><li>协议控制</li></ul></li></ul></li><li>物理层（解决单一比特的传输问题）<ul><li>接口特性、比特编码、数据率、比特同步、传输模式（单工通信、半双工、双工通信）</li></ul></li><li>数据链路层（结点到结点的数据传输）<ul><li>组帧（便于接受信息）</li><li>物理寻址（物理层不能寻址）</li><li>流量控制（匹配发送和接受速度）</li><li>差错控制</li><li>接入控制（访问控制）</li></ul></li><li>网络层<ul><li>逻辑寻址（ip）—全局的唯一逻辑地址</li><li>路由选择</li><li>分组转发</li></ul></li><li>传输层的功能（负责源-&gt;目的（端到端）（进程间）的完整报文传输）<ul><li>报文的分段和重组</li><li>SAP寻址（保证交给正确的进程）</li><li>可以实现端到端的链接控制，流量控制，差错控制</li></ul></li><li>会话层（主要负责对话管理，同步等）<ul><li>不单独存在</li></ul></li><li>表示层（处理两个系统之间交换信息的语法和语义问题）<ul><li>数据表示转化（大小端）</li><li>加解密，压缩，解压缩</li><li>不单独存在</li></ul></li><li>应用层</li></ol><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><ol><li>网络接口层、网际层、运输层、应用层</li><li><p>Everything over IP</p></li><li><p>5层参考模型</p><ul><li>物理层</li><li>数据链路层</li><li>网络层（源到目的的数据分组路由和转发）</li><li>传输层（TCP、UDP）{进程之间的通信}</li><li>应用层（支持各种网络应用）</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;计算机网络就是互连的、自治的计算机集合&lt;ul&gt;
&lt;li&gt;通过交换网络进行互连&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换&lt;u
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复试</title>
    <link href="http://blog.huhaobin.cn/2019/03/01/oj/"/>
    <id>http://blog.huhaobin.cn/2019/03/01/oj/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-04-04T07:59:19.241Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>sort<br><algorithm><br>bool ZuSort(testee t1, testee t2) {<br>if(t1.score == t2.score) return t1.id &lt; t2.id;<br>return t1.score &gt; t2.score;<br>}<br>sort(result, result + resultPos, ZuSort); // result[MAX]</algorithm></p></li><li><p>时间、日期等周期性数据应该从最小位自加，逐步控制更高一层的周期</p></li><li><p>空间换取时间：(散列)</p><ul><li><p>查找集合N 中的元素在集合M{2,6,7}中是否出现以及出现的次数</p><p> 可以用bool M[MAX], M[2] = true; M[6] = true; M[7] = true;</p><p> 求出现的次数时，可以用int M[MAX], M[2] ++; M[6] ++; M[7] ++;</p></li></ul></li><li><p>老哥，一定要记得多组数组共享变量的清零</p></li><li><p>利用printf(“%.2f\n” ,ans);格式化输出保留小数点两位</p></li><li><p>所有单调性函数求解问题都可以用二分法</p></li><li><p>最大公约数用辗转相除法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcd(a, b) = gcd(b, a%b);</div><div class="line">gcd(a, 0) = a</div></pre></td></tr></table></figure></li><li><p>最小公倍数的计算</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lcm(a, b) = (a/ gcd(a, b)) * b;</div></pre></td></tr></table></figure></li><li><p>分数表示</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">struct franction &#123;</div><div class="line">long long up,  down;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们约定，若分母(down)小于0,则令分子，分母为本身的相反数<br>约分即是分子分母同除以他们的最大公约数<br>若分子为0，则令分母为1<br>带分数：整数部分是up/down, 分子是abs(up)%down, 分母是down</p></li><li><p>求素数的方法:<br> 方法一：</p><ul><li>如果n对i, (i 属于[2,sqrt(n)]) 有约数（余数为0），则n不是素数</li><li><p>如果n对i, (i 属于[2,sqrt(n)]) 没有约数（余数不为0），则n是素数</p><p>方法二：</p></li><li>最小的素数的倍数肯定不是素数</li><li>2是素数</li><li>循环筛选</li></ul></li><li><p>求质因子的方法<br>质因子要么全部在[2,sqrt(n)]， 要么只有一个在[sqrt(n), n]。将前面的小于sqrt(n)的质因子全部除掉，剩下的如果！=1，那就是大于sqrt（n）的唯一的质因子</p></li><li><p>vector是一个边长数组<br>set是一个内部自动有序（递增）且不含重复元素的容器<br>set只能通过迭代器来访问， set<typename>::iterator it  // 通过* it访问内容</typename></p><p><em>multiset</em>可以处理元素不唯一的情况<br><em>unordered_set</em> 处理只去重但不排序的需求，速度比set快得多</p></li><li><p>除了vector和string之外的STL都不支持*(it + i)这种形式，只能通过图iteratorBianli.png形式来访问，<br>其他STL的各种操作都要通过迭代器来实现</p></li><li><p>map可以通过it-&gt;first来访问键，it-&gt;second 来访问值。并且map内部会自动按键从小到大排列，</p><p>unordered_map 用来处理只映射而不排序的需求（用散列代替map中的红黑树）</p></li><li><p>queue在top/pop前要先判断是否为空，</p></li><li><p>pair可以将两个元素绑在一起合成一个新的元素</p><ul><li>需要include<utility> 或者<map></map></utility></li><li>可以使用p.first p.second来访问</li><li>可以用作二维排序，一维相等时比较第二维</li><li>pair可以用作map的插入键值对</li></ul></li><li><p>algorithm头文件下的有用函数</p><ul><li>max(x,y)  min(x,y)</li><li>abs(x)  // 对整数求绝对值</li><li>fabs(x) // 对浮点数求绝对值</li><li>swap(x,y) //交换xy的值</li><li>find(x,y,c) // [x,y)查找元素c</li><li>reverse(it,it2) //将数组指针或者迭代器在[it,it2)之间的数组元素或者容器元素进行反转(逆序)</li><li>next_permutation(&amp;begin, &amp;end) // 给出序列[begin,end)在全排列中的下一个序列</li><li>fill() // 可以把容器或数组某一段区间赋为某个相同的值</li><li>对容器进行sort时，参数类型用容器的类型就好(对容器里面的元素进行排序)，实参一般要用迭代器</li><li>lower_bound(first, last, value) // 寻找数组或容器的[first, last)范围内第一个<strong>值大于或等于</strong> value的元素的位置，返回指针或迭代器</li><li>upper_bound(first, last, value) // 寻找数组或容器的[first, last)范围内第一个<strong>值大于</strong> value的元素的位置，返回指针或迭代器</li></ul></li><li><p>求联通分量的个数或者树的个数用并查集</p></li><li>错排公式<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">F(n) = (n-1)*F(n-1) + (n-1)*F(n-2)</div></pre></td></tr></table></figure></li></ol><h2 id="主要数据结构的实现"><a href="#主要数据结构的实现" class="headerlink" title="主要数据结构的实现"></a>主要数据结构的实现</h2><ol><li>哈夫曼树<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;int , vector&lt;int&gt; , greater&lt;int&gt; &gt; Q;</div></pre></td></tr></table></figure></li></ol><p>哈夫曼代价<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ans += a + b;</div></pre></td></tr></table></figure></p><ol><li>最小生成树可以用并查集实现</li><li>BFS<ul><li>一般用来求解最优解问题</li><li>将n元问题建模为n+1（自变量加结果）元问题的状态变化，通常需要一个n+1元结构体来做状态寄存；和一个原数据存储变量<br>一般每个样本点只用处理一次，注意处理次数和样品条件的剪枝</li></ul></li><li>DFS<ul><li>一般用来求解是否有解</li><li>是按层进行搜索和便历，故参数应该传层，递归的时候应该是<strong>层数加一</strong>，数据应该是本层数据取值i</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;sort&lt;br&gt;&lt;algorithm&gt;&lt;br&gt;bool ZuSort(testee t1, testee t2) {&lt;br&gt;if(t1.score == t2.score) return t1.id &amp;lt; t2.id;&lt;br&gt;return t1.sco
      
    
    </summary>
    
      <category term="考研" scheme="http://blog.huhaobin.cn/categories/%E8%80%83%E7%A0%94/"/>
    
    
      <category term="oj" scheme="http://blog.huhaobin.cn/tags/oj/"/>
    
  </entry>
  
  <entry>
    <title>红米note增强版刷入android7.1</title>
    <link href="http://blog.huhaobin.cn/2019/01/24/HMnote1s/"/>
    <id>http://blog.huhaobin.cn/2019/01/24/HMnote1s/</id>
    <published>2019-01-23T16:00:00.000Z</published>
    <updated>2019-01-24T14:43:26.103Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>root</p><p>参考链接<a href="http://en.miui.com/thread-208274-1-1.html" target="_blank" rel="external">http://en.miui.com/thread-208274-1-1.html</a></p><p>基本上就是先下载HMnote1S.zip这个压缩包，然后打开系统更新点击右上角的三个点选择从安装包更新，选择之前下载的压缩包更新即可。重启之后即可获得root</p></li><li><p>刷入twrp</p><p>需要下载的东西</p><ul><li><a href="https://drive.google.com/file/d/0B2sSKg3aizyzVXFQZVJ0UU5tTDg/view?pref=2&amp;pli=1" target="_blank" rel="external">https://drive.google.com/file/d/0B2sSKg3aizyzVXFQZVJ0UU5tTDg/view?pref=2&amp;pli=1</a></li><li>flashify app</li><li><a href="https://download.mokeedev.com/?device=gucci" target="_blank" rel="external">https://download.mokeedev.com/?device=gucci</a></li></ul></li><li><p>刷入</p><p> 下载完之后，打开flashify，刷入TWRP, 从文件安装，选择刚刚下载的recovery.img。刷入成功之后关机长按电源键和音量上键直至出现recovery界面<br> 选择wipe，清除无用数据，至少做到双清。<br> 返回到主界面选择install ，然后定位到 下载的Gucci即可</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;root&lt;/p&gt;
&lt;p&gt;参考链接&lt;a href=&quot;http://en.miui.com/thread-208274-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://en.miui.com/thread-208
      
    
    </summary>
    
      <category term="android" scheme="http://blog.huhaobin.cn/categories/android/"/>
    
    
  </entry>
  
</feed>
