<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saber110</title>
  
  <subtitle>越努力,越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huhaobin.cn/"/>
  <updated>2019-01-06T08:19:55.023Z</updated>
  <id>http://blog.huhaobin.cn/</id>
  
  <author>
    <name>Hu haobin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo重新搭建</title>
    <link href="http://blog.huhaobin.cn/2019/01/06/hexoBuild/"/>
    <id>http://blog.huhaobin.cn/2019/01/06/hexoBuild/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-06T08:19:55.023Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt install nodejs</div><div class="line">sudo apt install npm</div></pre></td></tr></table></figure></li><li><p>node升级</p><ul><li><p>使用n来下载版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo n lts 长期支持</div><div class="line">sudo n stable 稳定版</div><div class="line">sudo n latest 最新版</div><div class="line">sudo n 8.4.0 直接指定版本下载</div></pre></td></tr></table></figure></li><li><p>用上下键选择版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo n</div></pre></td></tr></table></figure></li><li><p>在新开的终端来面验证版本更改是否成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node -v</div></pre></td></tr></table></figure></li></ul></li><li><p>升级npm</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm i -g npm</div></pre></td></tr></table></figure></li><li><p>全局安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd hexo</div><div class="line">sudo npm install -g hexo-cli</div><div class="line">hexo init</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装nodejs&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/di
      
    
    </summary>
    
      <category term="hexo" scheme="http://blog.huhaobin.cn/categories/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>ssr</title>
    <link href="http://blog.huhaobin.cn/2018/11/02/ssr/"/>
    <id>http://blog.huhaobin.cn/2018/11/02/ssr/</id>
    <published>2018-11-01T16:00:00.000Z</published>
    <updated>2018-11-01T15:30:08.205Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</div></pre></td></tr></table></figure><p>bbr安装之后无法开机<br>安装完不要立即重启<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">echo &apos;add_drivers+=&quot;virtio_blk&quot;&apos; &gt;/etc/dracut.conf.d/force-vitio_blk-to-ensure-boot.conf</div><div class="line">cd /boot</div><div class="line">dracut -f /boot/initramfs-4.13.5-1.el6.elrepo.i686.img 4.13.5-1.el6.elrepo.i686</div><div class="line">reboot</div></pre></td></tr></table></figure></p><p>img 的名字是/boot下面较大的一个，前缀initramfs</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu搭建交叉编译环境</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/ubuntu-arm/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/ubuntu-arm/</id>
    <published>2018-09-24T05:53:47.888Z</published>
    <updated>2017-09-30T08:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.<em>*</em> mixed implicit and normal rules: deprecated syntax<br>  修改Makefile 452 修改后：<br>  %config: scripts_basic outputmakefile FORCE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;em&gt;*&lt;/em&gt; mixed implicit and normal rules: deprecated syntax&lt;br&gt;  修改Makefile 452 修改后：&lt;br&gt;  %config: scripts_basic outputmakefile FORCE
      
    
    </summary>
    
      <category term="未分类" scheme="http://blog.huhaobin.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="交叉编译" scheme="http://blog.huhaobin.cn/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>qt画图</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/qtPainting/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/qtPainting/</id>
    <published>2018-09-24T05:53:47.784Z</published>
    <updated>2018-04-21T06:15:31.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QcustomPlot"><a href="#QcustomPlot" class="headerlink" title="QcustomPlot"></a>QcustomPlot</h2><ol><li><p>下载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.qcustomplot.com</div></pre></td></tr></table></figure></li><li><p>把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可</p></li><li>pro文件中QT += widgets printsupport</li><li><p>使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">QVector x(101), y(101); // initialize with entries 0..100</div><div class="line">for (int i=0; i&lt;101; ++i)</div><div class="line">&#123;</div><div class="line">x[i] = i/50.0 – 1; // x goes from -1 to 1</div><div class="line">y[i] = x[i]*x[i]; // let’s plot a quadratic function</div><div class="line">&#125;</div><div class="line">qDebug()&lt;&lt;“data has been created”;</div><div class="line">ui-&gt;black_line-&gt;addGraph();</div><div class="line">qDebug()&lt;&lt;“begin painting”;</div><div class="line">ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);</div><div class="line">ui-&gt;black_line-&gt;replot();</div><div class="line">qDebug()&lt;&lt;“finish”;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QcustomPlot&quot;&gt;&lt;a href=&quot;#QcustomPlot&quot; class=&quot;headerlink&quot; title=&quot;QcustomPlot&quot;&gt;&lt;/a&gt;QcustomPlot&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载&lt;/p&gt;
 &lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Qt" scheme="http://blog.huhaobin.cn/categories/Qt/"/>
    
    
      <category term="上位机 Qt" scheme="http://blog.huhaobin.cn/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA-Qt/"/>
    
  </entry>
  
  <entry>
    <title>新博客站的第一篇文章</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/about/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/about/</id>
    <published>2018-09-24T05:53:47.768Z</published>
    <updated>2017-09-30T08:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百废待兴"><a href="#百废待兴" class="headerlink" title="百废待兴"></a>百废待兴</h2><p>自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本</p><h2 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h2><p>虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺.</p><h2 id="后悔莫及"><a href="#后悔莫及" class="headerlink" title="后悔莫及"></a>后悔莫及</h2><p>前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞</p><h3 id="有时间继续更新"><a href="#有时间继续更新" class="headerlink" title="有时间继续更新"></a>有时间继续更新</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百废待兴&quot;&gt;&lt;a href=&quot;#百废待兴&quot; class=&quot;headerlink&quot; title=&quot;百废待兴&quot;&gt;&lt;/a&gt;百废待兴&lt;/h2&gt;&lt;p&gt;自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名
      
    
    </summary>
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/categories/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/tags/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>集成库的学习</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/lib_int/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/lib_int/</id>
    <published>2018-09-24T05:53:47.732Z</published>
    <updated>2017-09-30T08:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol><li><p>在PCB library和SCH library里面可以更改器件的名字</p></li><li><p>在model manager里面进行原理图元器件和PCB元器件的映射</p></li><li><p>board insight提供了PCB图观察的各种视图</p></li><li><p>同时布多条线，放置—–交互式多跟布线</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;p&gt;个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="硬件" scheme="http://blog.huhaobin.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="AD" scheme="http://blog.huhaobin.cn/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/git/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/git/</id>
    <published>2018-09-24T05:53:47.732Z</published>
    <updated>2017-09-28T15:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">git push origin 本地分支名:远程分支名</div><div class="line">git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</div><div class="line"></div><div class="line">git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面加“*”号标记</div><div class="line">git checkout BRANCH_ID 切换分支</div><div class="line">git branch -r 列出远程分支</div><div class="line">git branch -a</div><div class="line">git branch name 新建分支</div><div class="line">git branch -d | -D branchname 删除branchname分支</div><div class="line">git branch -d -r branchname 删除远程branchname分支</div><div class="line"></div><div class="line">git <span class="built_in">log</span></div><div class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></div><div class="line">git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line">git diff --name-status OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line"></div><div class="line">git checkout COMMIT_ID 版本回退</div><div class="line"></div><div class="line">git stash list 查看堆栈情况</div><div class="line">git stash 将当前工作压栈</div><div class="line">git stash pop stash<span class="variable">$&#123;id&#125;</span> 弹出工作栈</div><div class="line">git stash clear 清除栈</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ci  library</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/ci-library/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/ci-library/</id>
    <published>2018-09-24T05:53:47.676Z</published>
    <updated>2017-09-30T08:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>调用时库名必须全部小写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调用时库名必须全部小写&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.huhaobin.cn/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言大坑</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/a_bigHole_ofC/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/a_bigHole_ofC/</id>
    <published>2018-09-24T05:53:47.636Z</published>
    <updated>2018-03-24T04:10:48.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接下来就开始看看坑"><a href="#接下来就开始看看坑" class="headerlink" title="接下来就开始看看坑"></a>接下来就开始看看坑</h2><ol><li><p>单引号表示表示整数值</p><ul><li>双引号表示字符串首的地址</li><li>以0开头的整数默认为八进制</li><li>注意使用移位运算加快程序执行速度</li><li>if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致</li><li>a[i] = i[a]</li><li>C语言的不对称边界</li><li>errno 外部出错变量，可以检测出错信息</li><li>break 跳出离他最近的那层循环或switch</li><li>C 语言不能省略形参，即使不使用</li></ul></li><li><p>C语言的数据存储空间</p><ul><li>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）</li><li>局部变量在return之后出栈销毁，不要尝试返回局部指针地址</li><li>堆  申请、释放原则 <strong>哪儿申请哪儿释放</strong><br> 记得判断 堆 申请成功与否</li></ul></li><li><p>一个程序将操作系统分配给其运行的内存块分为4个区域：<br>　　(1)代码区，存放程序的代码，即程序中的各个函数代码块。<br>　　(2)全局数据区，存放程序的全局数据和静态数据。<br>　　(3)堆区，存放程序的动态数据。<br>　　(4)栈区，存放程序的局部数据，即各个函数中的数据。</p></li><li><p>强制类型转换</p></li></ol><ul><li>占用空间大的转化为占用空间小的： 考虑字节序（大小端），所使用的部分可能在不同机器上截然不同</li><li>占用空间小的转化为占用空间大的： 考虑内存越界访问</li><li>结构体强制转换             ： 考虑字节对齐</li></ul><ol><li>字符串</li></ol><ul><li>通过索引读取字符串时，一定要判断索引的正确性</li></ul><ol><li>多线程编程</li></ol><ul><li>互斥量用来对临界区的互斥进入</li><li>条件变量用于线程的阻塞等待</li></ul><ol><li><p>指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int * p = NULL;</div><div class="line"></div><div class="line">&amp;p 表示p的地址</div><div class="line">p 表示变量p的内容</div><div class="line">*p 表示p指向的存储单元的内容</div></pre></td></tr></table></figure><ul><li><strong>数字0是唯一能输给指针的数值</strong>(相当于NULL)  </li><li>void * :指向任何类型的指针</li><li><strong>注意深复制和浅复制的区别</strong><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p, *q;</div><div class="line">*p = 58;</div><div class="line">q = p;        // q 和 P 指向同一内存单元</div><div class="line">free(q);</div><div class="line">printf(&quot;%d\n&quot;,p); //异常。p的内存已经被q释放</div></pre></td></tr></table></figure></li></ul></li><li><p>动态变量</p><p>在程序运行过程中产生的变量称为动态变量</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int * p; char *q;</div><div class="line">p = new int;  // 在内存中创建一个变量，存储所分配的内存地址到p中</div><div class="line">q = new char[19];   // 在内存中创建一个数组，并将数组地址存储到q中</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p = 28;</div><div class="line">*q = &quot;hello&quot;;</div></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete p;</div><div class="line">delete [] q;</div></pre></td></tr></table></figure></li></ul></li><li><p>动态数组</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int *p;</div><div class="line">p = new int[10];</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* p = 25;   //25存到第一个存储空间里  = p[0] = 25；</div><div class="line">p ++;</div><div class="line">* p = 35;   //35存到第二个存储空间里  = p[1] = 35；</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接下来就开始看看坑&quot;&gt;&lt;a href=&quot;#接下来就开始看看坑&quot; class=&quot;headerlink&quot; title=&quot;接下来就开始看看坑&quot;&gt;&lt;/a&gt;接下来就开始看看坑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单引号表示表示整数值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号表示字符串首
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>socksV5转化为http代理</title>
    <link href="http://blog.huhaobin.cn/2018/09/24/sockstohttp/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/sockstohttp/</id>
    <published>2018-09-24T05:53:47.556Z</published>
    <updated>2018-07-06T11:52:07.801Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用工具  privoxy</li></ol><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install privoxy</div></pre></td></tr></table></figure></p><p>更改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/privoxy/config</div></pre></td></tr></table></figure></p><p>并在里面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forward-socks5   /               127.0.0.1:1080 .</div></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service privoxy restart</div></pre></td></tr></table></figure></p><p>给系统设置http代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div></pre></td></tr></table></figure></p><p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=http://127.0.0.1:8118/</div></pre></td></tr></table></figure></p><p>使更改生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用工具  privoxy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre
      
    
    </summary>
    
      <category term="代理" scheme="http://blog.huhaobin.cn/categories/%E4%BB%A3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2018/09/24/UnistallPip/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/UnistallPip/</id>
    <published>2018-09-24T05:53:47.556Z</published>
    <updated>2018-06-19T03:53:09.789Z</updated>
    
    <content type="html"><![CDATA[<p>python -m pip uninstall pip</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python -m pip uninstall pip&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2018/09/24/csu/"/>
    <id>http://blog.huhaobin.cn/2018/09/24/csu/</id>
    <published>2018-09-24T05:53:47.492Z</published>
    <updated>2018-03-04T05:31:56.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://123.206.64.174" target="_blank" rel="external">http://123.206.64.174</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://123.206.64.174&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://123.206.64.174&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>程序员的自我修养</title>
    <link href="http://blog.huhaobin.cn/2018/05/13/Programmer&#39;sSelfCultivation2/"/>
    <id>http://blog.huhaobin.cn/2018/05/13/Programmer&#39;sSelfCultivation2/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-05-13T06:31:30.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在优先级调度的环境下，线程优先级改变的方式有</p><ul><li>用户制定优先级</li><li>根据进入等待状态的频繁程度提升或降低优先级</li><li>长时间得不到执行而提升优先级<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2></li></ul><p>基本结构如图所示<img src="/image/objSample.png" alt=""></p><ul><li>初始化的全局变量和局部静态变量保存在.data</li><li>未初始化的全局变量和局部静态变量保存在.bss</li><li>File Header 里面包含一个段表<br>除此之外还可以自定义段<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">__attribute__((section(&quot;FOO&quot;))) int global = 42;</div><div class="line">__attribute__((section(&quot;BAR&quot;))) void foo()</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">// 这样就可以把相应的变量或者函数放在以“FOO”/&quot;BAR&quot;作为段名的段中</div><div class="line">// 名字可以自定义</div></pre></td></tr></table></figure></li></ul><h2 id="C-和C的兼容"><a href="#C-和C的兼容" class="headerlink" title="C++和C的兼容"></a>C++和C的兼容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extern &quot;C&quot;&#123;</div><div class="line">  int func(int);</div><div class="line">  int var;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>C++ 编译器会将在extern “C”大括号内部的代码当作C语言来处理</p><p>为了处理C++调用了C函数，但认为是C++函数，经过名称修饰之后无法正确引用的问题，C++编译器会在便宜C++的程序时默认定义宏”__cplusplus”.我们可以使用条件宏来判断当前便宜单元是不是C++代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#ifdef __cplusplus</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">#endif</div><div class="line"></div><div class="line">void *memset(void *, int, size_t);    // C语言内容</div><div class="line">#ifdef __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程调度&quot;&gt;&lt;a href=&quot;#线程调度&quot; class=&quot;headerlink&quot; title=&quot;线程调度&quot;&gt;&lt;/a&gt;线程调度&lt;/h2&gt;&lt;p&gt;在优先级调度的环境下，线程优先级改变的方式有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户制定优先级&lt;/li&gt;
&lt;li&gt;根据进入等待状态的
      
    
    </summary>
    
      <category term="程序员的自我修养" scheme="http://blog.huhaobin.cn/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="程序员的自我修养" scheme="http://blog.huhaobin.cn/tags/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
  </entry>
  
  <entry>
    <title>信息的表示和处理</title>
    <link href="http://blog.huhaobin.cn/2018/05/11/OS2/"/>
    <id>http://blog.huhaobin.cn/2018/05/11/OS2/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-05-13T01:59:51.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><ol><li><p>数据大小</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">C类型      字节（32位）  字节（64位）</div><div class="line">char            1        1</div><div class="line">short int       2        2</div><div class="line">int             4        4</div><div class="line">long int        4        8</div><div class="line">long long int   8        8</div><div class="line">float           4        4</div><div class="line">double          8        8</div><div class="line">char *          4        8</div></pre></td></tr></table></figure></li><li><p>移位</p><p> 假如进行x&gt;&gt;k,这里的k很大,实际偏移量是通过k mod v得到的</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int lval = 0xede875 &gt;&gt; 32;</div><div class="line">int aval = 0xede875 &gt;&gt; 36;</div><div class="line">unsigned int uval = 0xede875 &gt;&gt; 40;</div></pre></td></tr></table></figure><p> 在32位机器上</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lval = 0xede875;            // 32 mod 32 = 0</div><div class="line">aval = 0xfede87;            // 36 mod 32 = 4</div><div class="line">uval = 0x00ede8;</div></pre></td></tr></table></figure><p> <strong>几乎所有的编译器/机器都对有符号数据使用算术右移，无符号数据必须是逻辑右移</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;信息存储&quot;&gt;&lt;a href=&quot;#信息存储&quot; class=&quot;headerlink&quot; title=&quot;信息存储&quot;&gt;&lt;/a&gt;信息存储&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;数据大小&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://blog.huhaobin.cn/2018/05/09/OS1/"/>
    <id>http://blog.huhaobin.cn/2018/05/09/OS1/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-05-09T13:24:04.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程介绍"><a href="#进程介绍" class="headerlink" title="进程介绍"></a>进程介绍</h2><ol><li><p>进程的创建</p><p>原因：</p><ul><li>系统初始化</li><li>正在运行的进程执行了创建进程的系统调用</li><li>用户请求创建一个新进程</li><li>批处理作业的初始化</li></ul></li><li><p>进程的终止</p><p>原因：</p><ul><li>正常退出（自愿）</li><li>出错退出（自愿）</li><li>严重错误（非自愿）</li><li>被其他进程杀死（非自愿）</li></ul></li><li><p>进程的状态</p><ul><li>运行态</li><li>就绪态</li><li>阻塞态</li></ul></li><li><p>线程可以在内核和用户空间中进行管理，但不论是在哪儿都会引来很多问题</p><h2 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h2></li><li><p>临界区</p><p>一个好的临界区解决方案需要具备以下四个条件：</p><ul><li>任何两个进程不能同时处于临界区</li><li>不应对CPU的速度和数目做任何假设</li><li>临界区外的进程不能阻塞其他进程</li><li>不能让进程在临界区外面无休止的等待</li></ul></li><li><p>忙等待形式的互斥</p><ol><li><p>关闭中断</p><p> 在进入临界区之前先关中断，退出之后开中断。这样把开关中断的权限交给用户是不明智的</p></li><li><p>锁变量</p><p> 设置一个共享锁变量，0表示临界区内没有进程，1表示有。每次进入之前先测试，如果此时为0则设置为1，退出临界区设置为0。遗憾的是这个方法也<strong>不是线程安全</strong>的</p></li><li><p>严格交替法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WHILE(TRUE)</div><div class="line">&#123;</div><div class="line">  WHILE(turn != 0);</div><div class="line">  critical_region();</div><div class="line">  turn = 1;</div><div class="line">  noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WHILE(TRUE)</div><div class="line">&#123;</div><div class="line">  WHILE(turn != 1);</div><div class="line">  critical_region();</div><div class="line">  turn = 0;</div><div class="line">  noncritical_region();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p> 整型变量turn的初值为零，用于跟踪轮到哪个进程进入临界区。一开始进程0检查turn，发现是0，所以进入临界区。同时进程1也在检查turn，不停的检查是否变为1。这样就产生了<a href="https://baike.baidu.com/item/%E5%BF%99%E7%A2%8C%E7%AD%89%E5%BE%85/16256157?fr=aladdin" target="_blank" rel="external">忙等待</a>。还有一种情况就是进程0退出临界区并将turn设置为1，此时进程0和1都在忙非临界区的任务，但是进程0先忙完需要进入临界区，由于turn为1所以进程0不能进入临界区</p></li><li>Peterson解决方案</li><li>TSL语句</li></ol></li><li><p>信号量</p><p> 用一个整型变量来累计唤醒次数，供以后使用。<br> 在这个解决方案中用了三个信号量。</p><ul><li>full 用来记录满的缓冲槽的数目，初值为0</li><li>empty 用来记录空的缓冲槽的数目，初值为缓冲区内槽的数目</li><li><p>mutex 用来确保生产者和消费者不会同时访问缓冲区，初值为1</p><p>多个进程使用初值为1的信号量可以保证同时只有一个进程可以进入临界区，如果每个进程在进入临界区之前执行一个down，退出之后执行一个up就可以保证互斥</p></li></ul></li><li><p>互斥</p><p> 若不需要信号量的计数能力，有时可以使用信号量的另一个版本—-互斥<br> 互斥是一个可以处于两态之一的变量：解锁(mutex_unlock)和加锁(mutex_lock)</p></li><li>管程<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3></li><li>先到先服务</li><li>最短作业优先</li><li>最短剩余时间优先</li><li>三级调度<ul><li>准入调度器</li><li>内存调度器</li><li>CPU调度器<h3 id="交互系统中的调度"><a href="#交互系统中的调度" class="headerlink" title="交互系统中的调度"></a>交互系统中的调度</h3></li></ul></li><li>时间片轮转调度</li><li><p>优先级调度</p><p> 注意时常对优先级进行调整，防止低优先级的进程饿死</p></li><li>多重队列</li><li>最短进程优先（老化算法预估进程运行所需时间）</li><li>保证调度算法</li><li>彩票调度算法</li><li>公平分享调度<h3 id="实时系统调度"><a href="#实时系统调度" class="headerlink" title="实时系统调度"></a>实时系统调度</h3></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程介绍&quot;&gt;&lt;a href=&quot;#进程介绍&quot; class=&quot;headerlink&quot; title=&quot;进程介绍&quot;&gt;&lt;/a&gt;进程介绍&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程的创建&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统初始化&lt;/li&gt;
&lt;li&gt;正在运行的进程执
      
    
    </summary>
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="操作系统原理" scheme="http://blog.huhaobin.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Octave安装forge</title>
    <link href="http://blog.huhaobin.cn/2018/04/30/OctaveInstallforge/"/>
    <id>http://blog.huhaobin.cn/2018/04/30/OctaveInstallforge/</id>
    <published>2018-04-30T13:56:20.000Z</published>
    <updated>2018-04-30T02:26:40.678Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>安装缺少的库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install liboctave-dev</div></pre></td></tr></table></figure></li><li><p>安装control</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">octave-cli</div><div class="line">pkg install -forge fuzzy-logic-toolkit</div><div class="line">pkg install -forge control</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装缺少的库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;cod
      
    
    </summary>
    
      <category term="Octave" scheme="http://blog.huhaobin.cn/categories/Octave/"/>
    
    
      <category term="Octave" scheme="http://blog.huhaobin.cn/tags/Octave/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之神经网络</title>
    <link href="http://blog.huhaobin.cn/2018/04/29/machine-learning4/"/>
    <id>http://blog.huhaobin.cn/2018/04/29/machine-learning4/</id>
    <published>2018-04-29T13:56:20.000Z</published>
    <updated>2018-04-29T09:13:42.143Z</updated>
    
    <content type="html"><![CDATA[<p><strong>a在这里表示神经网络中的神经元</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>二元分类(Binary classification)</li><li>多分类(Multi-class classification)</li></ol><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p><img src="/image/costfunctionBetweenLRandNeuralNetwork.png" alt=""></p><ul><li>L: 网络中的总层数</li><li>K: 输出层神经元的数量</li><li>S<sub>l</sub>: l 层的总神经元数量(不算偏置单元)额<!-- 注意： 这是单个 -->为了计算代价函数的最小值，我们使用反向传播算法</li></ul><h2 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h2><p>(计算出代价函数下降最快的方向)<br>给出训练集{(x<sup>(1)</sup>,y<sup>(1)</sup>)⋯(x<sup>(m)</sup>,y<sup>(m)</sup>)}</p><p>令 Δ<sub>i,j</sub><sup>(l)</sup> := 0 for all (l,i,j), (hence you end up having a matrix full of zeros)</p><p>For training example t =1 to m:</p><ol><li>Set a<sup>(1)</sup>:=x<sup>(t)</sup></li><li>Perform forward propagation to compute a<sup>(l)</sup> for l=2,3,…,L<br><img src="/image/GradientForNeuralNetwork.png" alt=""></li><li>Using y(t), compute δ<sup>(L)</sup>=a<sup>(L)</sup>−y<sup>(t)</sup></li><li>Compute δ<sup>(L−1)</sup>,δ<sup>(L−2)</sup>,…,δ<sup>(2)</sup> using δ<sup>(l)</sup>=((Θ<sup>(l)</sup>)<sup>T</sup>δ<sup>(l+1)</sup>) .∗ a<sup>(l)</sup> .∗ (1−a<sup>(l)</sup>)</li><li>Δ<sub>i,j</sub><sup>(l)</sup>:=Δ<sub>i,j</sub><sup>(l)</sup>+a<sub>j</sub><sup>(l)</sup>δ<sub>i</sub><sup>(l+1)</sup> or with vectorization, Δ<sup>(l)</sup>:=Δ<sup>(l)</sup>+δ<sup>(l+1)</sup>(a<sup>(l)</sup>)<sup>T</sup></li></ol><p>Hence we update our new Δ matrix.</p><ul><li>D<sub>i,j</sub>(l):=1/m(Δ<sub>i,j</sub><sup>(l)</sup>+λΘ<sub>i,j</sub><sup>(l)</sup>), if j≠0.</li><li>D<sub>i,j</sub><sup>(l)</sup>:=1/mΔ<sub>i,j</sub><sup>(l)</sup> If j=0</li></ul><p>所以得出J的微分为<img src="/image/partialDerivativeOfJInNN.png" alt=""></p><h2 id="向量展开"><a href="#向量展开" class="headerlink" title="向量展开"></a>向量展开</h2><p>在之前的学习过程中我们总是使用fminunc来优化参数，但是他要求所有的输入和输出均是向量，我们在神经网络中使用的时候只能把Theta矩阵和Gradient矩阵进行向量化</p><ul><li>size(Theta1) = 10 * 11</li><li>size(Theta2) = 10 * 11</li><li>size(Theta3) = 1 * 11<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">thetaVector = [ Theta1(:); Theta2(:); Theta3(:); ]</div><div class="line">deltaVector = [ D1(:); D2(:); D3(:) ]</div></pre></td></tr></table></figure></li></ul><p>恢复为矩阵<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Theta1 = reshape(thetaVector(1:110),10,11)</div><div class="line">Theta2 = reshape(thetaVector(111:220),10,11)</div><div class="line">Theta3 = reshape(thetaVector(221:231),1,11)</div></pre></td></tr></table></figure></p><h2 id="梯度计算结果校验"><a href="#梯度计算结果校验" class="headerlink" title="梯度计算结果校验"></a>梯度计算结果校验</h2><p>反向传播算法复杂多变，我们使用导数的定义来校验反向传播得到的结果是否正确(相差很小)，当确定正确之后关掉梯度校验。因为他很 <strong>慢</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">epsilon = 1e-4;</div><div class="line">for i = 1:n,</div><div class="line">  thetaPlus = theta;</div><div class="line">  thetaPlus(i) += epsilon;</div><div class="line">  thetaMinus = theta;</div><div class="line">  thetaMinus(i) -= epsilon;</div><div class="line">  gradApprox(i) = (J(thetaPlus) - J(thetaMinus))/(2*epsilon)</div><div class="line">end;</div></pre></td></tr></table></figure><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>为了避免神经网络因为相同的Theta而陷入冗余的计算，范围是[-INIT_EPSILON,INIT_EPSILON]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.</div><div class="line"></div><div class="line">Theta1 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div><div class="line">Theta2 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div><div class="line">Theta3 = rand(1,11) * (2 * INIT_EPSILON) - INIT_EPSILON;</div></pre></td></tr></table></figure></p><h2 id="网络选择-的步骤"><a href="#网络选择-的步骤" class="headerlink" title="网络选择 的步骤"></a>网络选择 的步骤</h2><ul><li>Number of input units = dimension of features x(i)</li><li>Number of output units = number of classes</li><li>Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units)</li><li>Defaults: 1 hidden layer. If you have more than 1 hidden layer, then it is recommended that you have the same number of units in every hidden layer.<h2 id="网络训练的步骤"><a href="#网络训练的步骤" class="headerlink" title="网络训练的步骤"></a>网络训练的步骤</h2></li><li>Randomly initialize the weights</li><li>Implement forward propagation to get hΘ(x<sup>(i)</sup>) for any x<sup>(i)</sup></li><li>Implement the cost function</li><li>Implement backpropagation to compute partial derivatives</li><li>Use gradient checking to confirm that your backpropagation works. Then disable gradient checking.</li><li>Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta.</li></ul><p>When we perform forward and back propagation, we loop on every training example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i = 1:m,</div><div class="line">   Perform forward propagation and backpropagation using example (x(i),y(i))</div><div class="line">   (Get activations a(l) and delta terms d(l) for l = 2,...,L</div></pre></td></tr></table></figure></p><p>(There are m training sets)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;a在这里表示神经网络中的神经元&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二元分类(Binary classificati
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之神经网络介绍</title>
    <link href="http://blog.huhaobin.cn/2018/04/28/machine-learning3/"/>
    <id>http://blog.huhaobin.cn/2018/04/28/machine-learning3/</id>
    <published>2018-04-28T13:56:20.000Z</published>
    <updated>2018-04-29T05:57:51.219Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。</p><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><ol><li>层： 输入层、隐藏层、输出层</li><li><p>仍然使用sigmoid函数<br>3.<br><img src="/image/AppearanceOfNeuronNetwork.png" alt="基本形式"></p><ul><li>a<sub>i</sub><sup>j</sup>: 第j层的第i个元素</li><li><p>Θ<sup>(j)</sup>: j层到j+1层的权重映射矩阵</p><p><strong>如果网络在j层有s<sub>j</sub>个单元，j+1层有s<sub>j+1</sub>个单元，那么Θ<sup>(j)</sup>的维度为s<sub>j+1</sub>×(s<sub>j</sub>+1)</strong></p></li></ul></li><li>向量化<br>对于中间层的计算，我们可以定义Z使得<br><img src="/image/neuralNetworkHiddenCompute.png" alt=""> 变形为<img src="/image/neuralNetworkHiddenCompute-z.png" alt=""><br>进行向量化之后<br><img src="/image/NeuralNetworkVectlize.png" alt=""><br>也就是说<br><img src="/image/ZNeuralNetwork.png" alt=""> <img src="/image/HNeuralNetwork.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。&lt;/p&gt;
&lt;h2 id=&quot;表示&quot;&gt;&lt;a href=&quot;#表示&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之逻辑分类问题</title>
    <link href="http://blog.huhaobin.cn/2018/04/27/machine-learning2/"/>
    <id>http://blog.huhaobin.cn/2018/04/27/machine-learning2/</id>
    <published>2018-04-27T13:56:20.000Z</published>
    <updated>2018-04-28T08:20:46.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑回归问题"><a href="#逻辑回归问题" class="headerlink" title="逻辑回归问题"></a>逻辑回归问题</h1><h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><ol><li>逻辑回归<br><img src="/image/HypothesisRepresentation.png" alt="逻辑回归"></li><li><p>线性回归</p><p>线性回归中 <strong>g(z)=1</strong></p></li></ol><h2 id="决策边界-Decision-boundary"><a href="#决策边界-Decision-boundary" class="headerlink" title="决策边界(Decision boundary)"></a>决策边界(Decision boundary)</h2><p>  一条分割y=0和y=1的线</p><h2 id="代价函数-cost-function"><a href="#代价函数-cost-function" class="headerlink" title="代价函数(cost function)"></a>代价函数(cost function)</h2><p>  <img src="/image/CostFunctionInLogisticRegression.png" alt="代价函数"><br>  整合之后<br>  <img src="/image/CostFunctionForLRM.png" alt="整合代价函数"><br>  gradient计算<br>  <img src="/image/GradientForLogstic.png" alt="gradient"></p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><p>  <img src="/image/GradientDescentForLRM.png" alt="梯度下降法"></p><h2 id="过度拟合"><a href="#过度拟合" class="headerlink" title="过度拟合"></a>过度拟合</h2><p>  过度拟合只会充分的拟合训练数据集，对数据预测并不会得到想要的值</p><ul><li>解决方法(regularization)</li></ul><h2 id="regularization"><a href="#regularization" class="headerlink" title="regularization"></a>regularization</h2><ol><li>重新设置代价函数(cost function)J<br><img src="/image/RegularizedLinerRegression.png" alt="J"><br>给每个theta做惩罚，用足够大的lambda去削弱theta的作用，从而平滑h。但是lambda太大的话将导致欠拟合，太大的时候得到的仅仅是一条扁平的直线</li><li>梯度下降法<br><img src="/image/RegularizationGradientDescent.png" alt=""><br>将theta分开更新是因为在重新设计代价函数的时候没有给theta惩罚，简化之后为<img src="/image/RegularizationGradientDescentJ.png" alt=""></li><li>归一化求代价函数的最小值<br><img src="/image/RegularizationNormalEquation.png" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;逻辑回归问题&quot;&gt;&lt;a href=&quot;#逻辑回归问题&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归问题&quot;&gt;&lt;/a&gt;逻辑回归问题&lt;/h1&gt;&lt;h2 id=&quot;系统函数&quot;&gt;&lt;a href=&quot;#系统函数&quot; class=&quot;headerlink&quot; title=&quot;系
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
  <entry>
    <title>机器学习之线性回归问题</title>
    <link href="http://blog.huhaobin.cn/2018/04/23/machine-learning1/"/>
    <id>http://blog.huhaobin.cn/2018/04/23/machine-learning1/</id>
    <published>2018-04-23T13:56:20.000Z</published>
    <updated>2018-04-28T08:20:01.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性回归问题"><a href="#线性回归问题" class="headerlink" title="线性回归问题"></a>线性回归问题</h1><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><ol><li>假设系统函数<br><img src="/image/Hypothesis.png" alt="系统函数"></li><li><p>代价函数<br><img src="/image/costFunction.png" alt="代价函数"></p><p> alpha: 学习效率</p><h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2></li><li>普适算法<br><img src="/image/GradientDescentAlgo.png" alt="普适算法"></li><li><p>线性回归中<br><img src="/image/GradientDescentForLinearRegression.png" alt="线性回归"><br><img src="/image/GDALRS.png" alt="去微分"></p><p> <strong>记得同步更新theta</strong></p><h2 id="多变量的线性回归问题"><a href="#多变量的线性回归问题" class="headerlink" title="多变量的线性回归问题"></a>多变量的线性回归问题</h2><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3></li><li><p>数据缩放()</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X = X/MAX(X);</div></pre></td></tr></table></figure><p> 使得X <strong>接近</strong>[-1,1]区间</p></li><li><p>平均值正常化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X = (X-U)/(max(X)-MIN(x)) // U是X的平均值</div></pre></td></tr></table></figure></li><li><p>数据归一化</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theta = pinv(X&apos;*X)*X&apos;*y;</div></pre></td></tr></table></figure></li></ol><p>可以用正态方程求解代价函数最小值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线性回归问题&quot;&gt;&lt;a href=&quot;#线性回归问题&quot; class=&quot;headerlink&quot; title=&quot;线性回归问题&quot;&gt;&lt;/a&gt;线性回归问题&lt;/h1&gt;&lt;h2 id=&quot;代价函数&quot;&gt;&lt;a href=&quot;#代价函数&quot; class=&quot;headerlink&quot; title=&quot;代
      
    
    </summary>
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/categories/machine-learning/"/>
    
    
      <category term="machine-learning" scheme="http://blog.huhaobin.cn/tags/machine-learning/"/>
    
  </entry>
  
</feed>
