<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saber110</title>
  
  <subtitle>越努力,越幸运</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.huhaobin.cn/"/>
  <updated>2019-05-07T08:06:00.132Z</updated>
  <id>http://blog.huhaobin.cn/</id>
  
  <author>
    <name>Hu haobin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>组会记录</title>
    <link href="http://blog.huhaobin.cn/2019/05/06/groupMetting1/"/>
    <id>http://blog.huhaobin.cn/2019/05/06/groupMetting1/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-07T08:06:00.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="the-difference-between-‘Nature’-and-‘Science’"><a href="#the-difference-between-‘Nature’-and-‘Science’" class="headerlink" title="the difference between ‘Nature’ and ‘Science’"></a>the difference between ‘Nature’ and ‘Science’</h2><p>nature: 懂事前就有的东西，即懂事前已经有了的东西</p><p>science：懂事后才有的东西，在自己懂事之后的出现的东西</p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><ul><li><p>输出root-tree，输出若干个根树（非连通图）</p></li><li><p>最先由于解决迷宫问题—&gt;判断终点问题而提出</p></li><li><p>应用</p><ul><li><p>查找图中的所有连接组件（一个连接组件是图中的最大连接子图）</p><p>由起点开始运行BFS所经过的所有节点，即为包含七点的一个连接组件</p></li><li><p>查找连接组件中的所有节点</p></li><li><p>查找非加权图中的任意两点间的最短路径</p></li><li><p>测试某图是否是<strong>二分图(bipartite graph)</strong></p><p>从任一节点出发，在搜索过程中给节点不同的标签，例如给开始点标0，开始点的所有邻居1，开始点的所有邻居的邻居再标0，以此类推。若在搜索过程中，任一节点有跟其相同标签的邻居，则此图不是二分图。若搜索结束时没有发生这种情况则说明此图是一二分图</p></li><li><p>应用于计算机游戏中的平面网格</p><p>BFS可用来解决计算机游戏（例如即时策略游戏）中找寻路径的问题。在这个应用中，使用平面网格来代替图形，而一个格子即是图中的一个节点。所有节点都与它的邻居（上、下、左、右、左上、右上、左下、右下）相接。</p><p>值得一提的是，当这样使用BFS算法时，首先要<strong>先检验上、下、左、右</strong>的邻居节点，<strong>再检验左上、右上、左下、右下</strong>的邻居节点。这是因为BFS趋向于先查找斜向邻居节点，而不是四方的邻居节点，因此找到的路径将不正确。BFS应该先查找四方邻居节点，接着才查找斜向邻居节点。</p></li></ul></li></ul><h2 id="LBFS-Lexicographic-breadth-first-search"><a href="#LBFS-Lexicographic-breadth-first-search" class="headerlink" title="LBFS(Lexicographic breadth-first search)"></a>LBFS(Lexicographic breadth-first search)</h2><ul><li><p>词典序的广度优先搜索算法</p></li><li><p>基于<a href="https://en.wikipedia.org/wiki/Partition_refinement" target="_blank" rel="external">Partition refinement</a>（一种用数据结构分类将集合分类为若干组小的集合的算法）</p></li><li><p>应用</p><ul><li><p>识别chordal graph</p><ul><li><p>Use lexicographic breadth-first search to find a lexicographic ordering of <em>G</em><br>  // 对图G使用LBFS生成一个LBFS序列</p><ul><li><p>For each vertex v :<br>// 对于每个顶点V</p></li><li><p>Let w be the neighbor of v occurring prior to v , as close to v in the sequence as possible<br>// 设w是v之前出现的v的邻居，尽可能接近序列中的v</p><ul><li>(Continue to the next vertex <em>v</em> if there is no such <em>w</em>)</li></ul><p>​    // 若没有符合要求的w则去下个定点v</p></li><li><p>If the set of earlier neighbors of <em>v</em> (excluding <em>w</em> itself) is not a subset of the set of earlier neighbors of <em>w</em>, the graph is not chordal</p></li></ul><p>// 如果v的早期邻居集合（不包括w本身）不是w的早期邻居集合的子集，则不是chordal</p></li><li><p>If the loop terminates without showing that the graph is not chordal, then it is chordal.</p></li></ul></li><li><p>图染色问题</p></li></ul></li></ul><h2 id="MCS（maximum-cardinality-search）"><a href="#MCS（maximum-cardinality-search）" class="headerlink" title="MCS（maximum cardinality search）"></a>MCS（maximum cardinality search）</h2><p>以任一点为起点，优先访问已访问邻居数最多的点</p><ul><li>可以用来识别chordal graph</li><li>MCS按照最大生成树的顺序进行下去</li></ul><h2 id="clique"><a href="#clique" class="headerlink" title="clique"></a>clique</h2><ul><li><p>一个无向图中，满足两两之间有边连接的顶点的集合，被称为该无向图的团</p></li><li><p>顶点集C被称为<a href="https://zh.wikipedia.org/wiki/無向圖" target="_blank" rel="external">无向图</a> G=(V,E) 的<strong>团</strong>，如果C是<a href="https://zh.wikipedia.org/wiki/顶点" target="_blank" rel="external">顶点</a>集V的子集(C⊆V)，而且任意两个C中的顶点都有<a href="https://zh.wikipedia.org/wiki/边" target="_blank" rel="external">边</a>连接。另一种等价的说法是，由C诱导的子图是<a href="https://zh.wikipedia.org/wiki/完全圖" target="_blank" rel="external">完全图</a> （有时也用“团”来指这样的子图）。</p></li><li><p><strong>极大团</strong>是指增加任一顶点都不再符合团定义的团，也就是说，极大团不能被任何一个更大的团所包含。</p></li></ul><h2 id="chordal-graph"><a href="#chordal-graph" class="headerlink" title="chordal graph"></a>chordal graph</h2><ul><li>如果长度大于3的每个圈都具有弦，即具有连接圈中的两个非连续顶点的边，则无向图被称为弦图。</li><li><em>一个无向图称为弦图当图中任意长度大于3的环都至少有一个弦。</em></li><li>chordal的任何一部分都是chordal</li><li>MCS在chordal上的终点是simplicial point</li><li>MCS在chordal上一定按着极大团的顺序遍历</li></ul><h2 id="区间图"><a href="#区间图" class="headerlink" title="区间图"></a>区间图</h2><p>在图论中，区间图是由实线上的一组区间形成的无向图，每个区间具有顶点，区间相交的顶点之间具有边。 它是间隔的交叉图。</p><p><img src="/image/Interval_graph.svg" alt="Seven intervals on the real line and the corresponding seven-vertex interval graph"></p><p>使用LBFS三遍就能生成</p><ul><li>第一遍任选起点，记录终点</li><li>第二遍从终点开始便历（会有某些错位的需要第三遍纠正）</li><li>第三遍从第二遍的终点开始便历，即可以得到区间序列</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><a href="https://blog.csdn.net/shenlan211314/article/details/6312228" target="_blank" rel="external">参考链接</a></p><p>实例：无向图G=(V, E)，V为图的所有顶点集合（非空），E为图的所有边的集合。</p><ul><li><p>子图：G’=(V’, E’)，V’被包含于V，E’被包含于E，G’为G的子图。</p></li><li><p>生成子图：在子图中，E’&lt;=E且V’&lt;=V；在生成子图中，E’&lt;=E,且V’=V</p></li><li><p>诱导子图（induced graph）</p><p>G’=(V’, E’)，V’被包含于V，E’={(u, v)|u, v属于V’，(u, v)属于E}，G’为G的诱导子图。</p><p><strong>注意：对于V’，只要在G中有边，那么在G’中同样应该有边。</strong></p></li><li><p>团（clique）</p><p>G’为关于<strong>V’</strong>的<em>完全图</em>。</p><p>一个团为极大团（maximal clique）当且仅当它不是其它团的子图。</p></li></ul><p>　　一个图为最大团（maximum clique）当且仅当它的点集模最大。</p><p>　　一个图的团数表示为ω(G)。</p><ul><li><p>弦图(chordal graph)</p><p>一个无向图称为弦图当图中任意长度大于3的环都至少有一个弦。</p></li><li><p>单纯点（simplicial vertex）</p><p>设N(v)表示与点v相邻的点集。一个点称为单纯点当<strong>{v}+N(v)的诱导子图为一个团</strong>。</p><p><strong>定理</strong></p><p>任何一个弦图都至少有一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点(simplicail point)。</p></li><li><p>完美消除序列（perfect elimination ordering）</p><p>一个点的序列（每个点出现且恰好出现一次）v[1], v[2], …, v[n]满足v[i]在{v[i], v[i+1], …, v[n]}的诱导子图中为一个单纯点</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;the-difference-between-‘Nature’-and-‘Science’&quot;&gt;&lt;a href=&quot;#the-difference-between-‘Nature’-and-‘Science’&quot; class=&quot;headerlink&quot; title=&quot;th
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="组会" scheme="http://blog.huhaobin.cn/tags/%E7%BB%84%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>从C到C++</title>
    <link href="http://blog.huhaobin.cn/2019/04/22/fromCtoC++/"/>
    <id>http://blog.huhaobin.cn/2019/04/22/fromCtoC++/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-24T06:16:05.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><p>定义引用时一定要将其<strong>初始化</strong>为引用某个变量</p></li><li><p>初始化后，他就一直引用这个变量，不会再引用到别的变量（后面相当于给引用的变量赋值）</p></li><li><p>只能引用变量，不能引用常量和表达式</p></li><li><p>引用的用法</p><ul><li><p>用作形参类型，改变实参的值</p></li><li><p>用作函数返回值类型，可以将函数放在等式左边（相当于给return的那个变量进行赋值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</div><div class="line"><span class="function"><span class="keyword">int</span> &amp; <span class="title">SetValue</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> n;&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">SetValue() = <span class="number">40</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; n;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// print 40</span></div></pre></td></tr></table></figure></li><li><p>常引用：不能<em>通过</em>常引用去修改其引用的内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; r = n;</div><div class="line">r = <span class="number">200</span>; <span class="comment">//编译错误</span></div><div class="line">n = <span class="number">200</span>； <span class="comment">// OK</span></div></pre></td></tr></table></figure></li></ul></li></ol><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ol><li>定义常量（区别与define就是有类型，可以进行类型检查，<strong>建议多使用const</strong>）</li><li>定义常量指针(不能<em>通过</em>常量指针去修改其指向的内容）<ul><li>常量指针可以只想别的内容</li><li>不能把常量指针赋值给非常量指针，反过来可以</li><li>形参为常量指针时，可避免函数内部不小心改变指针所指地方的内容</li></ul></li><li>定义常引用</li></ol><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>用法</p><ol><li><p>分配一个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">P = new T;</div><div class="line">// T 是任意类型名，P是类型为T * 的指针，指向sizeof（T）存储空间的起始地址</div></pre></td></tr></table></figure></li><li><p>分配一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = new T[N];</div><div class="line">// 分配一个类型为T的N个分组，返回T *</div></pre></td></tr></table></figure></li></ol><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ol><li><p>一个类可以有多个构造函数，对象生成时自动调用构造函数；对象一旦生成就不能在其上执行构造函数</p></li><li><p>构造函数执行必要的初始化工作</p></li><li><p>每个类至少有一个构造函数（若无显示声明，则编译器自动生成一个无参无内容的构造函数），当没有任何构造函数时，编译器才会生成无参构造函数</p></li><li><p>无参构造函数不一定有</p></li><li><p>构造函数没有返回值类型，但是可以重载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ElemType T = new ElemType(1);// 对象变量的初始化</div><div class="line">ElemType S = new ElemType[3] = &#123;1,2&#125;;// 对象变量数组的初始化</div><div class="line">// S的分配过程中S[0], s[1]调用有参的构造函数，s[2]调用无参的构造函数</div></pre></td></tr></table></figure></li></ol><ol><li><p><strong>所有</strong>的构造函数都与类同名</p></li><li><p>构造函数<strong>不负责分配对象空间</strong>, 在分配空间之后才调用构造函数</p></li></ol><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><ol><li>只有一个参数，即对同类对象的<strong>引用</strong>，可以是常引用，eg, X::X(const X &amp;)；也可以是非常引用，eg, X::X( X &amp;)。 </li><li>若没有定义复制构造函数，则编译器会生成一个默认的复制构造函数来完成复制功能</li><li>复制构造函数有且仅有一个</li><li>起作用的时机<ol><li>当用一个对象去初始化同类的另一个对象</li><li>如果某函数有一个参数是类A的对象，那么该函数被调用时，类A的复制构造函数将被调用<ul><li>若复制构造函数重写为不复制或者不复制全部属性，则实参和形参内容可能不同</li></ul></li><li>如果某函数的返回值是类A的对象，那么该函数返回时，类A的复制构造函数将被调用</li></ol></li><li>对象间的赋值不会调用复制构造函数</li><li>复制构造函数在形参为对象的时候会被调用，因此浪费了一部分时间，所以可以考虑使用<strong>const CMyClass &amp; 引用类型</strong>作为参数，不用调用复制构造函数</li></ol><h3 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h3><ol><li>只有一个形参但不是复制构造函数的函数</li><li>当有需要的时候，编译器会自动调用生成一个临时的对象</li></ol><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><ol><li><p>与类同名，并在前面加<strong>‘ ~ ‘</strong>，没有参数和返回值，一个类只能有一个析构函数</p></li><li><p>在对象消亡时自动被调用，可以用来做善后工作，若没有显示定义析构函数，则编译器生成一个什么都不做的析构函数</p></li><li><p>对象数组的生命期结束时，对象数组的每个元素的析构函数都会被调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class CMyClass&#123;</div><div class="line">public:</div><div class="line">~CMyClass()&#123; cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; </div><div class="line">&#125;;</div><div class="line">CMyClass obj;</div><div class="line">CMyClass fun(CMyClass sobj)&#123;// 形参消亡时会导致析构函数被调用</div><div class="line">return sobj;// 函数返回时生成临时对象返回</div><div class="line">&#125;</div><div class="line">int main()&#123;</div><div class="line">obj = fun(obj);// 函数调用的返回值（临时对象）被用过之后，该临时对象的析构函数被调用</div><div class="line">return 0;</div><div class="line">&#125;//程序执行结束obj的析构函数被调用</div><div class="line"></div><div class="line">// OUTPUT：</div><div class="line">// destructor</div><div class="line">// destructor</div><div class="line">// destructor</div></pre></td></tr></table></figure></li><li><p>析构函数<strong>不负责回收对象空间</strong>, 在调用析构函数之后系统才会回收对象空间</p></li></ol><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>重载是函数名相同，参数个数或者类型不同的函数。参数相同，名字相同的返回值不同的则是重复定义</li><li>C++中定义函数的时候可以让最右边连续若干个参数有默认值</li><li>类的对象所占用的内存空间的大小等于所有成员变量的大小之和 </li><li>全局对象在main之前被初始化</li><li>静态局部变量在执行到这一句的时候被构造，在整个程序结束之后被析构</li><li>析构顺序一般遵循“先构造的后消亡”</li><li>new出来的东西只有delete才会消亡，<strong>不delete的话哪怕程序结束也不会消亡</strong></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义引用时一定要将其&lt;strong&gt;初始化&lt;/strong&gt;为引用某个变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化后，他
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://blog.huhaobin.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MAX30102文档</title>
    <link href="http://blog.huhaobin.cn/2019/04/16/MAX30102/"/>
    <id>http://blog.huhaobin.cn/2019/04/16/MAX30102/</id>
    <published>2019-04-16T13:56:20.000Z</published>
    <updated>2019-04-17T01:45:37.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中断状态寄存器"><a href="#中断状态寄存器" class="headerlink" title="中断状态寄存器"></a>中断状态寄存器</h2><p><img src="/image/max30102-1.png" alt="img"></p><p>无论何时触发中断，MAX30102都会将低电平有效的中断引脚拉至低电平状态，直到中断被清除。</p><p><strong>A_FULL: FIFO满标志</strong></p><p>在SpO 2和HR模式下，当FIFO写指针剩余一定数量的空闲空间时，该中断触发。</p><p>触发号可以由FIFO_A_FULL [3：0]寄存器设置。 通过读取中断状态1寄存器（0x00）清除中断。</p><p><strong>PPG_RDY：新的FIFO数据就绪</strong></p><p>在SpO 2和HR模式下，当数据FIFO中有新样本时，此中断将触发。通过读取中断状态1寄存器（0x00）或读取FIFO_DATA寄存器来清除中断。</p><p><strong>ALC_OVF：环境光消除溢出(置位时说明硬件校正失败)</strong></p><p>当SpO 2 / HR光电二极管的环境光消除功能达到其最大限制时，该中断触发，因此，环境光影响ADC的输出。通过读取中断状态1寄存器（0x00）清除中断。</p><p><strong>PWR_RDY：电源就绪标志</strong></p><p>在上电或欠压情况下，当电源电压VDD从欠压锁定（UVLO）电压低于UVLO电压时，电源就绪中断被触发，表示模块已上电并准备好收集数据。</p><p><strong>DIE_TEMP_RDY：内部温度就绪标志</strong></p><p>内部芯片温度转换完成后，将触发此中断，以便处理器可以读取温度数据寄存器。通过读取中断状态2寄存器（0x01）或TFRAC寄存器（0x20）来清除中断。</p><h2 id="中断允许寄存器"><a href="#中断允许寄存器" class="headerlink" title="中断允许寄存器"></a>中断允许寄存器</h2><p>​    保留位应该设置为0</p><h2 id="FIFO数据寄存器"><a href="#FIFO数据寄存器" class="headerlink" title="FIFO数据寄存器"></a><strong>FIFO数据寄存器</strong></h2><p>FIFO深度为32，最多可容纳32个数据样本。样本大小<strong>取决</strong>于配置为活动的LED通道（a.k.a.通道）的数量。由于每个通道信号存储为3字节数据信号，因此FIFO宽度可以是3个字节或6个字节。</p><p>I 2 C寄存器映射中的FIFO_DATA寄存器指向要从FIFO读取的下一个样本。 FIFO_RD_PTR指向此示例。读FIFO_DATA寄存器不会自动递增I 2 C寄存器地址。突发读取该寄存器，一遍又一遍地读取相同的地址。每个样本是每个通道3个字节的数据（即，RED为3个字节，IR为3个字节等）。</p><p>FIFO寄存器（0x04-0x07）都可以写入和读取，但实际上<strong>只应写入FIFO_RD_PTR寄存器</strong>。其他数据由MAX30102自动递增或填充数据。当开始新的SpO 2或心率转换时，建议<strong>首先将FIFO_WR_PTR，OVF_COUNTER和FIFO_RD_PTR寄存器清零为全零</strong>（0x00），以确保FIFO为空并处于已知状态。在一次突发读取I 2 C事务中读取MAX30102寄存器时，寄存器地址指针通常会递增，以便发送的下一个数据字节来自下一个寄存器，等等。例外情况是FIFO数据寄存器寄存器0x07。读取该寄存器时，地址指针不会递增，但FIFO_RD_PTR会递增。因此，发送的下一个数据字节表示FIFO中可用的下一个数据字节</p><p><strong>从FIFO读取</strong></p><p>通常，从I 2 C接口读取寄存器会自动增加寄存器地址指针，因此可以在没有I 2 C启动事件的情况下以突发读取方式读取所有寄存器。 在MAX30102中，除FIFO_DATA寄存器（寄存器0x07）外，所有寄存器都适用。</p><p>读FIFO_DATA寄存器不会自动递增寄存器地址。一遍又一遍地读取该寄存器取来的都是同一地址的数据。 每个样本包含多个字节的数据，因此应从该寄存器（在同一事务中）读取多个字节以获得一个完整样本。</p><p>另一个例外是0xFF。 在0xFF寄存器之后读取更多字节不会使地址指针返回到0x00，并且读取的数据没有意义。</p><p><strong>FIFO数据结构</strong></p><p>数据FIFO由32个样本存储器组组成，可存储IR和RED ADC数据。 由于每个样本由两个通道的数据组成，每个样本有6个字节的数据，因此可以在FIFO中可以存储192个总字节数据。</p><p>FIFO如表1所示进行数据左对齐; 换句话说，无论ADC分辨率设置如何，<em>MSB位始终位于第17位数据位置</em>。 有关FIFO数据结构的直观表示，请参见表2。</p><p><strong>FIFO数据每通道包含3个字节</strong></p><p>FIFO数据是左对齐的，这意味着无论ADC分辨率设置如何，MSB始终位于相同的位置。 FIFO DATA [18]  -  [23]保留。 表2显示了每个三字节字节的结构（包含每个通道的18位ADC数据输出）。</p><p>SpO 2模式下的每个数据样本包含两个数据三元组（每个3个字节）。要读取一个样本，每个字节需要一个I 2 C读取命令。 因此，要在SpO 2模式下读取一个样本，需要6 I 2 C字节读取。 在读取每个样本的第一个字节后，FIFO读指针自动递增。</p><p><strong>写/读指针</strong></p><p>写/读指针用于控制FIFO中的数据流。 每次将新样本添加到FIFO时，写指针都会递增。 每次从FIFO读取样本时，读指针都会递增。 要重新读取FIFO中的样本，请将其值减1并再次读取数据寄存器。</p><p>进入SpO 2模式或HR模式时，应将FIFO写/读指针清零（返回0x00），以便FIFO中不存在旧数据。 如果V DD重新上电或V DD降至低于其UVLO电压，则指针自动清零。</p><p><strong>从FIFO读取数据的伪代码示例</strong></p><p>第一个事务：获取FIFO_WR_PTR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">START;</div><div class="line">Send device address + write mode</div><div class="line">Send address of FIFO_WR_PTR;</div><div class="line">REPEATED_START;</div><div class="line">Send device address + read mode</div><div class="line">Read FIFO_WR_PTR;</div><div class="line">STOP;</div></pre></td></tr></table></figure><p>中央处理器评估要从FIFO读取的样本数：</p><p><strong>NUM_AVAILABLE_SAMPLES</strong> = FIFO_WR_PTR – FIFO_RD_PTR</p><p>(Note: pointer wrap around should be taken into account)</p><p>NUM_SAMPLES_TO_READ = &lt; less than or equal to NUM_AVAILABLE_SAMPLES &gt;</p><p>第二个实务: 从FIFO中读取 NUM_SAMPLES_TO_READ 个样本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">START;</div><div class="line">Send device address + write mode</div><div class="line">Send address of FIFO_DATA;</div><div class="line">REPEATED_START;</div><div class="line">Send device address + read mode</div><div class="line">for (i = 0; i &lt; NUM_SAMPLES_TO_READ; i++) &#123;</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED1[23:16];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED1[15:8];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED1[7:0];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED2[23:16];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED2[15:8];</div><div class="line">    Read FIFO_DATA;</div><div class="line">    Save LED2[7:0];</div><div class="line">    Read FIFO_DATA;</div><div class="line">&#125;</div><div class="line">STOP;</div><div class="line">START;</div><div class="line">Send device address + write mode</div><div class="line">Send address of FIFO_RD_PTR;</div><div class="line">Write FIFO_RD_PTR;</div><div class="line">STOP;</div></pre></td></tr></table></figure><p>第三个事务：</p><p>写入FIFO_RD_PTR寄存器。 <strong>如果</strong>第二个事务成功，则FIFO_RD_PTR指向FIFO中的下一个样本，并且不需要第三个事务。 <strong>否则</strong>，<strong>处理器适当地更新</strong>FIFO_RD_PTR，以便重新读取样本。</p><p><strong>FIFO 配置(0x08)</strong></p><p><strong>位 7:5: 样本均值化 (SMP_AVE)</strong></p><p>为了减少数据吞吐量，可以通过设置该寄存器在芯片上对相邻样本（在每个单独的通道中）进行平均和抽取。</p><p><img src="/image/max30102-2.png" alt="img"></p><p><strong>位4: FIFO满时循环(FIFO_ROLLOVER_EN)</strong></p><p>当FIFO完全填满数据时，该位控制FIFO的行为。 如果FIFO_ROLLOVER_EN设置为（1），则FIFO地址将从0开始，FIFO将继续填充新数据。 如果该位未置位（0），则在读取FIFO_DATA或更改WRITE / READ指针位置之前，FIFO不会更新。</p><p><strong>位3：0：FIFO几乎满值（FIFO_A_FULL）</strong></p><p>该寄存器设置发出中断时FIFO中剩余的数据样本数（3个字节/样本）。 例如，如果此字段设置为0x0，则在FIFO中剩余0个数据样本时发出中断（所有32个FIFO字都有未读数据）。 此外，如果此字段设置为0xF，则在FIFO中剩余15个数据样本时发出中断（17个FIFO数据样本具有未读数据）。</p><p><strong>SpO 2 配置 (0x0A)</strong></p><p><strong>Bits 6:5: SpO 2 ADC量程控制</strong></p><p>该寄存器设置SpO 2传感器ADC的满量程范围，如表5所示。</p><p><strong>比特4：2：SpO 2采样率控制</strong></p><p>这些位定义了有效采样率，其中一个样本由一个IR脉冲/转换和一个红色脉冲/转换组成。</p><p>采样率和脉冲宽度是相关的，因为采样率设置脉冲宽度时间的上限。 如果用户选择的采样率对于所选的LED_PW设置来说太高，则可能的最高采样率被编程到寄存器中。</p><p><strong>位1：0：LED脉冲宽度控制和ADC分辨率</strong></p><p>这些位设置LED脉冲宽度（IR和RED具有相同的脉冲宽度），因此间接设置每个样本中ADC的积分时间。 ADC分辨率与积分时间直接相关。</p><h2 id="采样率和性能"><a href="#采样率和性能" class="headerlink" title="采样率和性能"></a>采样率和性能</h2><p>ADC的最大采样速率取决于所选的脉冲宽度，进而决定了ADC的分辨率。 例如，如果脉冲宽度设置为69μs，那么ADC分辨率为15位，并且所有采样率都是可选的。 但是，如果脉冲宽度设置为411μs，则采样率受限。 表11和表12总结了SpO 2和HR模式的允许采样率。</p><p>在<strong>心率模式</strong>下，仅红色LED用于捕获光学数据并确定用户的心率和/或光电容积描记图（PPG）。</p><h2 id="SpO-2温度补偿"><a href="#SpO-2温度补偿" class="headerlink" title="SpO 2温度补偿"></a>SpO 2温度补偿</h2><p>MAX30102具有精确的板载温度传感器，可根据I 2 C主机的命令数字化IC的内部温度。 温度对红色和红外LED的波长有影响。 虽然器件输出数据对IR LED的波长相对不敏感，但红色LED的波长对于正确解释数据至关重要。</p><p>表13显示了红色LED波长与LED温度的相关性。 由于LED管芯以非常短的热时间常数（几十微秒）加热，因此应根据LED的电流水平和IC的温度计算LED波长。 使用表13估算温度。</p><p>MAX30102具有2线I2C / SMBus兼容串行接口，包括串行数据线（SDA）和串行时钟线（SCL）。 SDA和SCL有助于MAX30102与主机之间的通信，时钟速率高达400kHz。 图1显示了2线接口时序图。 主机生成SCL并在总线上启动数据传输。 主器件通过发送正确的从地址和数据将数据写入MAX30102。 每个发送序列由START（S）或REPEATED START（Sr）条件和STOP（P）条件构成。 传输到MAX30102的每个字长为8位，后跟一个应答时钟脉冲。 来自MAX30102的主机读数据传输正确的从机地址，然后发送一系列9个SCL脉冲。</p><p>MAX30102与主机产生的SCL脉冲同步在SDA上传输数据。 主设备确认收到每个数据字节。 每个读取序列由START（S）或REPEATED START（Sr）条件，非应答和STOP（P）条件构成。 SDA既可作为输入，也可作为漏极开路输出。 SDA需要一个上拉电阻，通常大于500Ω。 SCL仅作为输入操作。 如果总线上有多个主机，或者单个主机具有漏极开路SCL输出，则SCL上需要一个上拉电阻，通常大于500Ω。 符合SDA和SCL的串联电阻是可选的。 串联电阻可保护MAX30102的数字输入免受总线上的高压尖峰影响，并最大限度地降低总线信号的串扰和下冲。</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>在每个SCL周期期间传输一个数据位。 SDA上的数据必须在SCL脉冲的高电平期间保持稳定。 SCL高时SDA的变化是控制信号。 请参阅START和STOP条件部分。</p><p><strong>启动和停止条件</strong></p><p>当总线不使用时，SDA和SCL空闲。 主设备通过发出START条件来启动通信。 START条件是SCL为高电平时SDA从高到低的转换。 STOP条件是SCL为高电平时SDA从低到高的转换（图7）。 来自主设备的START条件表示传输到设备的开始。 主设备终止传输，并通过发出STOP条件释放总线。 如果生成REPEATED START条件而不是STOP条件，则总线保持活动状态。</p><p><strong>早期停止条件</strong></p><p>MAX30102在数据传输期间的任何时刻都能识别出STOP条件，除非STOP条件出现在与START条件相同的高脉冲中。 为了正常工作，请勿在与START条件相同的SCL高电平脉冲期间发送STOP条件。</p><p><strong>从机地址</strong></p><p>总线主控器通过发出START条件后跟7位从机ID启动与从机设备的通信。空闲时，MAX30102等待START条件后跟从机ID的控制序列。串行接口逐位比较每个从站ID，如果检测到错误的从站ID，则允许接口断电并立即断开与SCL的连接。识别出START条件后跟正确的从机ID序列后，MAX30102被根据ID字的LSB是读还是写（R / W）编程为接受或发送数据。 R / W表示主机是写入还是从MAX30102读取数据（R / W = 0选择写入条件，R / W = 1选择读取条件）。接收到正确的从机ID后，MAX30102通过将SDA拉低一个时钟周期发出<strong>ACK</strong>。 MAX30102从机ID由7个固定位B7-B1（设置为0b1010111）组成。首先发送最重要的从ID位（B7），然后发送剩余的位。表17显示了设备的可能的从ID。</p><p><strong>应答位</strong></p><p>应答位（ACK）是MAX30102在时钟的第9位在写入模式下用于握手接收每个数据字节（图8）。 如果成功接收到前一个字节，MAX30102会在整个主机产生的第9个时钟脉冲期间拉低<strong>SDA</strong>。 监测ACK可以检测失败的数据传输。 如果接收设备繁忙或发生系统故障，则会发生不成功的数据传输。 如果数据传输失败，总线主机将重试通信。 当MAX30102处于<strong>读模式</strong>时，主器件在第9个时钟周期内<strong>拉低SDA</strong>以确认接收数据。 在每个读取字节之后，主机发送应答以允许数据传输继续。 当主机从MAX30102读取数据的最后一个字节，然后是STOP条件时，发送一个未应答。</p><p><strong>写操作</strong></p><p>对于写操作，将从ID作为第一个字节，然后是寄存器地址字节，然后是一个或多个数据字节。 寄存器地址指针在接收到的每个数据字节后自动递增，因此例如可以一次写入整个寄存器库。 使用STOP条件终止数据传输。 写操作如图9所示。</p><p>内部寄存器地址指针自动递增，因此写入附加数据字节按顺序填充数据寄存器。</p><p><img src="/image/max30102-3.png" alt="img"></p><p><strong>读数据格式</strong></p><p>对于读操作，必须执行<strong>两次I 2 C</strong>操作。首先，发送从机地址，然后发送您想要读取的I 2 C寄存器的ID。然后发送REPEAT START（Sr）条件，然后发送读取从机ID。然后，MAX30102开始从第一个操作中选择的寄存器中发送数据。读指针自动递增，因此器件继续按顺序从其他寄存器发送数据，直到收到STOP（P）条件。例外情况是<strong>FIFO_DATA</strong>寄存器，读取指针在读取其他字节时不再递增。要在FIFO_DATA之后读取下一个寄存器，<em>需要I 2 C写命令来更改读指针的位置</em>。图10和图11显示了读取一个字节和多个字节数据的过程。需要进行初始写操作发送读取寄存器地址。从初始I 2 C写操作中选择的寄存器开始，按顺序从寄存器发送数据。如果读取FIFO_DATA寄存器，则读指针不会自动递增，后续的数据字节将包含FIFO的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;中断状态寄存器&quot;&gt;&lt;a href=&quot;#中断状态寄存器&quot; class=&quot;headerlink&quot; title=&quot;中断状态寄存器&quot;&gt;&lt;/a&gt;中断状态寄存器&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/image/max30102-1.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="硬件" scheme="http://blog.huhaobin.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="毕业设计" scheme="http://blog.huhaobin.cn/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu装机</title>
    <link href="http://blog.huhaobin.cn/2019/04/16/zhuangji/"/>
    <id>http://blog.huhaobin.cn/2019/04/16/zhuangji/</id>
    <published>2019-04-16T07:00:00.000Z</published>
    <updated>2019-04-18T03:21:34.110Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Ubuntu安装之新建autoinstall.sh <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim autoinstall.sh</div></pre></td></tr></table></figure></li></ol><p>2.<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">将下列内容写入</div><div class="line">apt install vim</div><div class="line">## theme</div><div class="line">add-apt-repository ppa:noobslab/themes</div><div class="line">apt update</div><div class="line">apt install flatabulous-theme</div><div class="line">## icons</div><div class="line">add-apt-repository ppa:noobslab/icons</div><div class="line">apt update</div><div class="line">apt install ultra-flat-icons</div><div class="line">## pointer</div><div class="line">add-apt-repository ppa:noobslab/macbuntu</div><div class="line">apt update</div><div class="line">apt install macbuntu-os-icons-lts-v7</div><div class="line">apt install macbuntu-os-ithemes-lts-v7</div><div class="line">## fonts</div><div class="line">apt install fonts-wqy-microhei</div><div class="line">##</div><div class="line">apt install unity-tweak-tool</div><div class="line">## docky</div><div class="line">apt install cairo-dock</div><div class="line"></div><div class="line">##</div><div class="line">apt install git</div><div class="line">## python</div><div class="line">apt install python-pip</div><div class="line">pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U</div><div class="line"></div><div class="line">## hexo</div><div class="line">apt install npm</div><div class="line">npm install -g hexo-cli</div><div class="line"></div><div class="line">## network</div><div class="line">apt install --reinstall linux-firmware</div><div class="line">modprobe -r iwlwifi</div><div class="line">modprobe iwlwifi</div></pre></td></tr></table></figure></p><ol><li><p>自动安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ./autoinstall.sh</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Ubuntu安装之新建autoinstall.sh &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu搭建交叉编译环境</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/ubuntu-arm/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/ubuntu-arm/</id>
    <published>2019-04-15T06:27:43.805Z</published>
    <updated>2017-09-30T08:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>1.<em>*</em> mixed implicit and normal rules: deprecated syntax<br>  修改Makefile 452 修改后：<br>  %config: scripts_basic outputmakefile FORCE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.&lt;em&gt;*&lt;/em&gt; mixed implicit and normal rules: deprecated syntax&lt;br&gt;  修改Makefile 452 修改后：&lt;br&gt;  %config: scripts_basic outputmakefile FORCE
      
    
    </summary>
    
      <category term="未分类" scheme="http://blog.huhaobin.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="交叉编译" scheme="http://blog.huhaobin.cn/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>qt画图</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/qtPainting/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/qtPainting/</id>
    <published>2019-04-15T06:27:43.737Z</published>
    <updated>2018-04-21T06:15:31.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QcustomPlot"><a href="#QcustomPlot" class="headerlink" title="QcustomPlot"></a>QcustomPlot</h2><ol><li><p>下载</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.qcustomplot.com</div></pre></td></tr></table></figure></li><li><p>把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可</p></li><li>pro文件中QT += widgets printsupport</li><li><p>使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">QVector x(101), y(101); // initialize with entries 0..100</div><div class="line">for (int i=0; i&lt;101; ++i)</div><div class="line">&#123;</div><div class="line">x[i] = i/50.0 – 1; // x goes from -1 to 1</div><div class="line">y[i] = x[i]*x[i]; // let’s plot a quadratic function</div><div class="line">&#125;</div><div class="line">qDebug()&lt;&lt;“data has been created”;</div><div class="line">ui-&gt;black_line-&gt;addGraph();</div><div class="line">qDebug()&lt;&lt;“begin painting”;</div><div class="line">ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);</div><div class="line">ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);</div><div class="line">ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);</div><div class="line">ui-&gt;black_line-&gt;replot();</div><div class="line">qDebug()&lt;&lt;“finish”;</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;QcustomPlot&quot;&gt;&lt;a href=&quot;#QcustomPlot&quot; class=&quot;headerlink&quot; title=&quot;QcustomPlot&quot;&gt;&lt;/a&gt;QcustomPlot&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载&lt;/p&gt;
 &lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Qt" scheme="http://blog.huhaobin.cn/categories/Qt/"/>
    
    
      <category term="上位机 Qt" scheme="http://blog.huhaobin.cn/tags/%E4%B8%8A%E4%BD%8D%E6%9C%BA-Qt/"/>
    
  </entry>
  
  <entry>
    <title>新博客站的第一篇文章</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/about/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/about/</id>
    <published>2019-04-15T06:27:43.717Z</published>
    <updated>2017-09-30T08:48:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="百废待兴"><a href="#百废待兴" class="headerlink" title="百废待兴"></a>百废待兴</h2><p>自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本</p><h2 id="移花接木"><a href="#移花接木" class="headerlink" title="移花接木"></a>移花接木</h2><p>虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺.</p><h2 id="后悔莫及"><a href="#后悔莫及" class="headerlink" title="后悔莫及"></a>后悔莫及</h2><p>前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞</p><h3 id="有时间继续更新"><a href="#有时间继续更新" class="headerlink" title="有时间继续更新"></a>有时间继续更新</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;百废待兴&quot;&gt;&lt;a href=&quot;#百废待兴&quot; class=&quot;headerlink&quot; title=&quot;百废待兴&quot;&gt;&lt;/a&gt;百废待兴&lt;/h2&gt;&lt;p&gt;自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名
      
    
    </summary>
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/categories/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
    
      <category term="肺腑之言" scheme="http://blog.huhaobin.cn/tags/%E8%82%BA%E8%85%91%E4%B9%8B%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>集成库的学习</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/lib_int/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/lib_int/</id>
    <published>2019-04-15T06:27:43.689Z</published>
    <updated>2017-09-30T08:49:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误</p><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ol><li><p>在PCB library和SCH library里面可以更改器件的名字</p></li><li><p>在model manager里面进行原理图元器件和PCB元器件的映射</p></li><li><p>board insight提供了PCB图观察的各种视图</p></li><li><p>同时布多条线，放置—–交互式多跟布线</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;p&gt;个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="硬件" scheme="http://blog.huhaobin.cn/categories/%E7%A1%AC%E4%BB%B6/"/>
    
    
      <category term="AD" scheme="http://blog.huhaobin.cn/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/git/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/git/</id>
    <published>2019-04-15T06:27:43.689Z</published>
    <updated>2017-09-28T15:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">git push origin 本地分支名:远程分支名</div><div class="line">git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;</div><div class="line"></div><div class="line">git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面加“*”号标记</div><div class="line">git checkout BRANCH_ID 切换分支</div><div class="line">git branch -r 列出远程分支</div><div class="line">git branch -a</div><div class="line">git branch name 新建分支</div><div class="line">git branch -d | -D branchname 删除branchname分支</div><div class="line">git branch -d -r branchname 删除远程branchname分支</div><div class="line"></div><div class="line">git <span class="built_in">log</span></div><div class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></div><div class="line">git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line">git diff --name-status OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE</div><div class="line"></div><div class="line">git checkout COMMIT_ID 版本回退</div><div class="line"></div><div class="line">git stash list 查看堆栈情况</div><div class="line">git stash 将当前工作压栈</div><div class="line">git stash pop stash<span class="variable">$&#123;id&#125;</span> 弹出工作栈</div><div class="line">git stash clear 清除栈</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ci  library</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/ci-library/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/ci-library/</id>
    <published>2019-04-15T06:27:43.621Z</published>
    <updated>2017-09-30T08:50:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>调用时库名必须全部小写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;调用时库名必须全部小写&lt;/p&gt;

      
    
    </summary>
    
      <category term="PHP" scheme="http://blog.huhaobin.cn/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言大坑</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/a_bigHole_ofC/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/a_bigHole_ofC/</id>
    <published>2019-04-15T06:27:43.601Z</published>
    <updated>2018-03-24T04:10:48.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接下来就开始看看坑"><a href="#接下来就开始看看坑" class="headerlink" title="接下来就开始看看坑"></a>接下来就开始看看坑</h2><ol><li><p>单引号表示表示整数值</p><ul><li>双引号表示字符串首的地址</li><li>以0开头的整数默认为八进制</li><li>注意使用移位运算加快程序执行速度</li><li>if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致</li><li>a[i] = i[a]</li><li>C语言的不对称边界</li><li>errno 外部出错变量，可以检测出错信息</li><li>break 跳出离他最近的那层循环或switch</li><li>C 语言不能省略形参，即使不使用</li></ul></li><li><p>C语言的数据存储空间</p><ul><li>程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）</li><li>局部变量在return之后出栈销毁，不要尝试返回局部指针地址</li><li>堆  申请、释放原则 <strong>哪儿申请哪儿释放</strong><br> 记得判断 堆 申请成功与否</li></ul></li><li><p>一个程序将操作系统分配给其运行的内存块分为4个区域：<br>　　(1)代码区，存放程序的代码，即程序中的各个函数代码块。<br>　　(2)全局数据区，存放程序的全局数据和静态数据。<br>　　(3)堆区，存放程序的动态数据。<br>　　(4)栈区，存放程序的局部数据，即各个函数中的数据。</p></li><li><p>强制类型转换</p></li></ol><ul><li>占用空间大的转化为占用空间小的： 考虑字节序（大小端），所使用的部分可能在不同机器上截然不同</li><li>占用空间小的转化为占用空间大的： 考虑内存越界访问</li><li>结构体强制转换             ： 考虑字节对齐</li></ul><ol><li>字符串</li></ol><ul><li>通过索引读取字符串时，一定要判断索引的正确性</li></ul><ol><li>多线程编程</li></ol><ul><li>互斥量用来对临界区的互斥进入</li><li>条件变量用于线程的阻塞等待</li></ul><ol><li><p>指针</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int * p = NULL;</div><div class="line"></div><div class="line">&amp;p 表示p的地址</div><div class="line">p 表示变量p的内容</div><div class="line">*p 表示p指向的存储单元的内容</div></pre></td></tr></table></figure><ul><li><strong>数字0是唯一能输给指针的数值</strong>(相当于NULL)  </li><li>void * :指向任何类型的指针</li><li><strong>注意深复制和浅复制的区别</strong><h2 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int *p, *q;</div><div class="line">*p = 58;</div><div class="line">q = p;        // q 和 P 指向同一内存单元</div><div class="line">free(q);</div><div class="line">printf(&quot;%d\n&quot;,p); //异常。p的内存已经被q释放</div></pre></td></tr></table></figure></li></ul></li><li><p>动态变量</p><p>在程序运行过程中产生的变量称为动态变量</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int * p; char *q;</div><div class="line">p = new int;  // 在内存中创建一个变量，存储所分配的内存地址到p中</div><div class="line">q = new char[19];   // 在内存中创建一个数组，并将数组地址存储到q中</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">*p = 28;</div><div class="line">*q = &quot;hello&quot;;</div></pre></td></tr></table></figure></li><li><p>销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete p;</div><div class="line">delete [] q;</div></pre></td></tr></table></figure></li></ul></li><li><p>动态数组</p><ul><li><p>创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int *p;</div><div class="line">p = new int[10];</div></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">* p = 25;   //25存到第一个存储空间里  = p[0] = 25；</div><div class="line">p ++;</div><div class="line">* p = 35;   //35存到第二个存储空间里  = p[1] = 35；</div></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;接下来就开始看看坑&quot;&gt;&lt;a href=&quot;#接下来就开始看看坑&quot; class=&quot;headerlink&quot; title=&quot;接下来就开始看看坑&quot;&gt;&lt;/a&gt;接下来就开始看看坑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;单引号表示表示整数值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双引号表示字符串首
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>socksV5转化为http代理</title>
    <link href="http://blog.huhaobin.cn/2019/04/15/sockstohttp/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/sockstohttp/</id>
    <published>2019-04-15T06:27:43.553Z</published>
    <updated>2018-07-06T11:52:07.801Z</updated>
    
    <content type="html"><![CDATA[<ol><li>使用工具  privoxy</li></ol><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install privoxy</div></pre></td></tr></table></figure></p><p>更改配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /etc/privoxy/config</div></pre></td></tr></table></figure></p><p>并在里面添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">forward-socks5   /               127.0.0.1:1080 .</div></pre></td></tr></table></figure></p><p>重启服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service privoxy restart</div></pre></td></tr></table></figure></p><p>给系统设置http代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ~/.bashrc</div></pre></td></tr></table></figure></p><p>添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export http_proxy=http://127.0.0.1:8118/</div></pre></td></tr></table></figure></p><p>使更改生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;使用工具  privoxy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安装&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre
      
    
    </summary>
    
      <category term="代理" scheme="http://blog.huhaobin.cn/categories/%E4%BB%A3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2019/04/15/UnistallPip/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/UnistallPip/</id>
    <published>2019-04-15T06:27:43.553Z</published>
    <updated>2018-06-19T03:53:09.789Z</updated>
    
    <content type="html"><![CDATA[<p>python -m pip uninstall pip</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python -m pip uninstall pip&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://blog.huhaobin.cn/2019/04/15/csu/"/>
    <id>http://blog.huhaobin.cn/2019/04/15/csu/</id>
    <published>2019-04-15T06:27:43.465Z</published>
    <updated>2018-03-04T05:31:56.863Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://123.206.64.174" target="_blank" rel="external">http://123.206.64.174</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://123.206.64.174&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://123.206.64.174&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络4</title>
    <link href="http://blog.huhaobin.cn/2019/04/12/computernetworking4/"/>
    <id>http://blog.huhaobin.cn/2019/04/12/computernetworking4/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-22T08:07:03.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><pre><code>1. 网络层（数据报--datagram）向传输层（数据段---segment）提供服务2. 端系统和路由器都运行网络层3. 核心功能: 转发和路由, 连接建立（有些网络不需要建立）       1. 网络层的链接是中间所有设备都参与的, **需要确立一条明确的路径**       2. 传输层的连接是只有通信双方参与的</code></pre><h2 id="网络层服务模型"><a href="#网络层服务模型" class="headerlink" title="网络层服务模型"></a>网络层服务模型</h2><ol><li>无连接服务<ol><li>不事先确定系列分组的传输路径</li><li>每个分组独立确定路径</li><li>不同的分组路径可能不同</li><li>eg：数据报网络</li></ol></li><li>连接服务<ol><li>首先为系列分组的传输确定从源到目的的路径</li><li>然后用该路径进行该系列分组的传输</li><li>传输结束后拆除连接</li><li>eg：虚电路网络（ATM网络）</li></ol></li></ol><h2 id="数据包网络"><a href="#数据包网络" class="headerlink" title="数据包网络"></a>数据包网络</h2><ol><li>特征<ul><li>网络层无连接</li><li>每个分组携带目的地址</li><li>路由器根据分组的目的地址（范围）进行转发分组（internet）<ul><li>基于路由协议/算法构建转发表</li><li>检索转发表</li><li>每个分组独立选路</li></ul></li></ul></li><li>转发原则<ul><li>最长前缀匹配优先（优先选择与分组目的地址匹配前缀最长的入口）</li></ul></li></ol><h4 id="简化网络，复杂“边缘”"><a href="#简化网络，复杂“边缘”" class="headerlink" title="简化网络，复杂“边缘”"></a>简化网络，复杂“边缘”</h4><h2 id="internet网络层"><a href="#internet网络层" class="headerlink" title="internet网络层"></a>internet网络层</h2><p><img src="/image/internetNetworking.png" alt="网络层示意"></p><ol><li><p>网络链路层存在最大传输单元（MTU）——链路层数据帧可封装数据的上限</p><ol><li>不同链路的MTU不同</li><li>大ip分组向较小的MTU链路转发时<strong>可以</strong>被“分片”， 若相关标志位(DF)不允许分片，则将起丢掉，并用ICMP回传控制信息</li><li>ip分片到达目的主机才进行组装（路由器只进行拆分，不组装）</li><li>若有分片后的数据收不到，则丢弃整个分组（MF标志位：最后一片或未分片）</li><li>ipv4 片偏移字段以8字节为单位</li></ol></li><li><p>ip编址（<strong>层次化编址</strong>）</p><ol><li><p>ip地址与每个<strong>接口</strong>相关联</p></li><li><p>主机域不能全0也不能全1(广播地址)</p></li><li><p>ip划分：某个组织的网络号（ip地址高位）相同，主机号不同</p></li><li><p>ip子网：ip地址具有相同网络号的设备<strong>接口</strong></p><p>不跨越路由器（第三及以上层网络设备）可以彼此物理联通的设备</p></li></ol></li><li><p>有类ip地址/有类编址</p><p><img src="/image/ipv4Sort.png" alt="ipv4分类"></p><ul><li>D类地址用作多播</li><li>E类保留做研究使用</li><li>A、B、C类也有部分地址不可以被分配</li></ul></li><li><p>ip子网的划分和子网掩码</p><ol><li>将ip地址划分为网络号（NetID），<em>子网号（SubID）</em>，和主机号（HostID）</li><li>子网掩码（用来确定是否分了子网和子网的大小）<ol><li>NetID，SubID全取1</li><li>HostID全取0</li></ol></li><li>子网划分中比不划分子网有更多的不能使用的地址</li></ol></li><li><p>无类域间路由(CIDR: classless InterDomain Routing)</p><ol><li><p>消除传统的A，B，C类地址界限</p><p>将网络号和子网号统称为网络前缀</p></li><li><p>融合子网地址和子网掩码</p><p>格式：a.b.c.d/x,  x为前缀的长度</p></li></ol></li><li><p>DHCP </p><ol><li><p>默认网关：若分组要送出/入该子网则应该先送给网关，再由网关进行转发</p></li><li><p>从服务器动态获取：</p><ol><li>ip地址</li><li>子网掩码</li><li>默认网管地址</li><li>DNS服务器名称和ip地址</li></ol></li><li><p>“即插即用”</p></li><li><p>允许地址重用，在用地址续租</p></li><li><p>允许移动用户加入网络</p></li><li><p>DHCP配置协议</p><ol><li>需要接入网络的主机广播”DHCP discover”（发现报文）</li><li>DHCP服务器（一个子网里面可能有多个也可能没有）利用“DHCP offer“（提供报文）进行响应</li><li>主机向回应offer的DHCP服务器请求ip地址：”DHCP request“（请求报文）</li><li>DHCP服务器分配ip地址:“DHCP ack”（确认报文）</li></ol></li><li><p>DHCP配置过程示例</p><p><img src="/image/DHCPExample.png" alt="DHCP"></p><ul><li>DHCP服务器端口67，客户机端口68</li><li>第一次，第二次数据传输进行广播是因为相互不清楚对方的ip</li><li>第三次数据传输进行广播是为了告诉其他DHCP服务器客户机已经分配了ip，免得占用其他资源</li></ul></li><li><p>DHCP在应用层实现，封装在UDP数据报中</p></li></ol></li><li><p>网络地址转换(NAT)</p><ol><li>实现步骤<ol><li>替换：利用（NAT IP地址，新端口号）替换每个外出IP数据报的（源IP地址，源端口号）</li><li>记录：将每对（NAT IP地址，新端口号）与（源IP地址，源端口号）的替换信息存储到NAT转换表中</li><li>替换：根据NAT转换表，利用（源IP地址，源端口号）替换每个进入内网IP数据报的（目的IP地址，目的端口号），即（NAT IP地址，新端口号）</li></ol></li><li>NAT穿透问题<ol><li>方法1：静态配置NAT，将特定端口的连接请求转发给服务器</li><li>方法2：利用UPnp（互联网网管设备协议）自动配置</li><li>方法3：中继（代理）<ol><li>NAT内部的客户与中继服务器建立连接</li><li>外部客户也与中继服务器建立连接</li><li>中继服务器桥接两个连接的分组</li></ol></li></ol></li></ol></li><li><p>互联网控制报文协议（ICMP）</p><ol><li>主要功能：支持主机或者路由器进行<strong>差错报告</strong>和<strong>网络探询</strong></li><li>两类ICMP报文：差错报告报文（5种）和网络探询报文（2组）</li><li>不发送ICMp差错报告报文的特殊情况<ul><li>对ICMp差错报告报文不再发送ICMP差错报告报文</li><li>除第一个ip数据报分片外，对所有后续分片均不发送ICMP差错报告报文</li><li>对所有多播ip数据报均不发送</li><li>对具有特殊IP的数据报不发送</li></ul></li><li>ICMP封装在IP数据报中传输</li></ol></li><li><p>IPv6</p><ol><li>IPv4相比的变化<ul><li>彻底移除首部的校验和字段，以减少每跳处理时间</li><li>选项（options）字段从基本首部移出，定义多个选项首部，通过“下一个首部”字段指示</li><li>ICMPv6<ul><li>附加报文类型</li><li>多播组管理功能</li></ul></li></ul></li><li></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;网络层&quot;&gt;&lt;a href=&quot;#网络层&quot; class=&quot;headerlink&quot; title=&quot;网络层&quot;&gt;&lt;/a&gt;网络层&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下firefox播放HTML5视频</title>
    <link href="http://blog.huhaobin.cn/2019/04/08/ubuntu_Firefox_play_HTML5_vedio/"/>
    <id>http://blog.huhaobin.cn/2019/04/08/ubuntu_Firefox_play_HTML5_vedio/</id>
    <published>2019-04-08T03:19:32.000Z</published>
    <updated>2019-04-11T11:41:21.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>chrome内存吃的太狠，渣笔记本带的很吃力，但是用中国大学mooc不能正常观看教学视频，报错不能正常播放视频[code:6]。</p><h2 id="缺少组件"><a href="#缺少组件" class="headerlink" title="缺少组件"></a>缺少组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install ubuntu-restricted-extras</div></pre></td></tr></table></figure><h2 id="ubuntu-restricted-extras"><a href="#ubuntu-restricted-extras" class="headerlink" title="ubuntu-restricted-extras"></a>ubuntu-restricted-extras</h2><p>通俗来说就是ubuntu下的一些支持库，他可以帮助改善MP3、vedio、DVD等的体验，也可以获得windows下的字体体验和FLASH之类的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缘起&quot;&gt;&lt;a href=&quot;#缘起&quot; class=&quot;headerlink&quot; title=&quot;缘起&quot;&gt;&lt;/a&gt;缘起&lt;/h2&gt;&lt;p&gt;chrome内存吃的太狠，渣笔记本带的很吃力，但是用中国大学mooc不能正常观看教学视频，报错不能正常播放视频[code:6]。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux, ubuntu" scheme="http://blog.huhaobin.cn/tags/linux-ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络3</title>
    <link href="http://blog.huhaobin.cn/2019/04/07/computernetworking3/"/>
    <id>http://blog.huhaobin.cn/2019/04/07/computernetworking3/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-16T02:25:57.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ol><li><p>为运行在不同的端系统上的<strong>进程</strong>提供了一种逻辑通信机制(网络层提供<strong>主机</strong>之间的逻辑通信机制)</p><ul><li>位于网络层之上</li><li>依赖于网络层</li><li>对网络层功能进行加强</li></ul></li><li><p>传输层提供的服务</p><ul><li>可靠的、按序的交付服务（TCP）<ul><li>流量控制</li><li>拥塞控制</li><li>连接建立</li></ul></li><li>不可靠的交付服务（UDP）<ul><li>复用/分用</li><li>简单的错误校验</li><li>尽力而为（best effort）</li><li>不需要建立链接，延迟很小</li><li>上层更好控制（不用顾及拥塞控制之类）</li><li>经常用于流媒体、DNS、SNMP等</li></ul></li><li>不提供延迟、带宽等方面的服务</li></ul></li><li><p>多路复用/分用</p></li></ol><h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><ol><li><p>不错、不丢、不乱</p></li><li><p>可靠数据传输协议</p></li><li><p>需要双向的控制信息流实现，上层单向流动到可靠协议，由可靠协议负责和不可靠的UDP双向交互实现可靠传输</p></li><li><p>协议实现（数据错误，位错误）</p><ul><li>有限状态机来刻画传输协议</li><li>确认机制（ACK: 确认; NAK：数据错误; 错误重传机制）— 接收方显式回传控制消息<ul><li>为ACK和NAK增加校验和</li><li>添加额外的控制消息</li><li>NAK/ACK 坏掉重传（产生重复传送的问题）</li><li>增加序列号进行NAK/ACK重传</li></ul></li><li>差错检测（校验和等）</li><li>停-等协议（有限状态机）</li><li>NAK可以在ACK确认消息的时候加入序列号代替（确认最后一个分组）</li></ul><p>5 . 协议实现（丢失分组）</p><ul><li>等待合理的一段时间之后重传（需要定时器）</li><li>停等引起效率低下</li><li>采用流水线机制（连发多个分组再等待ACK）</li><li>使用滑动窗口协议实现流水线</li></ul></li></ol><h2 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h2><h3 id="GBN（Go-Back-N）协议：一组分组一组分组的滑动"><a href="#GBN（Go-Back-N）协议：一组分组一组分组的滑动" class="headerlink" title="GBN（Go-Back-N）协议：一组分组一组分组的滑动"></a>GBN（Go-Back-N）协议：一组分组一组分组的滑动</h3><ol><li><p>发送方</p><ul><li><p>窗口尺寸为N，最多允许有N个分组未确认，分组头部包含K-bit序列号</p></li><li><p>采用累积确认的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ACK(n)表示确认到n(包含n)的分组均被正确接收</div></pre></td></tr></table></figure></li><li><p>整个窗口设置一个计时器</p></li><li><p>超时则重发序列号大于n还未收到ack的分组</p></li></ul></li><li><p>接收方（没有缓存，没有接收方窗口）</p><ul><li>发送拥有最高序列号的、已被正确接收的分组的ACK<ul><li>可能产生重复的ACK</li></ul></li><li>乱序到达的分组直接丢弃，重新确认正确收到的最大的序列号</li></ul></li></ol><h3 id="SR（selective-repeat-协议：一个分组一个分组的滑动"><a href="#SR（selective-repeat-协议：一个分组一个分组的滑动" class="headerlink" title="SR（selective repeat)协议：一个分组一个分组的滑动"></a>SR（selective repeat)协议：一个分组一个分组的滑动</h3><ol><li>接收方（设置缓冲机制，缓冲乱需到达的分组）<ol><li>添加接收方窗口</li><li>对每个分组单独确认</li></ol></li><li>发送方<ol><li>为每个分组设置单独的计数器</li></ol></li><li>窗口可以跳跃前移</li></ol><h2 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h2><ol><li><p>点对点（一个发送方，一个接收方）</p></li><li><p>可靠的按序的字节流</p></li><li><p>流水线机制（拥塞控制，流量控制，窗口大小设置）</p></li><li><p>发送方/接收方缓存</p></li><li><p>全双工（同一连接中能传输双向数据流）</p></li><li><p>面向连接</p><ol><li>通信双方在发送数据前必须建立连接</li><li>连接状态只在连接的两端维护，沿途 结点并不维护</li><li>TCP连接包括：两台主机上的缓存，连接状态变量、socket等</li></ol></li><li><p>流量控制机制</p></li><li><p>序列号是segment中第一个字节的编号，而不是segment的编号，建立TCP连接时双方随机选择序列号</p></li><li><p>ACKS</p><ol><li>累计确认机制：该序列号之前的所有字节已经被正确处理</li><li>返回是希望接收到的下一个字节的序列号</li></ol></li><li><p>可靠数据传输</p><ol><li>TCP在IP层提供不可靠的服务基础上实现可靠数据传输服务</li><li>使用单一重传定时器</li><li>触发重传的事件（超时，收到重复ACK）</li></ol></li><li><p>快速重传</p><p>​    由于接受断发回的ACK是希望接收到的字节的序列号，当连续收到三个相同的ACK时就执行快速重传而不用等超时再传</p></li><li><p>流量控制（速度匹配机制)</p><p>控制发送方发送速度不要过快以至于淹没接收方的buffer</p><p>receiver 在segment头部告诉sender还有多少buffer</p></li><li><p>多媒体应用通常不使用TCP，以免被拥塞控制机制限制速率</p></li></ol><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><ol><li>一般由TCP的发送端（客户机）请求建立连接，接收端等待客户连接请求</li><li>连接的三次握手<ol><li>客户机向服务器发送一个SYN段（没有数据，包含客户端初始选择的序列号）</li><li>服务器答复SYNACK（选择服务器的初始序列号，分配客户机缓存）</li><li>客户机收到SYNACK，回复ACK（可以包含数据）</li><li>建立TCP连接<strong>两次握手不能确定具体是否成功，四次握手会有资源浪费</strong></li></ol></li><li>关闭的四次握手<ol><li>客户机向服务器发送FIN报文段</li><li>服务器收到FIN，回复ACK，关闭连接，发送FIN</li><li>客户机收到FIN，回复ACK<ol><li>进入等待状态，如果收到FIN，则重新发送ACK</li></ol></li><li>服务器收到ACK，关闭链接</li></ol></li></ol><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><ol><li><p>表现</p><ol><li>分组丢失</li><li>分组延迟越来越大</li></ol><h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><ul><li>端到端的拥塞控制（端系统通过观察loss（分组丢失）delay（分组延迟时间等来判断网络是否发生拥塞—-TCP采用这种方法）</li><li>网络辅助的拥塞控制（路由器显式的向发送方反馈网络的用色信息，简单的拥塞指示（1 bit）：指示发送方该采取何种速率—-ATM）</li></ul><h3 id="拥塞控制的基本原理"><a href="#拥塞控制的基本原理" class="headerlink" title="拥塞控制的基本原理"></a>拥塞控制的基本原理</h3><ul><li><p>限制sender的发送速率</p></li><li><p>ConfgWin：（发送窗口的大小）</p><ul><li>动态调整以改变发送速率</li><li>反映所感知到的网络拥塞</li></ul></li><li><p>网络拥塞的感知</p><ul><li>LOSS事件==timeout或者连续3个重复的ACK</li></ul></li><li><p>合理调整发送速率</p><ul><li><p>加性增—乘性减（AIMD)</p><p>谨慎的探测可用带宽，逐渐增加发送速率，直到发生loss事件（每个RTT将CongWin增大一个MSS）;  发生loss之后已经拥塞，需要快速降低发送频率（将CongWin减半）</p></li><li><p>慢启动（SS）</p><p>当链接刚刚建立时（CongWin = 1,  初始速率20k），让CongWin指数增长; 每个RTT将CongWin翻倍–&gt;快速攀升</p></li><li><p>指数增长切换到加性增</p><p>用一个变量Threshold， 设置为LOSS事件前congWin值的1/2.</p><p><img src="/image/loss_event.jpg" alt="loss event"></p><ul><li><p>收到3个重复的ACK(网络还能传输一些segment)</p><p>将congWin切为一半，然后线性增长</p></li><li><p>Timeout事件（<strong>拥塞更严重</strong>)</p><p>CongWin直接设为1,然后指数增长，达到threshold之后再线性增长</p></li></ul></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为运行在不同的端系统上的&lt;strong&gt;进程&lt;/strong&gt;提供了一种逻辑通信机制(网络层提供&lt;strong&gt;主
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络2</title>
    <link href="http://blog.huhaobin.cn/2019/04/07/computernetworking2/"/>
    <id>http://blog.huhaobin.cn/2019/04/07/computernetworking2/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-16T02:37:17.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ol><li>网络应用的体系结构<ul><li>客户机/服务器（c/s）</li><li>peer to peer (点对点结构)</li><li>混合结构</li></ul></li><li>TCP/UDP区别<br> <img src="/image/udp_tcp.jpg" alt="tcp/udp"></li><li>HTTP<ul><li>采用无状态的机制（服务器不维护任何有关客户端过去所请求的消息）</li><li>采用请求/响应的模式</li><li>使用TCP传输</li></ul></li></ol><table><thead><tr><th>持久性连接</th><th>非持久性连接</th></tr></thead><tbody><tr><td>    每个tcp连接只允许传送一个对象</td><td>允许传送多个对象</td></tr><tr><td>    HTTP1.0</td><td>HTTP1.1</td></tr></tbody></table><ol><li><p>代理服务器与远程服务器之间的更新</p><ul><li>条件性GET（如果缓存有最新的版本则不需要发送请求对象）<br> 在HTTP请求消息中声明所持有版本的日期 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-modified-since &lt;date&gt;</div></pre></td></tr></table></figure></li></ul></li><li><p>SMTP(邮件)</p><ul><li>采用TCP（可靠）持久性连接</li><li>通过ASCII采用命令/响应的模式</li><li>端口25</li><li>用MIME进行消息内容扩展，使其可以传输非ASCII数据（二进制、多媒体）</li></ul></li><li><p>DNS</p><ol><li><p>是一个<em>多层</em>命名服务器构成的<em>分布式</em>数据库（为什么不用集中式）</p><ul><li>单点失败</li><li>流量问题</li><li>距离问题</li><li>维护性问题</li></ul></li></ol><ul><li>应用层协议：完成名字的解析（在应用层实现Internet的核心服务）</li><li>域名解析过程<ul><li>向本地域名服务器请求，若本地不知道则直接请求根域名服务器</li><li>根域名服务器一般不知道，则返回顶级域名服务器（.com/.cn/.org…..)</li></ul></li><li>全球总共有13个根域名服务器</li><li>域名服务器<ul><li>根域名服务器</li><li>顶级域名服务器（负责.com/.cn/.org…..）</li><li>权威域名服务器（组织的域名服务器，提供组织内部服务器的解析服务）</li><li>本地域名解析服务器<ul><li>每个ISP都有默认的本地域名服务器</li><li>作为代理去查询分层式域名服务器</li></ul></li><li>DNS查询<ul><li>迭代查询（本地域名服务器负责根据指示依次查询域名服务器）</li><li>递归查询（本地域名服务器只向根域名服务器请求，根域名服务器再去请求顶级域名服务器，顶级再去查询权威，然后将结果依次返回）</li></ul></li><li>DNS缓存和更新<ul><li>只要域名解析服务器获得一个新的域名-ip映射，即缓存这一映射</li><li>本地域名服务器一般会缓存顶级域名服务器（根域名服务器一般不会被访问）</li></ul></li></ul></li><li>DNS记录（资源记录 Resource Record)<ul><li>format:(name, value, type, ttl)</li><li>type = A<ul><li>name 主机域名</li><li>value ip地址</li></ul></li><li>type = NS<ul><li>name：域（edu.cn)</li><li>value:该域权威域名解析服务器的主机域名）</li></ul></li><li>type = cname<ul><li>name ：某一真实域名的别名</li><li>value：真实域名</li></ul></li><li>type = MX<ul><li>value是于name相对应的邮件服务器</li></ul></li></ul></li><li>DNS协议（查询/回复）</li></ul></li></ol><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><ol><li>纯p2p架构<ul><li>没有服务器</li><li>任意端系统之间直接通信</li><li>节点阶段性接入internet</li><li>节点可能更换ip地址</li><li>多用户同时下载时性能比C/S优（C/S随着用户数增加耗时线性增长，p2p则是有个阈值）</li></ul></li><li>p2p例子：BitTorrent<ul><li>下载的同时进行发送（可以发送自己的，也可以发送刚刚下载的）</li><li>稀缺文件优先下载（防止端系统离开）</li><li>上传<ul><li>向给自己发送的4个需要下载的端系统发送数据</li><li>每10s重新评估top4</li><li>每30s随机选择一个其他结点，向其发送</li></ul></li></ul></li><li><p>索引技术</p><ol><li><p>集中式索引</p><ul><li>单点失败</li><li>性能瓶颈</li><li>法律</li></ul></li><li><p>完全分布式索引</p><ul><li>完全分布式架构</li><li>每个节点对他共享的文件且只对他共享的文件进行索引</li><li>用<a href="#jump">覆盖网络</a>实现全局性文件搜索</li><li>采用洪泛式查询，查询命中之后反向回传</li></ul></li><li><p>层次式覆盖网络</p><ul><li>介于集中式索引和洪泛式查询的方法</li><li>每个结点或者是一个超级结点，或者被分配一个超级节点</li><li>节点和超级节点之间维持TCP</li><li>某些超级节点对之间维持TCP<ul><li>普通节点向超级节点请求查询</li><li>超级节点之间使用洪泛式查询</li></ul></li><li>超级节点负责跟踪字节点的内容</li></ul></li></ol></li><li><p>危害</p><ul><li>对硬盘的损坏（高温、重复读写、扇区损坏）</li><li>占用网络带宽资源</li><li>助长病毒传播</li><li>盗版</li></ul></li><li><p><span id="jump">覆盖网络<span></span></span></p><ul><li>节点X与节点Y之间若有TCP连接那么构成一条边</li><li>所有活动的节点和边构成覆盖网络</li><li>节点一般邻居数少于十个</li></ul></li></ol><h2 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h2><ol><li>套接字使用时不用指定端口号，由操作系统负责分配和管理，用套接子描述符即可</li><li><p>windows对unix socket进行封装形成winsock，程序使用时以WSAStartup开头（初始化api），以WSACleanup（释放windows socket DLL）结尾</p></li><li><p>当多个进程同时是使用socket时，socket数据结构里有对其计数的变量，关闭一个则减1，到0才关闭此数据结构</p></li><li>同一个进程中的多个线程不能同时调用一个socket</li><li>当一个主机中有多个ip时，服务器端调用bind时用INADDR_ANY</li><li>listen、accept只用于服务器，监听端口，只是用于tcp</li><li>connect之用于客户端，tcp/udp</li><li>send, recv 适用于TCP或者调用connect的UDP</li><li>sendto, recvfrom用于未调用connect的UDP</li><li><img src="/image/socket_.jpg" alt="socket流程"></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层&quot;&gt;&lt;/a&gt;应用层&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;网络应用的体系结构&lt;ul&gt;
&lt;li&gt;客户机/服务器（c/s）&lt;/li&gt;
&lt;li&gt;peer to peer (点对点结构)
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>扩展/boot分区</title>
    <link href="http://blog.huhaobin.cn/2019/04/07/boot%20partition%20is%20not%20enough/"/>
    <id>http://blog.huhaobin.cn/2019/04/07/boot partition is not enough/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-04-07T09:13:38.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="how-to-expend-the-capicity-of-boot-partition-in-linux"><a href="#how-to-expend-the-capicity-of-boot-partition-in-linux" class="headerlink" title="how to expend the capicity of /boot partition in linux"></a>how to expend the capicity of /boot partition in linux</h2><ol><li>use the Disks offered in the System to build a partition for new /boot, and click “Mount the filesystem” signed by a triangle icon</li><li>copy all the things form old /boot partition to new /boot partition . new /boot partition willbe mounted in /mnt</li><li>click the old /boot prtition in Disks, click buttons as following<br> “More actions” signed by a gear<br> “Edit Mount Options…”, meanwhile, wtrite the config down for later<br> uncheck “Mount at Startup”<br> modify “Mount Point” to something else, such as “/boot_old”<br> and click OK</li><li>click the old /boot prtition in Disks, and “Unmount the filesystem”. click buttons as following<br> “More actions” signed by a gear, and click “Edit Partition” modify “Type” to linux filesystem and Change<br> “Edit Mount Options…” copy the config form old one<br> OK</li></ol><p>and now it can work almost, but there is something broken likely.to solve this , you can use the Boot Repair. here is its brochure:</p><p>installation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:yannubuntu/boot-repair</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install -y boot-repair &amp;&amp; boot-repair</div></pre></td></tr></table></figure></p><p>Recommended repair<br>launch Boot-Repair from either :<br>the Dash (the Ubuntu logo at the top-left of the screen)<br>or by typing ‘boot-repair’ in a terminal<br>Then click the “Recommended repair” button. When repair is finished, note the URL (paste.ubuntu.com/XXXXX) that appeared on a paper, then reboot and check if you recovered access to your OSs.</p><p>If the repair did not succeed, indicate the URL to people who help you by email or forum.</p><p>if you have trouble in booting, if you computer is booted by grub2, here is you solutions:</p><ol><li>ls<br>find the boot file location </li><li>set root = (hd0, gpt0)<br>(hd0,gpt0) is your boot file location</li><li>linux /path/to/your/bootfile(vmlinuz*) root=/dev/sda0<br>/dev/sda0 is your root location</li><li>initrd /path/to/your/bootfile(initrd*)</li><li>boot</li></ol><p>now you can boot your computer.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;how-to-expend-the-capicity-of-boot-partition-in-linux&quot;&gt;&lt;a href=&quot;#how-to-expend-the-capicity-of-boot-partition-in-linux&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="linux" scheme="http://blog.huhaobin.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://blog.huhaobin.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络1</title>
    <link href="http://blog.huhaobin.cn/2019/04/04/computernetworking1/"/>
    <id>http://blog.huhaobin.cn/2019/04/04/computernetworking1/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-04-08T03:10:10.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>计算机网络就是互连的、自治的计算机集合<ul><li>通过交换网络进行互连</li></ul></li><li>交换<ul><li>动态转接</li><li>动态资源分配和传输</li></ul></li><li><p>电路交换（电路建立—数据传输—电路拆除）</p><ul><li><p>多路复用</p><ul><li>频分复用（FDM）— 同轴电缆</li><li>时分复用（TDM) — 时间分帧、分片</li><li><p>码分复用（CDM）— 每个用户有个m bit的各个用户相互正交的码片序列</p><p>每个原始信号的bit位被用码片序列编码为m bit;1 -&gt; +1; 0 -&gt; -1;</p></li><li>波分复用（光的频分复用）</li></ul></li></ul></li><li>报文交换<ul><li>一次将一个报文全部传输</li><li>存储转发整个报文</li></ul></li><li><p>分组交换</p><ol><li>报文的拆分和重组</li><li>产生额外开销</li><li>存储转发小分组</li><li>便于实现统计复用</li><li>由于流水线技术，速度比报文交换要快，硬件要求要低</li><li><p>适用于突发数据传输</p><ul><li>充分利用资源</li><li>无需建立电路</li></ul></li><li><p>分组延迟</p><ul><li><p>结点处理延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">差错控制</div><div class="line">确定输出链路</div><div class="line">通常小于msec</div></pre></td></tr></table></figure></li><li><p>排队延迟</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">等待输出链路可用</div><div class="line">取决与路由器的当前拥塞状态</div></pre></td></tr></table></figure></li><li><p>传输延迟（发送一个分组所需要的时间）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">分组长度</div><div class="line">链路宽度</div></pre></td></tr></table></figure></li><li><p>传播延迟（信号在介质（一个路由器到另一个路由器或端系统）中的传播延迟）</p></li></ul></li></ol></li><li>协议是两个对等实体进行通信的规则的集合，是“水平的”; 同系统的相邻层之间通过接口进行交互，通过服务访问点（SAP—service access point）交换原语，请求特定的服务</li><li>计算机网络结构是分层的（软件和硬件）</li></ol><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><ol><li>七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层<ul><li>一般主机需要实现所有层，路由器只需要实现最基本的三层<br><img src="/image/osi.jpg" alt="数据传输过程"></li><li>数据在上层向下层传递的过程中除了数据链路层向物理层不增加帧头之外，其他的层都需要增加，<strong>并且数据链路层加帧头和帧尾</strong></li><li>数据封装的目的<ul><li>差错检测</li><li>地址信息</li><li>协议控制</li></ul></li></ul></li><li>物理层（解决单一比特的传输问题）<ul><li>接口特性、比特编码、数据率、比特同步、传输模式（单工通信、半双工、双工通信）</li></ul></li><li>数据链路层（结点到结点的数据传输）<ul><li>组帧（便于接受信息）</li><li>物理寻址（物理层不能寻址）</li><li>流量控制（匹配发送和接受速度）</li><li>差错控制</li><li>接入控制（访问控制）</li></ul></li><li>网络层<ul><li>逻辑寻址（ip）—全局的唯一逻辑地址</li><li>路由选择</li><li>分组转发</li></ul></li><li>传输层的功能（负责源-&gt;目的（端到端）（进程间）的完整报文传输）<ul><li>报文的分段和重组</li><li>SAP寻址（保证交给正确的进程）</li><li>可以实现端到端的链接控制，流量控制，差错控制</li></ul></li><li>会话层（主要负责对话管理，同步等）<ul><li>不单独存在</li></ul></li><li>表示层（处理两个系统之间交换信息的语法和语义问题）<ul><li>数据表示转化（大小端）</li><li>加解密，压缩，解压缩</li><li>不单独存在</li></ul></li><li>应用层</li></ol><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><ol><li>网络接口层、网际层、运输层、应用层</li><li><p>Everything over IP</p></li><li><p>5层参考模型</p><ul><li>物理层</li><li>数据链路层</li><li>网络层（源到目的的数据分组路由和转发）</li><li>传输层（TCP、UDP）{进程之间的通信}</li><li>应用层（支持各种网络应用）</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;计算机网络就是互连的、自治的计算机集合&lt;ul&gt;
&lt;li&gt;通过交换网络进行互连&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;交换&lt;u
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.huhaobin.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="自顶向下方法" scheme="http://blog.huhaobin.cn/tags/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
