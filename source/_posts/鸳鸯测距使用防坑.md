---
title: 鸳鸯测距使用防坑
abbrlink: 1671835932
date: 2020-02-10 13:48:47
tags: 硬件
---


这两天使用超声波测距（鸳鸯测距）来实现双车通信，但是使用时碰到了特别多的坑，理论上来说测到的距离是一条非常平滑的线，但是在使用的时候就出现了各种波动。
V4传说是180度测距，V5是360度测距，但是V4实际使用的时候只有90度左右，V5确实是360度，但是在前车的左右两旁会出现距离跳变。

实际测量的曲线波动特别有规律，一般的滤波方法根本无能为力，在探索了三天之后，得到这些滤波方法：
#### 限幅滤波法(又称程序判断滤波法)
- 方法:
	根据经验判断,确定两次采样允许的最大偏差值(设为A)
	每次检测到新值时判断:
	+ 如果本次值与上次值之差<=A,则本次值有效 
	+ 如果本次值与上次值之差>A,则本次值无效,放弃本次值,用上次值代替本次值
- 优点:
能有效克服因偶然因素引起的脉冲干扰
- 缺点
    - 无法抑制那种周期性的干扰
    - 平滑度差
#### 中位值滤波法
- 方法:
    - 连续采样N次(N取奇数)
    - 把N次采样值按大小排列
    - 取中间值为本次有效值
- 优点:
    - 能有效克服因偶然因素引起的波动干扰
    - 对温度、液位的变化缓慢的被测参数有良好的滤波效果
- 缺点:
    - 对流量、速度等快速变化的参数不宜
#### 算术平均滤波法
- 方法:
    + 连续取N个采样值进行算术平均运算
    + N值较大时:信号平滑度较高,但灵敏度较低
    + N值较小时:信号平滑度较低,但灵敏度较高
    + N值的选取:一般流量,N=12;压力:N=4
- 优点:
    * 适用于对一般具有随机干扰的信号进行滤波
    * 这样信号的特点是有一个平均值,信号在某一数值范围附近上下波动
- 缺点:
    * 对于测量速度较慢或要求数据计算速度较快的实时控制不适用
    * 比较浪费RAM

#### 递推平均滤波法(又称滑动平均滤波法)
- 方法:
    * 把连续取N个采样值看成一个队列
    * 队列的长度固定为N
    * 每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)
    把队列中的N个数据进行算术平均运算,就可获得新的滤波结果
    * N值的选取:流量,N=12;压力:N=4;液面,N=4~12;温度,N=1~4
- 优点:
    * 对周期性干扰有良好的抑制作用,平滑度高
    * 适用于高频振荡的系统
- 缺点:
    * 灵敏度低
    * 对偶然出现的脉冲性干扰的抑制作用较差
    * 不易消除由于脉冲干扰所引起的采样值偏差
    * 不适用于脉冲干扰比较严重的场合
    * 比较浪费RAM
    
#### 中位值平均滤波法(又称防脉冲干扰平均滤波法)
- 方法:
    * 相当于“中位值滤波法”+“算术平均滤波法”
    * 连续采样N个数据,去掉一个最大值和一个最小值
    * 然后计算N-2个数据的算术平均值
    * N值的选取:3~14
- 优点:
    * 融合了两种滤波法的优点
    * 对于偶然出现的脉冲性干扰,可消除由于脉冲干扰所引起的采样值偏差
- 缺点:
    * 测量速度较慢,和算术平均滤波法一样
    * 比较浪费RAM

####限幅平均滤波法
- 方法:
    * 相当于“限幅滤波法”+“递推平均滤波法”
    * 每次采样到的新数据先进行限幅处理,
    * 再送入队列进行递推平均滤波处理
- 优点:
    * 融合了两种滤波法的优点
    * 对于偶然出现的脉冲性干扰,可消除由于脉冲干扰所引起的采样值偏差
- 缺点:
    - 比较浪费RAM

#### 一阶滞后滤波法

- 方法:
    * 取a=0~1
    * 本次滤波结果=(1-a) 本次采样值+a 上次滤波结果
- 优点:
    * 对周期性干扰具有良好的抑制作用
    * 适用于波动频率较高的场合
- 缺点:
    * 相位滞后,灵敏度低
    * 滞后程度取决于a值大小
    * 不能消除滤波频率高于采样频率的1/2的干扰信号
    
####加权递推平均滤波法
- 方法:
    * 是对递推平均滤波法的改进,即不同时刻的数据加以不同的权
    * 通常是,越接近现时刻的数据,权取得越大.
    * 给予新采样值的权系数越大,则灵敏度越高,但信号平滑度越低
- 优点:
    * 适用于有较大纯滞后时间常数的对象
    * 和采样周期较短的系统
- 缺点:
    * 对于纯滞后时间常数较小,采样周期较长,变化缓慢的信号
    * 不能迅速反应系统当前所受干扰的严重程度,滤波效果差

####消抖滤波法
- 方法:
    * 设置一个滤波计数器
    * 将每次采样值与当前有效值比较:
    * 如果采样值＝当前有效值,则计数器清零
    * 如果采样值<>当前有效值,则计数器+1,并判断计数器是否>=上限N(溢出)
    * 如果计数器溢出,则将本次值替换当前有效值,并清计数器
- 优点:
    * 对于变化缓慢的被测参数有较好的滤波效果,
    * 可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动
- 缺点:
    * 对于快速变化的参数不宜
    * 如果在计数器溢出的那一次采样到的值恰好是干扰值,则会将干扰值当作有效值导入系统

####限幅消抖滤波法
- 方法:
    * 相当于“限幅滤波法”+“消抖滤波法”
    * 先限幅,后消抖
- 优点:
    * 继承了“限幅”和“消抖”的优点
    * 改进了“消抖滤波法”中的某些缺陷,避免将干扰值导入系统
- 缺点:
    - 对于快速变化的参数不宜

## 示例程序,如有不足之处还望各位同行指教
假定从8位AD中读取数据(如果是更高位的AD可定义数据类型为int),子程序为`get_ad()`;

#### 限副滤波

A值可根据实际情况调整
value为有效值,new_value为当前采样值
滤波程序返回有效的实际值
```C
#define A 10

char value;

char filter()
{
char new_value;
new_value = get_ad();
if ( ( new_value - value &gt; A ) || ( value - new_value &gt; A )
return value;
return new_value;

}
```
#### 中位值滤波法

N值可根据实际情况调整
排序采用冒泡法
```C
#define N 11

char filter()
{
  char value_buf[N];
  char count,i,j,temp;
  for ( count=0;count
  {
    value_buf[count] = get_ad();
    delay();
  }
  for (j=0;j
    {
    for (i=0;i
      {
        if ( value_buf[i]&gt;value_buf[i+1] )
      {
      temp = value_buf[i];
      value_buf[i] = value_buf[i+1];
      value_buf[i+1] = temp;
      }
    }
  }
  return value_buf[(N-1)/2];
}
```
####算术平均滤波法
```C
#define N 12

char filter()
{
  int sum = 0;
  for ( count=0;count
  {
    sum + = get_ad();
    delay();
  }
  return (char)(sum/N);
}
```
#### 递推平均滤波法(又称滑动平均滤波法)
```C
#define N 12

char value_buf[N];
char i=0;

char filter()
{
  char count;
  int sum=0;
  value_buf[i++] = get_ad();
  if ( i == N ) i = 0;
  for ( count=0;count
  sum = value_buf[count];
  return (char)(sum/N);
}
```
#### 中位值平均滤波法(又称防脉冲干扰平均滤波法)
```C
#define N 12

char filter()
{
  char count,i,j;
  char value_buf[N];
  int sum=0;
  for (count=0;count
  {
    value_buf[count] = get_ad();
    delay();
  }
  for (j=0;j
  {
    for (i=0;i
    {
      if ( value_buf[i]&gt;value_buf[i+1] )
    {
      temp = value_buf[i];
      value_buf[i] = value_buf[i+1];
      value_buf[i+1] = temp;
    }
    }
  }
  for(count=1;count
  sum += value[count];
  return (char)(sum/(N-2));
}
```
####限幅平均滤波法

略 参考子程序1、3

####一阶滞后滤波法

为加快程序处理速度假定基数为100,a=0~100
```C
#define a 50

char value;

char filter()
{
char new_value;
new_value = get_ad();
return (100-a)*value + a*new_value;
}
```
####加权递推平均滤波法

code数组为加权系数表,存在程序存储区.
```C
#define N 12

char code coe[N] = {1,2,3,4,5,6,7,8,9,10,11,12};
char code sum_coe = 1+2+3+4+5+6+7+8+9+10+11+12;

char filter()
{
  char count;
  char value_buf[N];
  int sum=0;
  for (count=0,count
  {
    value_buf[count] = get_ad();
    delay();
  }
  for (count=0,count
    sum += value_buf[count]*coe[count];
  return (char)(sum/sum_coe);
}
```
####消抖滤波法
```C
#define N 12

char filter()
{
  char count=0;
  char new_value;
  new_value = get_ad();
  while (value !=new_value);
  {
    count++;
    if (count&gt;=N) return new_value;
      delay();
    new_value = get_ad();
  }
  return value;
}
```
####限幅消抖滤波法

略 参考子程序1、9

我是用了第五种滤波方法得到了比较稳定的距离。