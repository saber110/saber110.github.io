---
title: 组会记录
tags:
  - 算法
  - 组会
abbrlink: 804394302
date: 2019-05-07 16:06:00
---

## [](#the-difference-between-‘Nature’-and-‘Science’ "the difference between ‘Nature’ and ‘Science’")the difference between ‘Nature’ and ‘Science’

nature: 懂事前就有的东西，即懂事前已经有了的东西

science：懂事后才有的东西，在自己懂事之后的出现的东西

## [](#BFS "BFS")BFS

*   输出root-tree，输出若干个根树（非连通图）

*   最先由于解决迷宫问题—&gt;判断终点问题而提出

*   应用

    *   查找图中的所有连接组件（一个连接组件是图中的最大连接子图）

    由起点开始运行BFS所经过的所有节点，即为包含七点的一个连接组件

        *   查找连接组件中的所有节点

        *   查找非加权图中的任意两点间的最短路径

        *   测试某图是否是**二分图(bipartite graph)**

    从任一节点出发，在搜索过程中给节点不同的标签，例如给开始点标0，开始点的所有邻居1，开始点的所有邻居的邻居再标0，以此类推。若在搜索过程中，任一节点有跟其相同标签的邻居，则此图不是二分图。若搜索结束时没有发生这种情况则说明此图是一二分图

        *   应用于计算机游戏中的平面网格

    BFS可用来解决计算机游戏（例如即时策略游戏）中找寻路径的问题。在这个应用中，使用平面网格来代替图形，而一个格子即是图中的一个节点。所有节点都与它的邻居（上、下、左、右、左上、右上、左下、右下）相接。

    值得一提的是，当这样使用BFS算法时，首先要**先检验上、下、左、右**的邻居节点，**再检验左上、右上、左下、右下**的邻居节点。这是因为BFS趋向于先查找斜向邻居节点，而不是四方的邻居节点，因此找到的路径将不正确。BFS应该先查找四方邻居节点，接着才查找斜向邻居节点。

## [](#LBFS-Lexicographic-breadth-first-search "LBFS(Lexicographic breadth-first search)")LBFS(Lexicographic breadth-first search)

*   词典序的广度优先搜索算法

*   基于[Partition refinement](https://en.wikipedia.org/wiki/Partition_refinement)（一种用数据结构分类将集合分类为若干组小的集合的算法）

*   应用

    *   识别chordal graph

            *   Use lexicographic breadth-first search to find a lexicographic ordering of _G_
  // 对图G使用LBFS生成一个LBFS序列

                    *   For each vertex v :
// 对于每个顶点V

                        *   Let w be the neighbor of v occurring prior to v , as close to v in the sequence as possible
// 设w是v之前出现的v的邻居，尽可能接近序列中的v

                            *   (Continue to the next vertex _v_ if there is no such _w_)

                ​    // 若没有符合要求的w则去下个定点v

                        *   If the set of earlier neighbors of _v_ (excluding _w_ itself) is not a subset of the set of earlier neighbors of _w_, the graph is not chordal

            // 如果v的早期邻居集合（不包括w本身）不是w的早期邻居集合的子集，则不是chordal

                *   If the loop terminates without showing that the graph is not chordal, then it is chordal.
    *   图染色问题

## [](#MCS（maximum-cardinality-search） "MCS（maximum cardinality search）")MCS（maximum cardinality search）

以任一点为起点，优先访问已访问邻居数最多的点

*   可以用来识别chordal graph
*   MCS按照最大生成树的顺序进行下去

## [](#clique "clique")clique

*   一个无向图中，满足两两之间有边连接的顶点的集合，被称为该无向图的团

*   顶点集C被称为[无向图](https://zh.wikipedia.org/wiki/無向圖) G=(V,E) 的**团**，如果C是[顶点](https://zh.wikipedia.org/wiki/顶点)集V的子集(C⊆V)，而且任意两个C中的顶点都有[边](https://zh.wikipedia.org/wiki/边)连接。另一种等价的说法是，由C诱导的子图是[完全图](https://zh.wikipedia.org/wiki/完全圖) （有时也用“团”来指这样的子图）。

*   **极大团**是指增加任一顶点都不再符合团定义的团，也就是说，极大团不能被任何一个更大的团所包含。

## [](#chordal-graph "chordal graph")chordal graph

*   如果长度大于3的每个圈都具有弦，即具有连接圈中的两个非连续顶点的边，则无向图被称为弦图。
*   _一个无向图称为弦图当图中任意长度大于3的环都至少有一个弦。_
*   chordal的任何一部分都是chordal
*   MCS在chordal上的终点是simplicial point
*   MCS在chordal上一定按着极大团的顺序遍历

## [](#区间图 "区间图")区间图

在图论中，区间图是由实线上的一组区间形成的无向图，每个区间具有顶点，区间相交的顶点之间具有边。 它是间隔的交叉图。

![Seven intervals on the real line and the corresponding seven-vertex interval graph](/image/Interval_graph.svg)

使用LBFS三遍就能生成

*   第一遍任选起点，记录终点
*   第二遍从终点开始便历（会有某些错位的需要第三遍纠正）
*   第三遍从第二遍的终点开始便历，即可以得到区间序列

## [](#基本概念 "基本概念")基本概念

[参考链接](https://blog.csdn.net/shenlan211314/article/details/6312228)

实例：无向图G=(V, E)，V为图的所有顶点集合（非空），E为图的所有边的集合。

*   子图：G’=(V’, E’)，V’被包含于V，E’被包含于E，G’为G的子图。

*   生成子图：在子图中，E’&lt;=E且V’&lt;=V；在生成子图中，E’&lt;=E,且V’=V

*   诱导子图（induced graph）

G’=(V’, E’)，V’被包含于V，E’={(u, v)|u, v属于V’，(u, v)属于E}，G’为G的诱导子图。

**注意：对于V’，只要在G中有边，那么在G’中同样应该有边。**

*   团（clique）

G’为关于**V’**的_完全图_。

一个团为极大团（maximal clique）当且仅当它不是其它团的子图。

　　一个图为最大团（maximum clique）当且仅当它的点集模最大。

　　一个图的团数表示为ω(G)。

*   弦图(chordal graph)

一个无向图称为弦图当图中任意长度大于3的环都至少有一个弦。

*   单纯点（simplicial vertex）

设N(v)表示与点v相邻的点集。一个点称为单纯点当**{v}+N(v)的诱导子图为一个团**。

**定理**

任何一个弦图都至少有一个单纯点，不是完全图的弦图至少有两个不相邻的单纯点(simplicail point)。

*   完美消除序列（perfect elimination ordering）

一个点的序列（每个点出现且恰好出现一次）v[1], v[2], …, v[n]满足v[i]在{v[i], v[i+1], …, v[n]}的诱导子图中为一个单纯点