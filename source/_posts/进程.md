---
title: 进程
tags: OS
abbrlink: 52063040
date: 2020-02-11 13:20:23
---

## 进程介绍
1. 进程的创建

- 原因：
    - 系统初始化
    - 正在运行的进程执行了创建进程的系统调用
    - 用户请求创建一个新进程
    - 批处理作业的初始化

2. 进程的终止

- 原因：
    - 正常退出（自愿）
    - 出错退出（自愿）
    - 严重错误（非自愿）
    - 被其他进程杀死（非自愿）

3. 进程的状态

- 运行态
- 就绪态
- 阻塞态

4. 线程可以在内核和用户空间中进行管理，但不论是在哪儿都会引来很多问题

### 进程间通信（IPC）
#### 临界区

一个好的临界区解决方案需要具备以下四个条件：

- 任何两个进程不能同时处于临界区
- 不应对CPU的速度和数目做任何假设
- 临界区外的进程不能阻塞其他进程
- 不能让进程在临界区外面无休止的等待

#### 忙等待形式的互斥

1. 关闭中断

    在进入临界区之前先关中断，退出之后开中断。这样把开关中断的权限交给用户是不明智的

2. 锁变量

    设置一个共享锁变量，0表示临界区内没有进程，1表示有。每次进入之前先测试，如果此时为0则设置为1，退出临界区设置为0。遗憾的是这个方法也不是线程安全的

3. 严格交替法
```C
WHILE(TRUE)
{
  WHILE(turn != 0);
  critical_region();
  turn = 1;
  noncritical_region();
}
```
```bash
WHILE(TRUE)
{
  WHILE(turn != 1);
  critical_region();
  turn = 0;
  noncritical_region();
}
```
整型变量turn的初值为零，用于跟踪轮到哪个进程进入临界区。一开始进程0检查turn，发现是0，所以进入临界区。同时进程1也在检查turn，不停的检查是否变为1。这样就产生了忙等待。还有一种情况就是进程0退出临界区并将turn设置为1，此时进程0和1都在忙非临界区的任务，但是进程0先忙完需要进入临界区，由于turn为1所以进程0不能进入临界区

4. Peterson解决方案
5. TSL语句
6. 信号量

    用一个整型变量来累计唤醒次数，供以后使用。
    在这个解决方案中用了三个信号量。
    ```
    full 用来记录满的缓冲槽的数目，初值为0
    empty 用来记录空的缓冲槽的数目，初值为缓冲区内槽的数目
    mutex 用来确保生产者和消费者不会同时访问缓冲区，初值为1
    ```
    多个进程使用初值为1的信号量可以保证同时只有一个进程可以进入临界区，如果每个进程在进入临界区之前执行一个down，退出之后执行一个up就可以保证互斥

7. 互斥

    若不需要信号量的计数能力，有时可以使用信号量的另一个版本—-互斥
    互斥是一个可以处于两态之一的变量：解锁(mutex_unlock)和加锁(mutex_lock)

8. 管程

9. 进程调度
10. 批处理系统中的调度
11. 先到先服务
12. 最短作业优先
13. 最短剩余时间优先
14. 三级调度
    - 准入调度器
    - 内存调度器
    - CPU调度器
15. 交互系统中的调度
16. 时间片轮转调度
17. 优先级调度

    注意时常对优先级进行调整，防止低优先级的进程饿死

18. 多重队列
19. 最短进程优先（老化算法预估进程运行所需时间）
20. 保证调度算法
    - 彩票调度算法
    - 公平分享调度
    - 实时系统调度