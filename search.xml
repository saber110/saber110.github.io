<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[程序员的自我修养]]></title>
    <url>%2F2018%2F05%2F13%2FProgrammer'sSelfCultivation2%2F</url>
    <content type="text"><![CDATA[线程调度在优先级调度的环境下，线程优先级改变的方式有 用户制定优先级 根据进入等待状态的频繁程度提升或降低优先级 长时间得不到执行而提升优先级目标文件 基本结构如图所示 初始化的全局变量和局部静态变量保存在.data 未初始化的全局变量和局部静态变量保存在.bss File Header 里面包含一个段表除此之外还可以自定义段1234567__attribute__((section(&quot;FOO&quot;))) int global = 42;__attribute__((section(&quot;BAR&quot;))) void foo()&#123;&#125;// 这样就可以把相应的变量或者函数放在以“FOO”/&quot;BAR&quot;作为段名的段中// 名字可以自定义 C++和C的兼容1234extern &quot;C&quot;&#123; int func(int); int var;&#125; C++ 编译器会将在extern “C”大括号内部的代码当作C语言来处理 为了处理C++调用了C函数，但认为是C++函数，经过名称修饰之后无法正确引用的问题，C++编译器会在便宜C++的程序时默认定义宏”__cplusplus”.我们可以使用条件宏来判断当前便宜单元是不是C++代码 12345678#ifdef __cplusplusextern &quot;C&quot;&#123;#endifvoid *memset(void *, int, size_t); // C语言内容#ifdef __cplusplus&#125;#endif]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
      <tags>
        <tag>程序员的自我修养</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息的表示和处理]]></title>
    <url>%2F2018%2F05%2F11%2FOS2%2F</url>
    <content type="text"><![CDATA[信息存储 数据大小 123456789C类型 字节（32位） 字节（64位）char 1 1short int 2 2int 4 4long int 4 8long long int 8 8float 4 4double 8 8char * 4 8 移位 假如进行x&gt;&gt;k,这里的k很大,实际偏移量是通过k mod v得到的 123int lval = 0xede875 &gt;&gt; 32;int aval = 0xede875 &gt;&gt; 36;unsigned int uval = 0xede875 &gt;&gt; 40; 在32位机器上 123lval = 0xede875; // 32 mod 32 = 0aval = 0xfede87; // 36 mod 32 = 4uval = 0x00ede8; 几乎所有的编译器/机器都对有符号数据使用算术右移，无符号数据必须是逻辑右移]]></content>
      <categories>
        <category>操作系统原理</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程]]></title>
    <url>%2F2018%2F05%2F09%2FOS1%2F</url>
    <content type="text"><![CDATA[进程介绍 进程的创建 原因： 系统初始化 正在运行的进程执行了创建进程的系统调用 用户请求创建一个新进程 批处理作业的初始化 进程的终止 原因： 正常退出（自愿） 出错退出（自愿） 严重错误（非自愿） 被其他进程杀死（非自愿） 进程的状态 运行态 就绪态 阻塞态 线程可以在内核和用户空间中进行管理，但不论是在哪儿都会引来很多问题 进程间通信（IPC） 临界区 一个好的临界区解决方案需要具备以下四个条件： 任何两个进程不能同时处于临界区 不应对CPU的速度和数目做任何假设 临界区外的进程不能阻塞其他进程 不能让进程在临界区外面无休止的等待 忙等待形式的互斥 关闭中断 在进入临界区之前先关中断，退出之后开中断。这样把开关中断的权限交给用户是不明智的 锁变量 设置一个共享锁变量，0表示临界区内没有进程，1表示有。每次进入之前先测试，如果此时为0则设置为1，退出临界区设置为0。遗憾的是这个方法也不是线程安全的 严格交替法 1234567WHILE(TRUE)&#123; WHILE(turn != 0); critical_region(); turn = 1; noncritical_region();&#125; 1234567WHILE(TRUE)&#123; WHILE(turn != 1); critical_region(); turn = 0; noncritical_region();&#125; 整型变量turn的初值为零，用于跟踪轮到哪个进程进入临界区。一开始进程0检查turn，发现是0，所以进入临界区。同时进程1也在检查turn，不停的检查是否变为1。这样就产生了忙等待。还有一种情况就是进程0退出临界区并将turn设置为1，此时进程0和1都在忙非临界区的任务，但是进程0先忙完需要进入临界区，由于turn为1所以进程0不能进入临界区 Peterson解决方案 TSL语句 信号量 用一个整型变量来累计唤醒次数，供以后使用。 在这个解决方案中用了三个信号量。 full 用来记录满的缓冲槽的数目，初值为0 empty 用来记录空的缓冲槽的数目，初值为缓冲区内槽的数目 mutex 用来确保生产者和消费者不会同时访问缓冲区，初值为1 多个进程使用初值为1的信号量可以保证同时只有一个进程可以进入临界区，如果每个进程在进入临界区之前执行一个down，退出之后执行一个up就可以保证互斥 互斥 若不需要信号量的计数能力，有时可以使用信号量的另一个版本—-互斥 互斥是一个可以处于两态之一的变量：解锁(mutex_unlock)和加锁(mutex_lock) 管程进程调度批处理系统中的调度 先到先服务 最短作业优先 最短剩余时间优先 三级调度 准入调度器 内存调度器 CPU调度器交互系统中的调度 时间片轮转调度 优先级调度 注意时常对优先级进行调整，防止低优先级的进程饿死 多重队列 最短进程优先（老化算法预估进程运行所需时间） 保证调度算法 彩票调度算法 公平分享调度实时系统调度]]></content>
      <categories>
        <category>操作系统原理</category>
      </categories>
      <tags>
        <tag>操作系统原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Octave安装forge]]></title>
    <url>%2F2018%2F04%2F30%2FOctaveInstallforge%2F</url>
    <content type="text"><![CDATA[安装缺少的库 1apt install liboctave-dev 安装control 123octave-clipkg install -forge fuzzy-logic-toolkitpkg install -forge control]]></content>
      <categories>
        <category>Octave</category>
      </categories>
      <tags>
        <tag>Octave</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之神经网络]]></title>
    <url>%2F2018%2F04%2F29%2Fmachine-learning4%2F</url>
    <content type="text"><![CDATA[a在这里表示神经网络中的神经元 分类 二元分类(Binary classification) 多分类(Multi-class classification) 代价函数 L: 网络中的总层数 K: 输出层神经元的数量 Sl: l 层的总神经元数量(不算偏置单元)额 为了计算代价函数的最小值，我们使用反向传播算法 反向传播算法(计算出代价函数下降最快的方向)给出训练集{(x(1),y(1))⋯(x(m),y(m))} 令 Δi,j(l) := 0 for all (l,i,j), (hence you end up having a matrix full of zeros) For training example t =1 to m: Set a(1):=x(t) Perform forward propagation to compute a(l) for l=2,3,…,L Using y(t), compute δ(L)=a(L)−y(t) Compute δ(L−1),δ(L−2),…,δ(2) using δ(l)=((Θ(l))Tδ(l+1)) .∗ a(l) .∗ (1−a(l)) Δi,j(l):=Δi,j(l)+aj(l)δi(l+1) or with vectorization, Δ(l):=Δ(l)+δ(l+1)(a(l))T Hence we update our new Δ matrix. Di,j(l):=1/m(Δi,j(l)+λΘi,j(l)), if j≠0. Di,j(l):=1/mΔi,j(l) If j=0 所以得出J的微分为 向量展开在之前的学习过程中我们总是使用fminunc来优化参数，但是他要求所有的输入和输出均是向量，我们在神经网络中使用的时候只能把Theta矩阵和Gradient矩阵进行向量化 size(Theta1) = 10 * 11 size(Theta2) = 10 * 11 size(Theta3) = 1 * 1112thetaVector = [ Theta1(:); Theta2(:); Theta3(:); ]deltaVector = [ D1(:); D2(:); D3(:) ] 恢复为矩阵123Theta1 = reshape(thetaVector(1:110),10,11)Theta2 = reshape(thetaVector(111:220),10,11)Theta3 = reshape(thetaVector(221:231),1,11) 梯度计算结果校验反向传播算法复杂多变，我们使用导数的定义来校验反向传播得到的结果是否正确(相差很小)，当确定正确之后关掉梯度校验。因为他很 慢 12345678epsilon = 1e-4;for i = 1:n, thetaPlus = theta; thetaPlus(i) += epsilon; thetaMinus = theta; thetaMinus(i) -= epsilon; gradApprox(i) = (J(thetaPlus) - J(thetaMinus))/(2*epsilon)end; 随机初始化为了避免神经网络因为相同的Theta而陷入冗余的计算，范围是[-INIT_EPSILON,INIT_EPSILON]12345If the dimensions of Theta1 is 10x11, Theta2 is 10x11 and Theta3 is 1x11.Theta1 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;Theta2 = rand(10,11) * (2 * INIT_EPSILON) - INIT_EPSILON;Theta3 = rand(1,11) * (2 * INIT_EPSILON) - INIT_EPSILON; 网络选择 的步骤 Number of input units = dimension of features x(i) Number of output units = number of classes Number of hidden units per layer = usually more the better (must balance with cost of computation as it increases with more hidden units) Defaults: 1 hidden layer. If you have more than 1 hidden layer, then it is recommended that you have the same number of units in every hidden layer.网络训练的步骤 Randomly initialize the weights Implement forward propagation to get hΘ(x(i)) for any x(i) Implement the cost function Implement backpropagation to compute partial derivatives Use gradient checking to confirm that your backpropagation works. Then disable gradient checking. Use gradient descent or a built-in optimization function to minimize the cost function with the weights in theta. When we perform forward and back propagation, we loop on every training example:123for i = 1:m, Perform forward propagation and backpropagation using example (x(i),y(i)) (Get activations a(l) and delta terms d(l) for l = 2,...,L (There are m training sets)]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之神经网络介绍]]></title>
    <url>%2F2018%2F04%2F28%2Fmachine-learning3%2F</url>
    <content type="text"><![CDATA[神经网络可以用来解决特征特别多的机器学习问题，普通的解决方法在这儿显得无能为力，主要是特征向量太多的时候就会出现无数种特征向量的组合产生假设函数的无数项，这对于计算来说不现实。 表示 层： 输入层、隐藏层、输出层 仍然使用sigmoid函数3. aij: 第j层的第i个元素 Θ(j): j层到j+1层的权重映射矩阵 如果网络在j层有sj个单元，j+1层有sj+1个单元，那么Θ(j)的维度为sj+1×(sj+1) 向量化对于中间层的计算，我们可以定义Z使得 变形为进行向量化之后也就是说]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之逻辑分类问题]]></title>
    <url>%2F2018%2F04%2F27%2Fmachine-learning2%2F</url>
    <content type="text"><![CDATA[逻辑回归问题系统函数 逻辑回归 线性回归 线性回归中 g(z)=1 决策边界(Decision boundary) 一条分割y=0和y=1的线 代价函数(cost function) 整合之后 gradient计算 梯度下降法 过度拟合 过度拟合只会充分的拟合训练数据集，对数据预测并不会得到想要的值 解决方法(regularization) regularization 重新设置代价函数(cost function)J给每个theta做惩罚，用足够大的lambda去削弱theta的作用，从而平滑h。但是lambda太大的话将导致欠拟合，太大的时候得到的仅仅是一条扁平的直线 梯度下降法将theta分开更新是因为在重新设计代价函数的时候没有给theta惩罚，简化之后为 归一化求代价函数的最小值]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之线性回归问题]]></title>
    <url>%2F2018%2F04%2F23%2Fmachine-learning1%2F</url>
    <content type="text"><![CDATA[线性回归问题代价函数 假设系统函数 代价函数 alpha: 学习效率 梯度下降法 普适算法 线性回归中 记得同步更新theta 多变量的线性回归问题数据处理 数据缩放() 1X = X/MAX(X); 使得X 接近[-1,1]区间 平均值正常化 1X = (X-U)/(max(X)-MIN(x)) // U是X的平均值 数据归一化 1theta = pinv(X&apos;*X)*X&apos;*y; 可以用正态方程求解代价函数最小值]]></content>
      <categories>
        <category>machine-learning</category>
      </categories>
      <tags>
        <tag>machine-learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt画图]]></title>
    <url>%2F2018%2F04%2F21%2FqtPainting%2F</url>
    <content type="text"><![CDATA[QcustomPlot 下载 1http://www.qcustomplot.com 把qcustomplot.cpp和qcustomplot.h拷贝到工程目录下，然后把这两个文件引入工程项目即可 pro文件中QT += widgets printsupport 使用一个Widget窗体在ui设计器上，对这个窗体点击右键，选择提升为，把提升的类名填写为QCustomPlot即可，这样就可以使用了，使用就和我们用普通控件一样，ui-&gt;xxx-&gt;……。xxx为widget的名字 12345678910111213141516QVector x(101), y(101); // initialize with entries 0..100for (int i=0; i&lt;101; ++i)&#123;x[i] = i/50.0 – 1; // x goes from -1 to 1y[i] = x[i]*x[i]; // let’s plot a quadratic function&#125;qDebug()&lt;&lt;“data has been created”;ui-&gt;black_line-&gt;addGraph();qDebug()&lt;&lt;“begin painting”;ui-&gt;black_line-&gt;graph(0)-&gt;setData(x,y);ui-&gt;black_line-&gt;xAxis-&gt;setLabel(“x”);ui-&gt;black_line-&gt;yAxis-&gt;setLabel(“y”);ui-&gt;black_line-&gt;xAxis-&gt;setRange(-1, 1);ui-&gt;black_line-&gt;yAxis-&gt;setRange(0, 1);ui-&gt;black_line-&gt;replot();qDebug()&lt;&lt;“finish”;]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>上位机 Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysqldb安装]]></title>
    <url>%2F2018%2F04%2F19%2FMySQLdb%2F</url>
    <content type="text"><![CDATA[1apt install python3-mysqldb]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新博客站的第一篇文章]]></title>
    <url>%2F2018%2F04%2F19%2Fabout%2F</url>
    <content type="text"><![CDATA[百废待兴自从前一段时间开始搞电设,就已经没有精力去打理博客了,由于个人原因之前用的Wp,虽然还能跑起来但是已经不喜欢用了.国内对域名备案要求太高了,我的域名在撑过了两个春秋之后终于被封杀了,所以我现在WP 里面好多东西都是缺兵少将的.故过来搭一个git pages的博客,免去维护的时间成本 移花接木虽然搭建(ง •̀_•́)ง 了新的博客也不能放弃前面的学习资料,虽然已经有很多都已经没有记录了,但是之前已经记录的东西是万万不能放弃的,所以打算在这几天的颓废期里面把之前的博文再写一遍,以备后续查漏补缺. 后悔莫及前一段时间有很多次想写博客,但是由于域名被封,之前自用WP不能正常工作了,当时又比较忙没有抽出来事件维护博客真是有生以来最痛心的事情了.现在想想我的错误真的是不可思议,前一段时间接触的都是自己没有碰到过的全新的领域,然而毫无疑问的没有留下任何学习资料,我现在想起来自己真的是傻的发楞 有时间继续更新]]></content>
      <categories>
        <category>肺腑之言</category>
      </categories>
      <tags>
        <tag>肺腑之言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ssr]]></title>
    <url>%2F2018%2F04%2F19%2Fshadowsocksr%2F</url>
    <content type="text"><![CDATA[服务部署123yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用脚本：123yum -y install wgetwget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 脚本安装需要注意的有 protocol 最好选择auth_chain_a obfs(混淆) 千万不要选择tls 有被墙的风险 添加开机启动 123vim /etc/rc.localpython /usr/local/shadowsocksr/shadowsocks/server.py -c /etc/shadowsocksr/user-config.json a &amp; 加速服务(BBR) 12345wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 客户端地址windows 1https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases/download/4.7.0/ShadowsocksR-4.7.0-win.7z linux12apt-get install python-pippip install shadowsocks android1https://github.com/shadowsocks/shadowsocks-android/releases/download/v4.5.6/shadowsocks--universal-4.5.6.apk]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux定时执行任务]]></title>
    <url>%2F2018%2F04%2F18%2FSystemTimer%2F</url>
    <content type="text"><![CDATA[用户级任务1crontab -e 格式1min hour dayofmonth monthofyear dayofweek command 会进行语法检查系统级任务1nano /etc/crontab 格式1min hour dayofmonth monthofyear dayofweek user command 不会进行语法检查 共同点 配置之后需要重启crond服务1service cron restart]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux网络连接后执行脚本]]></title>
    <url>%2F2018%2F04%2F18%2FDoThingsAfterInternetConnetc%2F</url>
    <content type="text"><![CDATA[在Debian/Ubuntu的发行版本里，网络建立前、后和网络断开前、后都会到/etc/network/里运行相应目录下的脚本1234if-down.d -- 网络关闭前if-post-down.d -- 网络关闭后if-pre-up.d -- 网络建立前if-up.d -- 网络建立后 所以把自己的脚本放在/etc/network/if-up.d/目录下面就可以了]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客的美化]]></title>
    <url>%2F2018%2F04%2F11%2FButifyBlog%2F</url>
    <content type="text"><![CDATA[SEO12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在【站点配置文件】hexo_blog_config.yml 中添加如下代码。12345# hexo sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh反向代理进行内网穿透]]></title>
    <url>%2F2018%2F04%2F10%2FSSHReverseproxy%2F</url>
    <content type="text"><![CDATA[公网主机配置 修改sshd的配置文件， 1nano /etc/ssh/sshd_config 在最后面添加GatewayPorts yes,重启sshd 1service sshd restart 作用：设置反向代理的ip是0.0.0.0，而不是127.0.0.1 内网主机配置命令格式 1ssh -NfR &lt;公网端口&gt;:&lt;要代理的ip&gt;:&lt;要代理的端口&gt; &lt;用户名&gt;@公网主机ip (-i /path/to/privatekey) 123-N：ssh不执行命令-f：后台执行-R：反向代理 private key 应该时600权限查看是否启动，在公网主机上执行 1234netstat -tnl|grep &lt;公网端口&gt;tcp 0 0 0.0.0.0:&lt;公网端口&gt; 0.0.0.0:* LISTENtcp6 0 0 :::&lt;公网端口&gt; :::* LISTEN 说明执行成功 免密，稳定通道 免密在内网主机上执行 1ssh-copy-id &lt;用户名&gt;@公网主机ip 稳定通道(两种方法) autossh12apt-get install autosshautossh -M 2333 &lt;公网端口&gt;:&lt;要代理的ip&gt;:&lt;要代理的端口&gt; &lt;用户名&gt;@公网主机ip (-i /path/to/publickey) -M : 回显测试 ssh心跳包 单独客户设置（方法1）修改/etc/ssh/ssh_config，添加 12ServerAliveInterval 60ServerAliveCountMax 9999999999 服务器设置（方法二）{新客户端可以不用设置，服务器负责维护}1234sudo vim /etc/ssh/sshd_config# 添加ClientAliveInterval 30ClientAliveCountMax 6]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机算法 C++描述 第二章]]></title>
    <url>%2F2018%2F04%2F07%2FCA2%2F</url>
    <content type="text"><![CDATA[template 模板 类模板假设一个类中数据成员的数据类型不能确定。或者是某个成员函数的參数或返回值的类型不能确定。就必须将此类声明为模板，它的存在不是代表一个详细的、实际的类，而是代表着一类类。 123456template &lt;class Type&gt;class foo&#123; private: Type a;&#125; 类模板的使用 1类名&lt;实际的类型&gt; 类模板的使用实际上是将类模板实例化成一个详细的类 在类外面定义函数模板 12345template&lt;typename（或class) T&gt;&lt;返回类型&gt;&lt;函数名&gt;(參数表)&#123; 函数体&#125; 123456template&lt;typename（或class) T&gt;T fuc(T x, T y)&#123; T x; //……&#125; 模板函数 12345678910double d; int a; fuc(d,a);则系统将用实參d的数据类型double去取代函数模板中的T生成函数：double fuc(double x,int y)&#123; double x; //……&#125; 模板函数的生成就是将函数模板的类型形參实例化的过程。 队列 队列的一种有效表示方法是用数组，把他看成环形结构 判断队列为空 rear == front 队尾插入操作 rear = (++rear)%MaxSize 二叉树 引理 一棵二叉树第i层上最多结点个数为2i-1, 一个深度为k的二叉树最多节点数为2k-1 n个节点的完全二叉树可以存放在一维数组tree[n+1]中 任何一个包含n个节点的完全二叉树，如果采用上述的方法表示，对于任何下标的节点i来说，1 &lt;= i &lt;= n有： 当 i != 1 时，parent(i)在 ⌊i/2⌋。当i == 1时，i是树根没有parent 当 2i &lt;= n 时，lchild(i)在2i。如果2i &gt; n，i没有左孩子 当 2i + 1 &lt;= n 时，rchild(i)在2i+1，否则没有右孩子 二叉搜索树 特征 每个元素都有一个键值，并且没有两个元素键值相同 左子树的键值(如果有的话)都小于树根的键值 右子树的键值(如果有的话)都大于树根的键值 左右子树也都是二叉搜索树 堆(Heap) 堆性质：每个节点的值都至少与其孩子一样大（一样小） —&gt; 依次递增（减） 堆排序：这可真的是一个秀的头疼的操作。靠其自身的insert和deletemax构建新堆获得旧堆的顺序 集合与 不相交 集合的并集 用森林表示集合，每个集合都可以表示为一棵树。把孩子节点链接到父节点上 为了得到两个集合的并集，我们可以把一课树的树根的父节点域设置为另一棵树的树根( 不相交) 忽略集合的名字并且用表示集合的树的树根来标志该集合 权重规则 ： 如果以i为树根的树所包含的节点少于以j为树根的树，那么就令j成为i的父节点。否则i成为j的父节点 收缩规则 ： 如果节点j在节点i到树根的路径上，并且p[i] != root[i],那么将p[i]置为root[i]—–&gt; p[j]及路径上所有节点的父节点置为root[i] 图 图的定义和特点 欧拉定义定点的度等于与他相接的边的条数 对于有向图来说：V的入/出度是以v为头/尾的所有边的条数 当且仅当所有定点的度数都是偶数，满足这样条件的路径被成为 欧拉路径 我们通常用G=(V, E)来表示一个图 V 是有穷非空的定点的集合 E 是顶点对称的集合，又被称为边 无向图中任意边的顶点对都是无序的 (u, v) 有向图中任意边的顶点对都是有序的 ， u是头，v是尾 图不能包含定点v到自己的边。这样的边被称为自边或者自环 图不能有一条边重复多次，如果去掉这个限制那么我们得到的是多图 任意包含n个顶点的无向图的最大边数为 n(n-1)/2，包含最大边数的无向图是完全的 任意包含n个顶点的有向图的最大边数为 n(n-1) 路径的长度就是其中的边数 简单路径： 路径中可能除了第一个和最后一个都是不同的顶点（只有可能第一个和最后一个相同，其他的都不同） 环： 第一个和最后一个相同的路径 图的表示 邻接矩阵 邻接矩阵是一个n*n的矩阵 若存在边(i, j)，则a[i, j] = 1,其他的等于0 无向图的邻接矩阵是对称的 无向图上的顶点i其度数等于它对应的行之和 有向图上行之和是出度，列之和是入度 邻接表 邻接多重表]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治策略]]></title>
    <url>%2F2018%2F04%2F07%2FCA3%2F</url>
    <content type="text"><![CDATA[分治策略一般方法给定函数来计算n个输入， 分治策略 建议将输入分成k个子集，1&lt;k&lt;=n,得到k个子问题 解递归关系很多分治算法的复杂度是这样的 $$T(n)= a_{1}^n $$ 残缺棋盘描述: 有2k* 2k个方格的棋盘中恰好有一个方格是坏的 要求：用三方块把残缺棋盘铺满，三方块不能重叠，不能盖住坏的方格 —–&gt; 需要用(22k-1)/3个三方块 解决思路(分治法)： 划分成小棋盘比如4个2k-1* 2k-1，这样只有一个小棋盘有坏的 我们用一个三方块盖住没有坏方格的三个棋盘 递归 棋盘的大小缩为1*1时，递归终止 二分搜索描述： 在n个已经按升序/降序排列好的元素中搜索是否存在元素x 要求： 已经按 升序/降序 排列好]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书记录]]></title>
    <url>%2F2018%2F04%2F06%2FTheCollectOfReading%2F</url>
    <content type="text"><![CDATA[计算机类 计算机算法(C++语言描述) 第二版]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程间通信]]></title>
    <url>%2F2018%2F04%2F01%2FprocessCom%2F</url>
    <content type="text"><![CDATA[信号 由于某些错误而产生的事件 可以设定信号触发之后的处理方式，但信号是系统已经确定的12void (*signals(int signum, void(*hangdler)(int)))(int);int sigaction(int signum, const struct sigaction * act, struct sigaction * addr) 管道和命名管道实质是先进先出，半双工的数据结构，双方通信需要两个管道 管道：只能用于相互关联的进程间通信，如：父子进程 命名管道： = 特殊文件12mkfifo(const char * pathname, mode_t mode); //建立管道文件read() write() close() 均可操作 信号量主要用于控制多个线程对临界区资源的访问 消息队列将消息按队列方式组成的链表 1234int msgget(key_t key, int msgflg);int msgsnd(int msgid, const void * msgptr, int msgsz, int msgflg);int msgrcv(int msgid, const void * msgptr, int msgsz, long msgtyp, int msgflg);int msgctl(int msgid, int cmd, struct msgid_ds *buf); 共享内存直接操作内存，不用复制文件 系统创建的特殊地址空间，允许多个不相关的进程使用 1234int shmget(key_t key, int shmflg);int shmat(int shmid, const void * shmaddr, int shmflg);int shmdt(const void * shmaddr);int shmctl(int shmid, int cmd, struct shmid_ds *buf);]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程珠玑]]></title>
    <url>%2F2018%2F04%2F01%2FProgrammingPearlsKnown%2F</url>
    <content type="text"><![CDATA[编程珠玑新知识点记录第一章 开篇 位图，位向量 位向量(亦作位图，不过与图形学中的位图混淆，下作位向量)。一个n位的二进制数据，数据i如果出现在该二进制的第i位，则该位置为1，否则为0。如：用一个10位长的二进制数据表示元素都小于10的集合，{1,2,3,5,8},该集合用二进制数据的表现形式：0111010010 算法分析 初始化集合，每个位都置为0； 读入文件的每个整数，将对应的位置为1； 遍历二进制数据，如果该位为1，则输出相应的整数。 bitsetC++语言的一个类库，用来方便地管理一系列的bit位而不用程序员自己来写代码。 1234bitset&lt;N&gt;varm (M)其中varm为变量名。N表示该类型在内存中占的位数，是二进制。M表示变量varm的初始值。 相关函数 any(); //当bitset对象的一位或多个位被设置为1 时any()返回true none(); // 如果bitset 对象的所有位都被设置为0 ,则none()操作返回true count(); // count()操作返回被设置为1的位的个数. set(); //我们可以用set()操作或者下标操作符来设置某个单独的位 test(); //测试某个单独的位是否为1 test()操作。用位置做参数，返回true或false reset(); // 要将某个单独的位设置为0 ,我们可以用reset()或下标操作符 wc -l/c/w filename 统计文件行/字节/字数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux关机前执行脚本]]></title>
    <url>%2F2018%2F03%2F31%2FDOBeforeShutdownInLinux%2F</url>
    <content type="text"><![CDATA[建立关机需要执行的脚本文件1sudo vim /etc/init.d/K99shutdownbefore.sh K99文件名用来保证运行优先级 赋予执行权限 1sudo chmod +x /etc/init.d/K99shutdownbefore.sh 创建关机和重启软连接 12sudo ln -s /etc/init.d/K99shutdownbefore.sh /etc/rc0.d/K99shutdownbeforesudo ln -s /etc/init.d/K99shutdownbefore.sh /etc/rc6.d/K99shutdownbefore]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言大坑]]></title>
    <url>%2F2018%2F03%2F24%2Fa_bigHole_ofC%2F</url>
    <content type="text"><![CDATA[接下来就开始看看坑 单引号表示表示整数值 双引号表示字符串首的地址 以0开头的整数默认为八进制 注意使用移位运算加快程序执行速度 if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致 a[i] = i[a] C语言的不对称边界 errno 外部出错变量，可以检测出错信息 break 跳出离他最近的那层循环或switch C 语言不能省略形参，即使不使用 C语言的数据存储空间 程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆） 局部变量在return之后出栈销毁，不要尝试返回局部指针地址 堆 申请、释放原则 哪儿申请哪儿释放 记得判断 堆 申请成功与否 一个程序将操作系统分配给其运行的内存块分为4个区域： (1)代码区，存放程序的代码，即程序中的各个函数代码块。 (2)全局数据区，存放程序的全局数据和静态数据。 (3)堆区，存放程序的动态数据。 (4)栈区，存放程序的局部数据，即各个函数中的数据。 强制类型转换 占用空间大的转化为占用空间小的： 考虑字节序（大小端），所使用的部分可能在不同机器上截然不同 占用空间小的转化为占用空间大的： 考虑内存越界访问 结构体强制转换 ： 考虑字节对齐 字符串 通过索引读取字符串时，一定要判断索引的正确性 多线程编程 互斥量用来对临界区的互斥进入 条件变量用于线程的阻塞等待 指针 12345int * p = NULL;&amp;p 表示p的地址p 表示变量p的内容*p 表示p指向的存储单元的内容 数字0是唯一能输给指针的数值(相当于NULL) void * :指向任何类型的指针 注意深复制和浅复制的区别浅复制12345int *p, *q;*p = 58;q = p; // q 和 P 指向同一内存单元free(q);printf(&quot;%d\n&quot;,p); //异常。p的内存已经被q释放 动态变量 在程序运行过程中产生的变量称为动态变量 创建 123int * p; char *q;p = new int; // 在内存中创建一个变量，存储所分配的内存地址到p中q = new char[19]; // 在内存中创建一个数组，并将数组地址存储到q中 使用 12*p = 28;*q = &quot;hello&quot;; 销毁 12delete p;delete [] q; 动态数组 创建 12int *p;p = new int[10]; 使用 123* p = 25; //25存到第一个存储空间里 = p[0] = 25；p ++;* p = 35; //35存到第二个存储空间里 = p[1] = 35；]]></content>
  </entry>
  <entry>
    <title><![CDATA[sizeof与strlen的区别]]></title>
    <url>%2F2018%2F03%2F11%2Fsizeofstrlen%2F</url>
    <content type="text"><![CDATA[sizeof是一个操作符,结果类型是size_t，它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小.而strlen是一个库函数,使用需要包含头文件. sizeof的参数可以是数据类型或变量,而strlen函数只能以结尾为’\0’的字符串的作为参数. sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数 编译器在编译的时候就计算出了sizeof的结果.而strlen函数必须在运行的时候才能计算出来. sizeof计算的是数据类型占用的内存的大小,而strlen计算的字符串实际的长度,不包括’\0’; 数组作为sizeof的参数不会退化,而作为strlen的参数的时候会退化为一个字符指针.]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F03%2F04%2Fcsu%2F</url>
    <content type="text"><![CDATA[http://123.206.64.174]]></content>
  </entry>
  <entry>
    <title><![CDATA[Qt mysql 数据库找不到]]></title>
    <url>%2F2018%2F03%2F04%2FQt_mysqlDriver%2F</url>
    <content type="text"><![CDATA[12QSqlDatabase: QMYSQL driver not loadedQSqlDatabase: available drivers: QSQLITE QMYSQL QMYSQL3 QODBC QODBC3 QPSQL QPSQL 7 原因： 应用程序找不到libmysql.dll解决方法： 把libmysql.dll 放在.exe应用程序运次的同目录下 比如在debug时，放在debug的目录下面； release时，放在release的目录下面]]></content>
      <categories>
        <category>qt</category>
      </categories>
      <tags>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache2跨域]]></title>
    <url>%2F2017%2F12%2F15%2Fapache2cors%2F</url>
    <content type="text"><![CDATA[加载服务器组件1a2enmod headers 修改服务器配置 在想要可以跨域访问的目录下 Header set Access-Control-Allow-Origin * 重启服务器1service apache2 restart]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qt使用mysql]]></title>
    <url>%2F2017%2F12%2F13%2Fqtmysql%2F</url>
    <content type="text"><![CDATA[Qt使用mysql虽然qt自己编译生成了libmysqlclient.so,但是这个文件还依赖于系统的libmysqlclient.so.18，但是很多主机都没有安装这个 查看缺少的文件12cd /the/path/to/libmysqlclient.soldd libmysqlclient.so 下载 1https://dev.mysql.com/downloads/connector/c/ 复制 1cp libmysqlclient.so.18 /usr/lib 使用重新编译工程并使用]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卸载python安装的模块]]></title>
    <url>%2F2017%2F12%2F02%2Fuinstallpythonmodules%2F</url>
    <content type="text"><![CDATA[pip 使用pip安装的可以用pip卸载 1pip uinstall *** easy_install 使用easy_install安装的可以用easy_install卸载 1easy_install -m PackageName setup.py 通过发行包附带的setup.py安装的模块，首选setup.py提供的uninstall选项。如果作者没有提供uninstall选项，则通过如下命令行手动卸载： 12345671. python setup.py install --record files.txt2. 创建del.sh脚本内容 #!/bin/bash for i in $(less files.txt) do rm -rf $i done3. 执行脚本]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh美化终端]]></title>
    <url>%2F2017%2F11%2F21%2Fzsh%2F</url>
    <content type="text"><![CDATA[本文仅仅为了提升装逼技能不想装的可以关掉了 安装 1apt install zsh 安装on-my-zsh配置zsh 1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 切换终端 1chsh -s /usr/bin/zsh 重启机器 1reboot 问题 zsh没有导入npm的环境123nano ~/.zshrcexport PATH=&quot;$PATH:/path/to/your/npm/bin&quot;source ~/.zshrc 备注 换回bash 1exec bash 切换到zsh 1exec zsh]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04不能访除系统以外的硬盘]]></title>
    <url>%2F2017%2F11%2F16%2Fubuntu_can_not_use_harddrive%2F</url>
    <content type="text"><![CDATA[12sudo apt install ntfsfixsudo ntfsfix /dev/sdb1]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux, ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04 安装websploit]]></title>
    <url>%2F2017%2F11%2F16%2Fhow_to_install_websploit_on_ubuntu%2F</url>
    <content type="text"><![CDATA[高效中间人攻击框架 安装依赖 12sudo apt-get install scapysudo apt install apache2 //for exploit/browser_autopwn 安装 123wget https://launchpad.net/ubuntu/+archive/primary/+files/websploit_3.0.0-1_all.deb在桌面环境下双击即可安装 验证 1websploit]]></content>
      <categories>
        <category>websploit</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu搭建交叉编译环境]]></title>
    <url>%2F2017%2F11%2F15%2Fubuntu-arm%2F</url>
    <content type="text"><![CDATA[1.* mixed implicit and normal rules: deprecated syntax 修改Makefile 452 修改后： %config: scripts_basic outputmakefile FORCE]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ci library]]></title>
    <url>%2F2017%2F11%2F15%2Fci-library%2F</url>
    <content type="text"><![CDATA[调用时库名必须全部小写]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F11%2F15%2Fgit%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122git push origin 本地分支名:远程分支名git pull &lt;远程主机&gt; &lt;远程分支&gt;:&lt;本地分支&gt;git branch 不带参数：列出本地已经存在的分支，并且在当前分支的前面加“*”号标记git checkout BRANCH_ID 切换分支git branch -r 列出远程分支git branch -agit branch name 新建分支git branch -d | -D branchname 删除branchname分支git branch -d -r branchname 删除远程branchname分支git loggit log --statgit diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HEREgit diff --name-status OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HEREgit checkout COMMIT_ID 版本回退git stash list 查看堆栈情况git stash 将当前工作压栈git stash pop stash$&#123;id&#125; 弹出工作栈git stash clear 清除栈]]></content>
  </entry>
  <entry>
    <title><![CDATA[集成库的学习]]></title>
    <url>%2F2017%2F11%2F15%2Flib_int%2F</url>
    <content type="text"><![CDATA[区别个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误 记录 在PCB library和SCH library里面可以更改器件的名字 在model manager里面进行原理图元器件和PCB元器件的映射 board insight提供了PCB图观察的各种视图 同时布多条线，放置—–交互式多跟布线]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>AD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux下arm-none-linux-gnueabi交叉编译环境的建立]]></title>
    <url>%2F2017%2F11%2F05%2Farm-none-linux-gnueabi%2F</url>
    <content type="text"><![CDATA[arm-none-linux-gnueabi-gcc下载 1http://www.veryarm.com/arm-none-linux-gnueabi-gcc 解压文件 设置路径本人下载解压版,所以设置一下环境变量1sudo nano /etc/bash.bashrc 在最后面添加1export PATH=$PATH:/path/to/arm-none-linux-gnueabi-gcc/bin 执行1source /etc/bash.bashrc 验证1arm-none-linux-gnueabi-gcc -v 出现版本号则说明安装成功]]></content>
      <categories>
        <category>linux交叉编译</category>
      </categories>
      <tags>
        <tag>ARM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix环境高级编程]]></title>
    <url>%2F2017%2F10%2F26%2Funix3%2F</url>
    <content type="text"><![CDATA[第四章 文件和目录 文件类型包括 普通文件 目录文件 块特殊文件 提供对设备带缓冲的访问，每次访问以固定的长度为单位进行 字符特殊文件 不带缓冲，长度可变系统中的所有设备要么是字符特殊文件要么是块特殊文件 FIFO（命名管道），用于进程间通信 套接字 符号链接 对于目录的读权限和执行权限是不一样的，读权限允许读目录，获得在该目录中所有文件名的列表。对目录的执行权限使我们可通过该目录（也就是搜索该目录 ，寻找一个特定的文件名）删除一个现有文件，必须对包含该文件的目录拥有写和执行权限，对文件本身不要求 内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时进程也希望用实际用户id和实际组id进行测试 unix系统大多数用户从不处理他们的umask（文件模式创建屏蔽字）值。通常在登陆的时候由shell设置一次然后再不改变 chmod 更新的是i节点的修改时间（状态更改时间），系统的排序方式是修改文件内容的时间（修改时间） ls查看得到文件，cat却找不到的时候一般是符号连接，ls -l/-f 查看 对于目录通常至少要设置一个执行权限位，以允许该目录中的文件名]]></content>
      <categories>
        <category>unix</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix环境高级编程]]></title>
    <url>%2F2017%2F10%2F21%2Funix2%2F</url>
    <content type="text"><![CDATA[第3章 文件IO unix系统shell把文件描述符0与进程的标准输入关联，文件描述符1与进程的标准输出关联 open和 openat函数返回的文件描述符一定是最小的未用的描述符数值 3.1ISO C中void *表示通用指针 文件偏移量可以大于当前文件的长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，位于文件中但没有写过的字节都被读为0 123STDIN_FILENO 标准输入STDOUT_FILENO 标准输出STDERR_FILENO 标准错误 unix支持在不同进程之间共享打开文件 内核使用三种数据结构表示打开文件 每个进程在进程表中都有一个记录项 文件描述符标志 指向一个文件表项的指针 内核为所有打开文件维持一张文件表，包含 文件标志状态 当前文件偏移量 指向文件v节点表项的指针 每个打开文件或设备都有一个v节点结构 文件类型 对文件进行各种操作的函数指针 大多数文件都有i节点（索引节点） 包含了文件的所有者，文件长度，指向文件实际数据块在磁盘上所在位置的指针 在unix系统中，通常write只是将数据排入队列，而实际的写磁盘操作可能在以后的某个时刻进行。而数据库系统需要使用O_SYVN，这样一来，当它从write返回的时候数据就已经写到磁盘上了 打开文件/dev/fd/n等效于复制描述符n（假设n是打开的）]]></content>
      <categories>
        <category>unix</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unix环境高级编程]]></title>
    <url>%2F2017%2F10%2F19%2Funix1%2F</url>
    <content type="text"><![CDATA[第一章 unix基础知识 unix的口令文件在/etc/passed 登录项由7个冒号分割的字段组成，依次是登录名，加密口令，数字用户ID,数字组ID,注释字段，起始目录(/home/usr/),shell 程序 只有斜线和空字符不能出现在文件名 创建新目录时自动创建 点和点点文件 按照惯例，每当运行一个新的程序时，所有的shell都为其打开三个文件描述符，即标准输入，标准输出和标准错误12ls &gt; file.list将标准输出重定向到file.list]]></content>
      <categories>
        <category>unix</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派上搭建python脸部识别环境]]></title>
    <url>%2F2017%2F10%2F10%2FfaceRecognize%2F</url>
    <content type="text"><![CDATA[更新 12sudo apt updatesudo apt upgrade 设置树莓派 1sudo raspi-config 开启摄像头 gpu memory 设置为16 安装依赖 12345678910111213141516171819202122sudo apt-get install build-essential \ cmake \ gfortran \ git \ wget \ curl \ graphicsmagick \ libgraphicsmagick1-dev \ libatlas-dev \ libavcodec-dev \ libavformat-dev \ libboost-all-dev \ libgtk2.0-dev \ libjpeg-dev \ liblapack-dev \ libswscale-dev \ pkg-config \ python3-dev \ python3-numpy \ python3-pip \ zipsudo apt-get clean 安装python的摄像头操作模块 12sudo apt-get install python3-picamerasudo pip3 install --upgrade picamera[array] 暂时增大交换内存 12345sudo nano /etc/dphys-swapfile&lt; change CONF_SWAPSIZE=100 to CONF_SWAPSIZE=1024 and save / exit nano &gt;sudo /etc/init.d/dphys-swapfile restart 下载安装dlib 1234mkdir -p dlibgit clone -b &apos;v19.6&apos; --single-branch https://github.com/davisking/dlib.git dlib/cd ./dlibsudo python3 setup.py install --compiler-flags &quot;-mfpu=neon&quot; 安装face_recognition 1sudo pip3 install face_recognition 恢复交换内存 12345sudo nano /etc/dphys-swapfile&lt; change CONF_SWAPSIZE=1024 to CONF_SWAPSIZE=100 and save / exit nano &gt;sudo /etc/init.d/dphys-swapfile restart]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cameraOnRaspberry]]></title>
    <url>%2F2017%2F10%2F10%2FcameraOnRaspberry%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041raspistill -o image.jpg 常用命令： # 两秒钟（时间单位为毫秒）延迟后拍摄一张照片，并保存为 image.jpg raspistill -t 2000 -o image.jpg # 拍摄一张自定义大小的照片。 raspistill -t 2000 -o image.jpg -w 640 -h 480 # 降低图像质量，减小文件尺寸 raspistill -t 2000 -o image.jpg -q 5 # 强制使预览窗口出现在坐标为 100,100 的位置，并且尺寸为宽 300 和高 200 像素。 raspistill -t 2000 -o image.jpg -p 100,100,300,200 # 禁用预览窗口 raspistill -t 2000 -o image.jpg -n # 将图像保存为 PNG 文件（无损压缩格式，但是要比 JPEG 速度慢）。注意，当选择图像编码时，文件扩展名将被忽略。 raspistill -t 2000 -o image.png –e png # 向 JPEG 文件中添加一些 EXIF 信息。该命令将会把作者名称标签设置为 Dreamcolor，GPS 海拔高度为 123.5米。 raspistill -t 2000 -o image.jpg -x IFD0.Artist=Dreamcolor -x GPS.GPSAltitude=1235/10 # 设置浮雕风格图像特效 raspistill -t 2000 -o image.jpg -ifx emboss # 设置 YUV 图像的 U 和 V 通道为指定的值（128:128 为黑白图像） raspistill -t 2000 -o image.jpg -cfx 128:128 # 仅显示两秒钟预览图像，而不对图像进行保存。 raspistill -t 2000 # 间隔获取图片，在 10 分钟（10 分钟 = 600000 毫秒）的时间里，每 10 秒获取一张，并且命名为 image_number_1_today.jpg，image_number_2_today.jpg... 的形式。 raspistill -t 600000 -tl 10000 -o image_num_%d_today.jpg # 获取一张照片并发送至标准输出设备 raspistill -t 2000 -o - # 获取一张照片并保存为一个文件 raspistill -t 2000 -o - &gt; my_file.jpg]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ftp_raspberry]]></title>
    <url>%2F2017%2F10%2F10%2Fftp_raspberrry%2F</url>
    <content type="text"><![CDATA[ftp配置1234567891011sudo apt-get install vsftpdsudo nano /etc/vsftpd.conf#推荐以下配置# 不允许匿名访问anonymous_enable=NO# 设定可以进行写操作write_enable=YES# 设定本地用户可以访问local_enable=YESascii_upload_enable=YESascii_download_enable=YES 1sudo service vsftpd restart 重启服务]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[uart_raspberry]]></title>
    <url>%2F2017%2F10%2F10%2Fuart_raspberry3B%2F</url>
    <content type="text"><![CDATA[串口配置1sudo raspi-config 123interfacedisable shell and enable hardware 禁用蓝牙 1echo &quot;dtoverlay=pi3-disable-bt&quot; &gt;&gt; /boot/config.txt 禁用串行控制台 串行控制台就是从串口登录树莓派，打开/boot/cmdline.txt 1234#dwc_otg.lpm_enable=0 console=tty1 console=serial0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet splash plymouth.ignore-serial-consolesdwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline fsck.repair=y 注意:打开第一句就是打开串口命令行]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[StartWithBoot]]></title>
    <url>%2F2017%2F10%2F10%2Fstartwithboot%2F</url>
    <content type="text"><![CDATA[定时任务的方法是使用cron和crontab。 开机自启动任务树莓派开机启动任务是由rc.local控制的1sudo nano /etc/rc.local 在注释后面添加命令，但是要保证exit 0这行代码在最后，然后保存文件退出。 注意如果你的命令需要长时间运行（例如死循环）或者运行后不能退出，那么你必须确保在命令的最后添加“&amp;”符号让命令运行在其它进程.]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AutoStartInUbuntuMate]]></title>
    <url>%2F2017%2F10%2F10%2FAutoStartInUbuntuMate%2F</url>
    <content type="text"><![CDATA[只有登录之后ubuntu mate才会联网1sudo nano /usr/share/lightdm/lightdm.conf.d/60-lightdm-gtk-greeter.conf file 在文件末尾添加1[SeatDefaults] greeter-session=lightdm-gtk-greeter autologin-user=username]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysqlInstallation]]></title>
    <url>%2F2017%2F10%2F10%2FmysqlInstallation%2F</url>
    <content type="text"><![CDATA[问题阐述最近mysql进行了大面积的更新,内置的数据库存储器换成了mariaDB,但是大公司的更新怎么会没有大坑呢,他们更新完之后在安装过程中不会让你设置root用户的密码,但是密码在哪儿呢,据说是在某个文件里存着(当然这是PC机的特权). 方法步骤 删除数据库文件 1rm -r /etc/mysql 安装 1spt install mysql_server 初始化数据库(先别在里面设置root用户的密码) 1mysql_secure_installation 登录数据库 1sudo mysql -u root -p 大坑标注:必须使用sudo,不使用su权限根本进不去,默认是空密码(对于树莓派) 删除原有的root用户 1DROP USER &apos;root&apos;@&apos;localhost&apos;; 创建root账户(先别设置密码) 1CREATE USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;&apos;; 设置root用户权限(设置密码) 1GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;; 刷新权限表 1FLUSH PRIVILEGES; 多说一句5.6步如果省略就算更改密码之后也只能用su权限链接,删除重新添加之后就所有用户都可以链接了(迷)]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派连接隐藏wifi]]></title>
    <url>%2F2017%2F09%2F30%2FraspberryWifi%2F</url>
    <content type="text"><![CDATA[编辑wifi文件 1sudo nano /etc/wpa_supplicant/wpa_supplicant.conf 在该文件最后添加下面的话 12345network=&#123; ssid="WIFINAME" scan_ssid=1 psk="password"&#125; 重启]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo个人博客的搭建]]></title>
    <url>%2F2017%2F09%2F30%2Fblogofhexo%2F</url>
    <content type="text"><![CDATA[搭建 最讨厌的就是原封不动的抄别人,所以我直接用别人的1http://hifor.net/2015/07/01/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-hexo-github/ 备注: window10/windows8/Linux 均可以搭建在本地进行测试在source目录下面新建CNAME文件,内容为自己独立的域名在弄完解析之后就可以通过自己的域名访问了 markdown 书写语法 1http://www.jianshu.com/p/q81RER sublime text markdown 插件 1http://www.jianshu.com/p/aa30cc25c91b 写作 在./source/_posts里面新建.md文件,用markdown语法写文件 更新到git pages 12341. hexo clean #清除hexo缓存2. hexo g #产生静态文件3. hexo s #开启本地服务器以供测试4. hexo d #将网站上传到git,进行远程使用 使用分类和标签功能 新建分类1hexo new page categories 执行完之后会在source/categories里面生成index.md里面的内容应该完善为 12345---title: 未分类date: 2017-09-30 13:28:39type: "categories"--- 新建标签1hexo new page tags 执行完之后会在source/tags里面生成index.md里面的内容应该完善为 12345---title: 未分类date: 2017-09-30 13:28:39type: "tags"---]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu mate 在树莓派上的应用]]></title>
    <url>%2F2017%2F09%2F30%2Fraspberry_ubuntumate%2F</url>
    <content type="text"><![CDATA[下载安装系统,并启动 系统默认没有开启ssh,所以要新建文件以开启sshwindows用户可以打开powershell进入SD卡根目录,执行 1new-item ssh -type file 开机 开机配置过程基本上跟ubuntu没有什么区别,选择wifi同步升级软件,检测键盘布局之类的. 接下来就是配置无线以及有线网络,方便没有HDMI显示器的环境下使用 重启 没有链接到网络,后来发现ubuntu mate在启动后会停留在输入密码登录的界面 自动登录 1https://ubuntu-mate.community/t/enable-automatic-login-in-ubuntu-mate-16-04-for-raspberry-pi-3/5679/4]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成库的学习]]></title>
    <url>%2F2017%2F06%2F13%2Finitlib%2F</url>
    <content type="text"><![CDATA[区别个人感觉集成库与其他的区别就是集成库同时包含了原理图库和PCB库，在换了开发环境（比如换电脑）之后不会出现各种元器件找不到的错误 记录 在PCB library和SCH library里面可以更改器件的名字 在model manager里面进行原理图元器件和PCB元器件的映射 board insight提供了PCB图观察的各种视图 同时布多条线，放置—–交互式多跟布线]]></content>
      <categories>
        <category>altium designer</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[这是一个长期学习的记录]]></title>
    <url>%2F2017%2F06%2F12%2Frecord-of-long-time-learning%2F</url>
    <content type="text"><![CDATA[学习记录 Altium Desinger FPGA—–quartus C++——STL]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cordova开发安卓]]></title>
    <url>%2F2017%2F04%2F17%2Fcordova-android%2F</url>
    <content type="text"><![CDATA[cordova 命令123456cordova create hello com.example.hello HelloWorldcordova platform add android/ios/browser --savecordova build &lt;ios/android&gt;cordova run &lt;ios/android&gt;cordova plugin add cordova-plugin-cameracordova plugin add cordova-plugin-camera]]></content>
      <categories>
        <category>安卓</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机算法 C++描述]]></title>
    <url>%2F2017%2F04%2F17%2FComputerAlgorithms%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>计算机算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c_multipthread]]></title>
    <url>%2F2017%2F04%2F17%2Fc-multipthread%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;unistd.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/time.h&gt;#include &lt;string.h&gt;#define MAX 10pthread_t thread[2];pthread_mutex_t mut;int number=0, i;void *thread1()&#123; printf (&quot;thread1 : I&apos;m thread 1\n&quot;); for (i = 0; i &lt; MAX; i++) &#123; printf(&quot;thread1 : number = %d\n&quot;,number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(2); &#125; printf(&quot;thread1 :主函数在等我完成任务吗？\n&quot;); pthread_exit(NULL);&#125;void *thread2()&#123; printf(&quot;thread2 : I&apos;m thread 2\n&quot;); for (i = 0; i &lt; MAX; i++) &#123; printf(&quot;thread2 : number = %d\n&quot;,number); pthread_mutex_lock(&amp;mut); number++; pthread_mutex_unlock(&amp;mut); sleep(3); &#125; printf(&quot;thread2 :主函数在等我完成任务吗？\n&quot;); pthread_exit(NULL);&#125;void thread_create(void)&#123; int temp; memset(&amp;thread, 0, sizeof(thread)); //comment1 /*创建线程*/ if((temp = pthread_create(&amp;thread[0], NULL, thread1, NULL)) != 0) //comment2 printf(&quot;线程1创建失败!\n&quot;); else printf(&quot;线程1被创建\n&quot;); if((temp = pthread_create(&amp;thread[1], NULL, thread2, NULL)) != 0) //comment3 printf(&quot;线程2创建失败&quot;); else printf(&quot;线程2被创建\n&quot;);&#125;void thread_wait(void)&#123; /*等待线程结束*/ if(thread[0] !=0) &#123; //comment4 pthread_join(thread[0],NULL); printf(&quot;线程1已经结束\n&quot;); &#125; if(thread[1] !=0) &#123; //comment5 pthread_join(thread[1],NULL); printf(&quot;线程2已经结束\n&quot;); &#125;&#125;int main()&#123; /*用默认属性初始化互斥锁*/ pthread_mutex_init(&amp;mut,NULL); printf(&quot;我是主函数哦，我正在创建线程，呵呵\n&quot;); thread_create(); printf(&quot;我是主函数哦，我正在等待线程完成任务阿，呵呵\n&quot;); thread_wait(); return 0;&#125; 编译指令1gcc -o thread_example thread_example.c -lpthread ubuntu下面-plthread 选项要放在最后面]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[random]]></title>
    <url>%2F2017%2F03%2F26%2Frandom-1%2F</url>
    <content type="text"><![CDATA[还是太年轻了，投入的越深越容易受伤，道不同不相为谋。 正好最近一段时间可以不用应付各种东西，好好做自己该做的事，别让以后的自己成为现在讨厌的人。 见贤思齐，见不贤自省。修身养性。积极面对事情，没想象中那么脆弱，好好跟各种老师相处。调节自己的心情，不能乱发脾气，尽量做一个不说别人坏话，不当面发脾气的人 你的身体是你的本钱，请你自己珍惜。自己不能再找借口不锻炼了，其实你明确的知道你的身体状况。 你对别人好，别人才能对你好 加油，你可以自己调节。给自己每天说一个晚安]]></content>
      <categories>
        <category>未分类</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ajax跨域]]></title>
    <url>%2F2017%2F02%2F15%2Fajax-access%2F</url>
    <content type="text"><![CDATA[`var url = “http://www.huhaobin.cn/yiban/Email/send“; $.ajax({ type: “GET”, url: url, data: $(“#ContactForm”).serialize(), headers: { ‘Access-Control-Allow-Origin’: ‘*’ }, success: function confirm(data) { console.log(data); alert(‘你的老板已经看见了’); }, error: function del(){ alert(‘你的老板没收到’); } });` 跨域要加header,并且注意只能用get]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器操作规范]]></title>
    <url>%2F2016%2F12%2F15%2FserverOption%2F</url>
    <content type="text"><![CDATA[要求入门Linux：鸟哥的Linux私房菜.基础学习篇（第三版）个人认为鸟哥的这本书是一本非常好的入门书 熟悉至少一个内置编辑器: vi, nano 至少熟悉一个发行版(或系列)，建议作为服务器常用的如Centos, Debian, Ubuntu，可以了解多个常用发行版 个人使用/开发尽量在Linux上 熟悉windows与linux之间相连接的工具.vnc，winscp,xshell.熟悉ssh工具及配置 服务器配置安装部分：熟悉最常用 的ftp,http,php,apache,dns,mail的一般配置方法。 危险操作前一定要备份（操作均需要备份）1234rm -rf dir/filename– kill -9 pid– 数据库相关 （delete，drop，truncate） 操作前一定备份数据）– 系统或软件从官方渠道下载 禁用目录浏览，敏感文件数据禁止放在web目录下面 （包括svn，cvs版本控制的文件） 账号非必要情况下，以非root用户登录操作 密码建议自己备份，但不要外漏。 若有修改密码的需求则报告给组长，等组长回复 端口 限制端口访问机器 禁止修改登录端口 监控 开启监控 比如开启监控日志，nginx，apache默认自带开启日志 学会查看日志解决问题 数据库 学会最基本的sql语言（增删查改） 绑定内网ip 设置登录密码 删除默认数据库及用户 新建mysql用户和组，相关权限给到mysql用户 库，表级别操作慎重 代码更新git 服务器更新 可以访问外网的服务器：配置ssh key，使用git pull 不能访问外网的服务器 12345678910111213git loggit log –statgit diff –name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HEREgit diff –name-status OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HEREM : modifyA : ADDD : DELETE 在每个项目的根目录下面的update.txt文件里添加写入 1操作人姓名-电话-邮箱-修改日期-git版本号 更新完成之后一定要多访问几次确保没有出问题 所有的服务更新完需要重启 建议更新时间选在访问人数较少的深夜 实用技巧 导出最后一次提交修改过的文件 1git archive -o ../updated.zip HEAD git diff --name-only HEAD^ 导出两次提交之间修改过的文件 1git archive -o ../latest.zip NEW_COMMIT_ID_HERE git diff --name-only OLD_COMMIT_ID_HERE NEW_COMMIT_ID_HERE 退出 windows：注销（禁止使用关闭） linux：logout(禁止使用shut down)]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>服务器操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell]]></title>
    <url>%2F2016%2F12%2F15%2Fshell%2F</url>
    <content type="text"><![CDATA[shell编程注意,尽量不要用空格做格式控制符 开头要用 指明解释器 1#!/bin/bash 每句话不用封号结尾 变量的定义不用$符,但是引用要用$符,引用的时候要注意有无大括号 删除变量的时候不用$符5. 1234567$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$* 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(&quot; &quot;)包含时，与 $* 稍有不同$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 #替换 转义替换（用-e 来禁止zhuanyi转义） 123456789下面的转义字符都可以用在 echo 中：&amp;#092; 反斜杠a 警报，响铃b 退格（删除键）f 换页(FF)，将当前位置移到下页开头n 换行r 回车t 水平制表符（tab键）v 垂直制表符 123456$&#123;var&#125; 变量本来的值$&#123;var:-word&#125; 如果变量 var 为空或已被删除(unset)，那么返回 word，但不改变 var 的值。$&#123;var:=word&#125; 如果变量 var 为空或已被删除(unset)，那么返回 word，并将 var 的值设置为 word。$&#123;var:?message&#125; 如果变量 var 为空或已被删除(unset)，那么将消息 message 送到标准错误输出，可以用来检测变量 var 是否可以被正常赋值。若此替换出现在Shell脚本中，那么脚本将停止运行。$&#123;var:+word&#125; 如果变量 var 被定义，那么返回 word，但不改变 var 的值。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言大坑]]></title>
    <url>%2F2016%2F11%2F21%2Fc-exam%2F</url>
    <content type="text"><![CDATA[接下来就开始看看坑 单引号表示表示整数值 双引号表示字符串首的地址 以0开头的整数默认为八进制 按位与、按位或、或运算、与运算 注意使用移位运算加快程序执行速度 if(a&lt;b == c&lt;d) //比较a、b、c、d的相对大小关系是否一致 a[i] = i[a] C语言的不对称边界 errno 外部出错变量，可以检测出错信息 break 跳出离他最近的那层循环或switch]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2F2016%2F11%2F17%2Ffile%2F</url>
    <content type="text"><![CDATA[代码：https://github.com/saber110/C_review 操作函数 fopen(filename,method) method:r,w,a,rb,wb,ab,r+,w+,a+,rb+,wb+,ab+ eg: if((fp = fopen(filename,”w”))==NULL)//判断是否打开成功 fclose(filepointer) return: success : 0,fail : EOF(即-1) ch = fgetc(fp) return : fail : EOF fputc(ch,fp) return : fail : EOF fof(fp) return : 文件结尾时返回0 fgets(str,n,fp) remark : 从fp读入一个长度为n-1的字符串并存放到str return : success : str地址 fail : NULL fputs(str,fp) remark : 把str的内容读到fp指向的文件 return : success : 0,fail : !0 fread(buffer, size, count, fp) fwrite(buffer, size, count, fp) remark : buffer : 要读入或输出的数据的地址 size : 要读写的字节书 count : 要读写的数据项个数(每个数据项的长度为size) return : success : 1 rewind(fp) remark : 将指针位置返回到开头，无返回值 fseek(fp,offset,type) para : type : 0—文件开始位置，1—当前位置，2—文件结束位置 出错检测 ferror(fp) return : 未出错为0，出错不为0 一定要调用clearerr(fp)清掉报错]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2016%2F11%2F14%2Fpointer%2F</url>
    <content type="text"><![CDATA[代码：https://github.com/saber110/C_review `&lt;/pre&gt; # 初始化 ’*‘ 表示对应地址的内容 &lt;pre&gt;` 指针变量名表示地址 `&lt;/pre&gt; ### 指针变量中只能存放地址 指针在初始化值的时候，一定要用变量的地址，在初始化完成之后可以不用地址改变指针的值 &lt;pre&gt;`int a = 200,* pointer; pointer = a; `&lt;/pre&gt; **这是不合法的** &lt;pre&gt;`int a = 200,* pointer; *pointer = a;//未进行初始化，存储单元无法预测 `&lt;/pre&gt; **这也是不合法的** &lt;pre&gt;`int a = 200,* pointer; pointer = &amp;amp;a; `&lt;/pre&gt; **这也是合法的** &lt;pre&gt;`int a = 200,* pointer; pointer = &amp;amp;a; *pointer = a;//等价于pointer = &amp;amp;a; `&lt;/pre&gt; **迷之合法** 综上，数组初始化只能有 &lt;pre&gt;`int *pointer = &amp;amp;a; 或者 int * pointer; pointer = &amp;amp;a; `&lt;/pre&gt; **两种方法** # 参数传递 不能通过改变指针形参的值而企图使指针实参的值发生改变（C语言在函数调用时只能单向值传递） 数组/指针作为形参时，传递的是对应的地址，改变形参的值可以改变实参 调用函数时形参指向实参，实际上指向同一个内存单元 如果用指针变量作为实参，指针变量必须要有具体的值，即必须指向对应已定义的对象 REMARK： 最重要的是可以改变指针的指向地址啊！！！！ 通过指针引用数组`若p-&gt;a[0],则++p-&gt;a[1] 若p-&gt;&amp;a[0]，则++p-&gt;&amp;a[1] p1,p2指向同一个数组时，p2-p1表示相差元素的个数 a[i] = *(a+i) &amp;a[i] = &amp;(a+i) ` 数组一维数组`int a[10]; 1\. *a代表a[0]的内容即a[0] 2\. a代表a[0]的地址即&amp;a[0] 3\. *(a + 1) 代表a[i]的内容 ` 多维数组`int a[10][10]; 1\. *a代表a[0][0]的内容即a[0][0] 2\. a代表a[0][0]的地址即&amp;a[0][0] 3\. *(a + 1) 代表a[i] 行 的地址 4\. *(a + 1) +1代表a[1][1]的地址，即&amp;a[1][1] 5\. *(*(a + 1) +1)代表a[1][1]的内容,即a[1][1] ` 字符指针`char *a; scanf("%d\n",a); 坚决不能使用上面这种，a的指向地址无法预测，可能会修改系统中敏感位置的值 char *a,arr[10]; a=arr; scanf("%d\n",a); 正确用法 ` 函数指针`int (p)(int x,int y);//指向返回值位int的函数指针int p(int x,int y) = int * (p(int x,int y))//返回值为指针的函数]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量]]></title>
    <url>%2F2016%2F11%2F14%2Fvarious%2F</url>
    <content type="text"><![CDATA[#存储类别 自动变量： 函数中未做特殊声明的局部变量（存储在动态存储区） 静态局部变量： 定义在函数内部，在函数运行完成后不释放空间，在下次运行时保留上次的值（存储在静态存储区） 寄存器变量： 运行次数超高的变量，用register声明，放在cpu中执行（其他的变量都在内存中） remark：在全局变量前加 static则将变量的使用范围限制在此文件中，其他文件不能通过extern进行作用域的扩展，同时，使用相同的静态外部变量名无关紧要]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回头C语言]]></title>
    <url>%2F2016%2F11%2F14%2Fstudy-c-again%2F</url>
    <content type="text"><![CDATA[1代码：https://github.com/saber110/C_review 循环12break: 跳出本层循环continue : 跳出本次循环接而执行下次循环 数组初始化 数字型数组 默认初始化为0, 字符型数组 默认初始化为’\0’（空格符）** 1234567int a[3][4] = &#123; &#123;1,2,3,4&#125;, &#123;5,6,7,8&#125;, &#123;9,10,11,12,&#125; &#125;;int a[3][4]=&#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;int a[3][4] =&#123;&#123;1&#125;,&#123;5&#125;,&#123;9&#125;&#125;; 前两种初始化的方法效果完全一致，但是前面的清晰可读推荐使用 第三种方法相当于 1234567891011a[0][0]= 1;a[1][0] = 5;a[2][0] = 9;其余元素全为0``` ### Remark初始化的时候如果确定全部元素的话可以省略一维数组的长度和二位数组的第一维长度**数组长度** char c[] = “i am a student”;sizeof(c) = 11; 12系统在后面自动添加&quot;\0&quot;表示字符串终结 (10+1) char C[5] = “CHINA”; 123456789 也是**合法**的表达 ### 数组名做形参时不会检查他的大小，当指定实参时形参指向实参的地址，实质上同在相同的内存空间# 这儿有个关于字符数组的大坑1. C语言的**字符**数组可以在初始化的时候直接赋值2. 但不可以用 str=”china”; //尝试之间赋值给已声明的字符数组strstr1 = str2; 1* 在后面要改变字符数组的内容需要使用 gets(str);strcat(str,str1);strcpy(str,str1);strncpy(str,str1,2);//将str1中的前两个字符赋值到str中```]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用ESP8266-12F Wifi模块进行通信流程]]></title>
    <url>%2F2016%2F11%2F10%2Fesp8266-12f-wifi%2F</url>
    <content type="text"><![CDATA[使用ESP8266-12F Wifi模块进行通信的套路体会###一、接线流程 在最初测试时，可使用usb转ttl串口进行接线，接线流程比较简单。将模块VCC，EN端接3.3V电源，GPIO15,GND端接地，模块TX,RX端分别接串口工具的RX,TX端，其余管脚悬空既可。 在接线过程中注意点如下。 用3.3V/800mA独立电源供电，需要共地。 保证CH_PD（EN） 也就是芯片选通脚为高电平，GPIO15(也就是MTDO)为低电平。并且CH_PD端与独立电源之间，GPIO15与地之间，需要分别连接阻值为10k的电阻。（如原理图所示）。 注：RST 引脚低电平复位，不需要可以悬空。GPIO0在下载固件时需要拉低。 ###二、调试流程 命令在后面必须要有回车发送调试使用AT指令。以下简单介绍四种模式的调试流程。 模块ap模式下做 tcp server 1234567AT+CWMODE=2或AT+CWMODE=3 //开启 AP 模式AT+RST //复位AT+CWSAP=&quot;TEST&quot;,&quot;123456789A&quot;,3,0 //设置模块的 wifi 和密码AT+CIPMUX=1 //打开多连接AT+CIPSERVER=1,8080 //1表示开启server模式，8080为端口号AT+CIPSTO=7200 //设置服务器超时时间为7200sAT+CIPSEND=0,10 //进入数据发送模式为十个字节,即可发送数据 模块sta模式下做 tcp client 12345678AT+CWMODE=1 //开启STA模式AT+RST //复位AT+CWLAP //查看附近的 wifiAT+CWJAP=&quot;TEST&quot;,&quot;123456789A&quot; //连接 wifi, 后面为密码AT+CIFSR //查看模块的分配的 ipAT+CIPMUX=1 //打开多连接AT+CIPSTART=0，&quot;TCP&quot;,&quot;192.168.4.1&quot;,8080 设置ip和端口号，发送 AT 指令去连接。AT+CIPSEND=0,10 //进入数据发送模式为十个字节,即可发送数据 模块做tcp透传 12345678910AT+CWMODE=1 //开启STA模式AT+RST //复位AT+CWLAP //查看附近的 wifiAT+CWJAP=&quot;TEST&quot;,&quot;123456789A&quot; //连接 wifi, 后面为密码AT+CIFSR //查看模块的分配的 ipAT+CIPMUX=0//设置单连接AT+CIPMODE=1//设置透传模式AT+CIPSTART=&quot;TCP&quot;,&quot;192.168.4.1&quot;,8080// 连接server端的ip和端口AT+CIPSEND //开始发送数据+++ //退出透传，此处应取消发送新行 模块做udp透传 123456789AT+CWMODE=1 //开启STA模式AT+RST //复位AT+CWLAP //查看附近的 wifiAT+CWJAP=&quot;TEST&quot;,&quot;123456789A&quot; //连接 wifi, 后面为密码AT+CIFSR //查看模块的分配的 ipAT+CIPSTART=“UDP”,&quot;255.255.255.255&quot;,8080,8080,0//建立udp连接，前8080为对方端口，后8080为模块端口AT+CIPMODE=1//设置透传模式AT+CIPSEND //开始发送数据+++ //退出透传，此处应取消发送新行 使用串口助手对单个wifi模块进行测试，注意事项如下。 配置模式为波特率：115200、数据位：8 校验位/停止位/流控：none 使用AT指令进行调试时，记住发送指令时要勾选“发送新行选项”。即指令需要换行（0x0d+0x0a） 使用两个wifi模块进行通讯形式如下。服务器与客户端进行tcp通信 按之前的步骤，将两模块分别设置成tcp server与tcp client即可实现双向通信。 该模式下，两模块间传输数据需要限定长度。 若客户端连不进服务器的热点，服务器应该执行复位指令，等待一段时间即可。 掉电后会自动退出server模式，需要重新初始化，初始化AT指令流程截图如下。 若客户端掉电，服务器未掉。上电后只初始化客户端，依然不能实现数据双向传输。服务器需要关闭server收发模式再重新开启，即可解决问题。 恢复出厂设置指令：AT+RESTORE 进行tcp透传 将一个模块设置成tcp server，另一个按照tcp透传进行调试即可。 透传只能在单连接模式下进行，所以在建立连接之前一定要用（AT+CIPMUX=0 设置单连接），但是模块处于服务器模式下时，必须要多链接，由于冲突，所以模块开启服务器模式不能做tcp透传。因此，该模式下，客户端像服务器发送数据可不限长度，服务器发送数据则需要限定长度。 其他调试方法同上。 进行udp透传 需要外界提供wifi热点 将两个wifi模块连接至统一wifi热点，按照udp透传进行调试。 对于建立udp连接的指令，如需要实现多端通信，则ip地址应输入广播域“255.255.255.255”，并需要设为同一端口。 使用单片机发送指令至wifi模块，使用uart通信协议。1.非透传模式 服务器初始化代码如下。123456789101112131415void Wifi_ServerInit() //服务器初始化&#123; printf(&quot;AT+CIPMUX=1&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10); printf(&quot;AT+CIPSERVER=1,8080&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10); printf(&quot;AT+CIPSTO=7200&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10);&#125; 客户端初始化代码如下。1234567891011void Wifi_tcp_ClientInit() //客户端初始化&#123; printf(&quot;AT+CIPMUX=1&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10); printf(&quot;AT+CIPSTART=0,&quot;TCP&quot;,&quot;192.168.4.1&quot;,8080&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10); &#125; 发送数据代码如下。12345678void Wifi_Send_Data(uint8 Id,uint8 Len,uint8 *str) //写指定长度的数据&#123; printf(&quot;AT+CIPSEND=%d,%d&quot;,Id,Len); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(1); uart_putstr(UART4,str); //数据长度满才可发送&#125; 2.UDP透传模式 客户端udp初始化123456789101112131415void Wifi_Udp_ClientInit(void)//客户端udp初始化&#123; printf(&quot;AT+CIPMUX=0&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10); printf(&quot;AT+CIPSTART=&quot;UDP&quot;,&quot;255.255.255.255&quot;,8080,8080,0&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10); printf(&quot;AT+CIPMODE=1&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10);&#125; 进入透传模式1234567void Wifi_Udp_SendData(void)//发送数据指令，进入透传&#123; printf(&quot;AT+CIPSEND&quot;); uart_putchar(UART4,0x0d); uart_putchar(UART4,0x0a); DELAY_MS(10);&#125; 退出透传模式1234void Wifi_Udp_Send_End(void)//退出透传&#123; printf(&quot;+++&quot;);&#125;]]></content>
      <categories>
        <category>智能小车</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 字蛛 压缩字体文件实现网站加速]]></title>
    <url>%2F2016%2F11%2F10%2Ffont-spider%2F</url>
    <content type="text"><![CDATA[这是一个神奇的东西个人开发的时候使用了艺术字体，由于谷歌和微软等巨头没有收录,为了缩短服务加载时间，本人找到两种方法 cdn加速，腾讯云目前进行免费cdn加速服务，但是由于使用的域名没有进行备案，所以 pass 使用字蛛 压缩所使用的字体文件 下面是坑@font-face { font-family: &apos;xixinkaijian&apos;; src:url(&apos;../fonts/xixinkaijian.eot&apos;); src: url(&apos;../fonts/xixinkaijian.eot?#font-spider&apos;) format(&apos;embedded-opentype&apos;), url(&apos;../fonts/xixinkaijian.woff&apos;) format(&apos;woff&apos;), url(&apos;../fonts/xixinkaijian.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/xixinkaijian.svg&apos;) format(&apos;svg&apos;); font-weight: normal; font-style: normal; } `&lt;/pre&gt; &lt;pre&gt;`@font-face { font-family: &apos;hycgj&apos;; src:url(&apos;../fonts/hycgj.eot&apos;); src: url(&apos;../fonts/hycgj.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/hycgj.eot?#font-spider&apos;) format(&apos;embedded-opentype&apos;), url(&apos;../fonts/hycgj.woff&apos;) format(&apos;woff&apos;), url(&apos;../fonts/hycgj.svg&apos;) format(&apos;svg&apos;); font-weight: normal; font-style: normal; } `&lt;/pre&gt; &lt;pre&gt;`@font-face { font-family: &apos;hyngj&apos;; src:url(&apos;../fonts/hyngj.eot&apos;); src: url(&apos;../fonts/hyngj.ttf&apos;) format(&apos;truetype&apos;), url(&apos;../fonts/hyngj.eot?#font-spider&apos;) format(&apos;embedded-opentype&apos;), url(&apos;../fonts/hyngj.woff&apos;) format(&apos;woff&apos;), url(&apos;../fonts/hyngj.svg&apos;) format(&apos;svg&apos;); font-weight: normal; font-style: normal; } `&lt;/pre&gt; #此处需注意font_1前面没有像平常引用地址的**小数点** &lt;pre&gt;`font_1 p { font-family: &apos;xixinkaijian&apos;; } `&lt;/pre&gt; &lt;pre&gt;`font_2 p { font-family: &apos;hycgj&apos;; } `&lt;/pre&gt; &lt;pre&gt;`font_3 p { font-family: &apos;hyngj&apos;; }]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>网站加速</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能指纹门锁开发]]></title>
    <url>%2F2016%2F11%2F09%2Fremote-lock%2F</url>
    <content type="text"><![CDATA[专业开挂二十年 需求起源 由于本人所在学校组织成员较多，然后钥匙管理就成了一个很大的问题，基本上会很频繁的发生钥匙找不到啊、钥匙被锁在办公室里面了啊等多种事情，所以萌发了这个念头。 动力 正好借着武汉黑客马拉松的借口，然后跟着我们云麓谷大佬的脚步一起去混了次比赛，当时大佬就说咱们做这个智能门锁吧。本着为组织服务，提升自身逼格的理念我们就开搞了。 艰辛的通信之路 本人在团队中充当一个硬件开发（划水）的角色，为了开发方便就直接选用了某宝的自动指纹对比模块—–PS1802指纹识别模块，树莓派开发板—–Raspberry Pi B+，usb转TTL—–CH340以及杜邦线若干。 跟据千古不变的硬件开发理念，拿到东西首先测试是否完好、功能是否异常、外观是否破损、有没有送女朋友之类的。所以诞生了如下步骤： 检查硬件连接以及货物清单。 用usb转TTL工具连接指纹模块和电脑，用老板发我的上位机进行测试，目测一切正常。（硬件测试方法和上位机试用方法都在链接里）。 既然确保硬件没问题了就可以开始开发了，选用C语言进行硬件底层开发，php调用C的接口实现高级开发和管理 。硬件使用UART[通用异步收发传输器]进行树莓派和指纹模块之间的通信 首先设置模块的通信速率为115200，加快系统响应。其次给树莓派安装wiringpi，然后开发的代码都在此处。 接下来真正来通信（接下来说到的陌生的东西都在SendUART.c里） 树莓派的官方库是不支持直接发十六进制的东西的，但是指纹模块的命令必须是十六进制才能响应。 讲默认发送的ascii转为十六进制ASCI_16() 很快就出现了新的问题，用这种方法发送的数据总是单个单个发出去 然后前面以0补足缺的位，所以还是不能成功的控制树莓派。 所以就催生了implode() 经过这样的折腾总算是能单向操作树莓派了，但是要接受树莓派回过来的消息并且确定其工作状态是一件很不容易的事情呐，由于不太熟悉wiringpi库的试用，我就分为几种接收长度的情况进行命令和数据接收（指纹模块回的指令分为命令应答、数据应答和普通应答，他们的长度不一），跟据不同的数据长度进行读取数据并且存入数组一并返回 C语言涉及到的差不多就是这些了，试用之前一定记得在树莓派上编译哦 sudo gcc SendUART.c -o SendUART -lwiringPisudo gcc close.c -o close -lwiringPi close文件是在长期加载失败之后手工关掉树莓派的uart设备的。 PHP篇 C语言写完接口之后为了更方便的给大家使用继而写了php的接口，顺便加进去了状态码用于判断指纹模块响应的正误——–本人做的工作到此结束 如果大家调用了什么不该调用的接口或者自己开发接口的时候碰到死活执行不完的情况那么请大家重启Apache sudo service apache2 restart 接下来是胡扯 搭完硬件和部署完我们的代码之后就可以在浏览器上访问树莓派的ip加我们的访问链接进行控制。 这只是一个小小的开头，现在只是局域网控制，到后面可以抽时间做一下内网穿透，然后和已有的员工信息库绑定进行更强大更智能的开发工作。 要不就先更到这儿吧 此处是代码 *]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CI上传文件文件名乱码]]></title>
    <url>%2F2016%2F10%2F25%2Fci-changecode%2F</url>
    <content type="text"><![CDATA[修改system—-libraries —–upload—–do_upload中的相对应内容为 12345678if ( ! @copy($this-&gt;file_temp, iconv(“UTF-8”, “gb2312”, $this-&gt;upload_path.$this-&gt;file_name)))&#123; if ( ! @move_uploaded_file($this-&gt;file_temp, iconv(“UTF-8”, “gb2312”, $this-&gt;upload_path.$this-&gt;file_name))) &#123; $this-&gt;set_error(‘upload_destination_error’); return FALSE; &#125;&#125; 修改同文件中的set_filename 12345678910111213141516171819202122232425262728293031323334public function set_filename($path, $filename)&#123; if ($this-&gt;encrypt_name == TRUE) &#123; mt_srand(); $filename = md5(uniqid(mt_rand())).$this-&gt;file_ext; &#125; $filename = iconv(‘UTF-8’, ‘GB2312’, $filename);//将$filename中的文件名转换为GB2312编码 if ( ! file_exists($path.$filename)) &#123; $filename = iconv(‘GB2312’, ‘UTF-8’, $filename);//将编码转回UTF-8 return $filename; &#125; $filename = str_replace($this-&gt;file_ext, ‘’, $filename); $new_filename = ‘’; for ($i = 1; $i &lt; 100; $i++) &#123; if ( ! file_exists($path.$filename.$i.$this-&gt;file_ext)) &#123; $new_filename = $filename.$i.$this-&gt;file_ext; break; &#125; &#125; if ($new_filename == ‘’) &#123; $this-&gt;set_error(‘upload_bad_filename’); return FALSE; &#125; else &#123; $new_filename = iconv(‘GB2312’, ‘UTF-8’, $new_filename);//将编码转回UTF-8 return $new_filename; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[raspberry_fingerprint]]></title>
    <url>%2F2016%2F10%2F18%2Fraspberry-fingerprint%2F</url>
    <content type="text"><![CDATA[http://www.it1352.com/216181.html http://www.docin.com/p-526335015.html sudo chown :www-data /dev/ttyAMA0 sudo chmod g+rw /dev/ttyAMA0]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fatal error Class 'ZipArchive' not found ......(linux是可以用phpexcel的)]]></title>
    <url>%2F2016%2F10%2F07%2Ffatal-error-class-ziparchive-not-found%2F</url>
    <content type="text"><![CDATA[史上最强悍的解决方案ubuntu : sudo apt-get install php7.0-zip 下面是装逼 在Linux下没有php_zip.dll这个文件（有也不会起作用的），所以需要重新编译一下php的zip模块。具体安装方法如下： 12345678cd /usr/srcwget http://pecl.php.net/get/ziptar -zxvf zipcd zip-1.x.xphpize./configuremakesudo make instal 安装完之后，屏幕上会提示zip.so的位置。然后将其记录下来，如：/usr/lib/php/20151012/zip.so 使用root权限修改php.ini（通常可能会在/usr/local/lib/文件夹下，不过视当初安装php而定，可以通过phpinfo()来查看）： 增加1extension = /usr/local/lib/php/extensions/zip.so 然后同样在php.ini文件中，将123zlib.output_compression = Off# 改为zlib.output_compression = On 最后别忘了重启一下Apache：1sudo service apache2 restart]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux配置Call to undefined function mcrypt_decrypt()+大杂烩]]></title>
    <url>%2F2016%2F10%2F05%2Flinux-call-to-undefined-function-mcrypt-decrypt%2F</url>
    <content type="text"><![CDATA[php5.4 ubuntu14.04 12$ sudo php5enmod mcrypt$ sudo service apache2 restart php7.0 ubuntu16.04 123sudo apt php-mcryptsudo phpenmod mcryptsudo service apache2 restart ubuntu安装curl 1sudo apt-get install php-curl 更改php.ini 开启curl(/etc/php/7.0/apache2/php.ini)重启apache2 1sudo service apache2 restart php gd库的安装 1sudo apt install php gd 更改php.ini 开启curl(/etc/php/7.0/apache2/php.ini)重启apache2 1sudo service apache2 restart ubuntu 开启对.htaccess的支持 1sudo a2enmod rewrite 配置/etc/apache2/apache2.conf 1234567AccessFileName .htaccess&lt;Directory /var/www/html&gt; Options Indexes FollowSymLinks MultiViews AllowOverride All Order allow,deny allow from all&lt;/Directory&gt; 1sudo service apache2 restart 6.mysql自增起始值设置1alter table users（表名） AUTO_INCREMENT=10000（起始值）; 7.ssl https配置 http://www.linuxidc.com/Linux/2015-02/113588.htm]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>大杂烩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows和linux互传文件]]></title>
    <url>%2F2016%2F10%2F05%2Fwindows-linux%2F</url>
    <content type="text"><![CDATA[给windows安装winscp 1.填写连接 2.权限问题 permission denied 可以先传到/tmp文件夹再mv 也可以直接更改目标文件夹为777]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>文件传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zhiwen]]></title>
    <url>%2F2016%2F09%2F22%2Fzhiwen%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=utf-8&gt;&lt;title&gt;css指纹效果&lt;/title&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;&lt;style&gt;.start&#123;animation-play-state:paused;position: absolute; top: 0 ;left: 0; width:100px; height: 10px; background:url(http://denghao.me/demo/2015/fingerScan/line.png) center no-repeat; background-size: 100%; -webkit-animation:act-scan 2s linear infinite alternate;&#125;.finish&#123;position: absolute; top: 0 ;left: 0; width:100px; height: 10px; background:url(http://denghao.me/demo/2015/fingerScan/line.png) center no-repeat; background-size: 100%;animation-play-state: paused;&#125;.beijing&#123;background: #009;color: #9FF;&#125;.print&#123;width: 100px; height:132px; background:url(http://denghao.me/demo/2015/fingerScan/finger.png) center no-repeat; background-size: 100%; position: relative;&#125;.print .scan&#123;position: absolute; top: 0 ;left: 0; width:100px; height: 10px; background:url(http://denghao.me/demo/2015/fingerScan/line.png) center no-repeat; background-size: 100%;-webkit-animation:act-scan 2s linear infinite alternate;animation-play-state: paused;&#125;@-webkit-keyframes act-scan&#123;0%&#123; top:0; &#125;50%&#123; top:120px; &#125;100%&#123; top:0;&#125;&#125;@keyframes act-scan&#123;0%&#123; top:0; &#125;50%&#123; top:120px; &#125;100%&#123; top:0;&#125;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body &gt;&lt;table&gt;&lt;td class=&quot;beijing&quot;&gt;&lt;div class=&quot;print&quot; &gt;&lt;div class=&quot;scan&quot; align = &quot;center&quot; id = &quot;scannow&quot; &gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/table&gt;&lt;script src=&quot;http://denghao.me/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123;var it = document.getElementById(&apos;scannow&apos;);$(&quot;.print&quot;).on(&quot;touchstart&quot;, function(event) &#123;event.preventDefault();call();it.className=&quot;start&quot;;&#125;);$(&quot;.print&quot;).on(&quot;touchend&quot;,function(event)&#123;event.preventDefault();clearInterval(timer1);&#125;);function call() &#123;timer1 = window.setTimeout(function() &#123;alert(&quot;你好啊&quot;);&#125;, 1000);document.getElementById(&apos;scannow&apos;).className=&quot;finish&quot;;&#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派语音对话]]></title>
    <url>%2F2016%2F09%2F07%2Fvoice%2F</url>
    <content type="text"><![CDATA[###代码1https://github.com/luyishisi/python_yuyinduihua ###安装环境12345678910111213sudo apt-get install python-pyaudiopip install numpy# 先安裝 curlwget http://curl.haxx.se/download/curl-7.21.3.tar.gztar xzf curl-7.21.3.tar.gz./configuremakemake install# 然後安装 pycurlwget http://pycurl.sourceforge.net/download/pycurl-7.19.0.tar.gztar xzf pycurl-7.19.0.tar.gzpython setup.py install --curl-config=/usr/local/bin/curl-config]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次涉猎Qt]]></title>
    <url>%2F2016%2F08%2F15%2Fthe-first-travel-of-qt%2F</url>
    <content type="text"><![CDATA[最近一直沉迷于智能小车无法自拔（虽然跪在了华南赛，但是热情还是有的），想当初做的是双车追逐组，当时确实是玩的挺浪。起初用ccd做双车，各种效果都不错，但是呢，老师总是说ccd识别容易出问题，迫于压力换成了摄像头（人生的三叉路口迷失了方向），十天的时间跑到了两米三，想当初也是拼哈。但是也引发了一系列的问题，最头疼的就是距离的稳定测量，由于配置了摄像头用了两个中断，其中包括一个频率很高的像素中断（大概20Us一次，必须配置成最高优先级，以防止图像抖动或发生实质性变动），这就有可能打断了距离测量的中断，这样就可能延长了距离的测量时间因此得到的数值也会变得比较大，这对距离的闭环有很大的影响，可以说都可以完全破坏距离机制。 &nbsp; 至于这个原因为什么扯到了Qt，我就说一句，Qt是个很好的上位机开发工具。 &nbsp; 刚刚学习Qt，顺便记录一点过程中比较关键的东西。 &nbsp; Qt完全跟C++相似，这也就容易上手。（完全无厘头） 一、123456789QApplicationQlabelQPushButton QObject::connectQSpinBoxaddWidget() 上下三角选值QSlideaddWidget()水平滑条 二、 Qt一共有三种主要的layout，分别是：QHBoxLayout- 按照水平方向从左到右布局；QVBoxLayout- 按照竖直方向从上到下布局；QGridLayout- 在一个网格中进行布局，类似于HTML的table。layout使用addWidget添加组件，使用addLayout可以添加子布局，因此，这就有了无穷无尽的组合方式。]]></content>
      <categories>
        <category>智能小车</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh登录腾讯云服务器]]></title>
    <url>%2F2016%2F07%2F20%2Fssh%2F</url>
    <content type="text"><![CDATA[###获取云服务器密钥登录Linux云服务器：（注：无论您电脑的操作系统是windows还是linux，都可以采用SSH密钥登录的方式远程登录linux云服务器）。 首页登录腾讯云官网的“管理中心”，接着在左侧导航栏“SSH密钥”进入SSH密钥管理界面；点击“创建密钥”按钮，输入密钥名，创建一个新密钥，创建完密钥后，点击“下载”按钮，下载私钥。 然后右键点击刚创建的密钥，绑定需要登录的服务器；绑定完服务器后，左键点击密钥，界面右侧滑出密钥详细页。如下图所示： 在密钥详细页中，将“公钥内容”复制到一个空白文本文档中，保存用户名为密钥名（即刚刚新建的密钥的名称），并修改文档后缀名为“.pub”（注：公钥名与私钥名必须相同，并且须放置在同一文件夹下）。如下图所示： 下载xshell，文件 – 新建——在主机处填写要连接的服务器的ip地址，然后点击确定 根据提示选择密钥文件（私钥），点击确定]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>腾讯云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[鸳鸯测距使用防坑]]></title>
    <url>%2F2016%2F07%2F06%2Fyuanyang%2F</url>
    <content type="text"><![CDATA[这两天使用超声波测距（鸳鸯测距）来实现双车通信，但是使用时碰到了特别多的坑，理论上来说测到的距离是一条非常平滑的线，但是在使用的时候就出现了各种波动。V4传说是180度测距，V5是360度测距，但是V4实际使用的时候只有90度左右，V5确实是360度，但是在前车的左右两旁会出现距离跳变。 实际测量的曲线如图： 上面那些波动特别有规律，一般的滤波方法根本无能为力，在探索了三天之后，得到这写滤波方法 限幅滤波法(又称程序判断滤波法) 方法:根据经验判断,确定两次采样允许的最大偏差值(设为A)每次检测到新值时判断:如果本次值与上次值之差&lt;=A,则本次值有效 如果本次值与上次值之差&gt;A,则本次值无效,放弃本次值,用上次值代替本次值 优点:能有效克服因偶然因素引起的脉冲干扰 缺点无法抑制那种周期性的干扰平滑度差 中位值滤波法 方法:连续采样N次(N取奇数)把N次采样值按大小排列取中间值为本次有效值 优点:能有效克服因偶然因素引起的波动干扰对温度、液位的变化缓慢的被测参数有良好的滤波效果 缺点:对流量、速度等快速变化的参数不宜 算术平均滤波法 方法:连续取N个采样值进行算术平均运算N值较大时:信号平滑度较高,但灵敏度较低N值较小时:信号平滑度较低,但灵敏度较高N值的选取:一般流量,N=12;压力:N=4 优点:适用于对一般具有随机干扰的信号进行滤波这样信号的特点是有一个平均值,信号在某一数值范围附近上下波动 缺点:对于测量速度较慢或要求数据计算速度较快的实时控制不适用比较浪费RAM 递推平均滤波法(又称滑动平均滤波法) 方法:把连续取N个采样值看成一个队列队列的长度固定为N每次采样到一个新数据放入队尾,并扔掉原来队首的一次数据.(先进先出原则)把队列中的N个数据进行算术平均运算,就可获得新的滤波结果N值的选取:流量,N=12;压力:N=4;液面,N=4~12;温度,N=1~4 优点:对周期性干扰有良好的抑制作用,平滑度高适用于高频振荡的系统 缺点:灵敏度低对偶然出现的脉冲性干扰的抑制作用较差不易消除由于脉冲干扰所引起的采样值偏差不适用于脉冲干扰比较严重的场合比较浪费RAM 中位值平均滤波法(又称防脉冲干扰平均滤波法) 方法:相当于“中位值滤波法”+“算术平均滤波法”连续采样N个数据,去掉一个最大值和一个最小值然后计算N-2个数据的算术平均值N值的选取:3~14 优点:融合了两种滤波法的优点对于偶然出现的脉冲性干扰,可消除由于脉冲干扰所引起的采样值偏差 缺点:测量速度较慢,和算术平均滤波法一样比较浪费RAM 限幅平均滤波法 方法:相当于“限幅滤波法”+“递推平均滤波法”每次采样到的新数据先进行限幅处理,再送入队列进行递推平均滤波处理 优点:融合了两种滤波法的优点对于偶然出现的脉冲性干扰,可消除由于脉冲干扰所引起的采样值偏差 缺点:比较浪费RAM 一阶滞后滤波法 方法:取a=0~1本次滤波结果=(1-a) 本次采样值+a 上次滤波结果 优点:对周期性干扰具有良好的抑制作用适用于波动频率较高的场合 缺点:相位滞后,灵敏度低滞后程度取决于a值大小不能消除滤波频率高于采样频率的1/2的干扰信号 加权递推平均滤波法 方法:是对递推平均滤波法的改进,即不同时刻的数据加以不同的权通常是,越接近现时刻的数据,权取得越大.给予新采样值的权系数越大,则灵敏度越高,但信号平滑度越低 优点:适用于有较大纯滞后时间常数的对象和采样周期较短的系统 缺点:对于纯滞后时间常数较小,采样周期较长,变化缓慢的信号不能迅速反应系统当前所受干扰的严重程度,滤波效果差 消抖滤波法 方法:设置一个滤波计数器将每次采样值与当前有效值比较:如果采样值＝当前有效值,则计数器清零如果采样值&lt;&gt;当前有效值,则计数器+1,并判断计数器是否&gt;=上限N(溢出)如果计数器溢出,则将本次值替换当前有效值,并清计数器 优点:对于变化缓慢的被测参数有较好的滤波效果,可避免在临界值附近控制器的反复开/关跳动或显示器上数值抖动 缺点:对于快速变化的参数不宜如果在计数器溢出的那一次采样到的值恰好是干扰值,则会将干扰值当作有效值导入系统 限幅消抖滤波法 方法:相当于“限幅滤波法”+“消抖滤波法”先限幅,后消抖 优点:继承了“限幅”和“消抖”的优点改进了“消抖滤波法”中的某些缺陷,避免将干扰值导入系统 缺点:对于快速变化的参数不宜 示例程序,如有不足之处还望各位同行指教假定从8位AD中读取数据(如果是更高位的AD可定义数据类型为int),子程序为get_ad(); 限副滤波 A值可根据实际情况调整 value为有效值,new_value为当前采样值 滤波程序返回有效的实际值 12345678910111213#define A 10char value;char filter()&#123;char new_value;new_value = get_ad();if ( ( new_value - value &amp;gt; A ) || ( value - new_value &amp;gt; A )return value;return new_value;&#125; 中位值滤波法 N值可根据实际情况调整 排序采用冒泡法 12345678910111213141516171819202122232425#define N 11char filter()&#123; char value_buf[N]; char count,i,j,temp; for ( count=0;count &#123; value_buf[count] = get_ad(); delay(); &#125; for (j=0;j &#123; for (i=0;i &#123; if ( value_buf[i]&amp;gt;value_buf[i+1] ) &#123; temp = value_buf[i]; value_buf[i] = value_buf[i+1]; value_buf[i+1] = temp; &#125; &#125; &#125; return value_buf[(N-1)/2];&#125; 算术平均滤波法 123456789101112#define N 12char filter()&#123; int sum = 0; for ( count=0;count &#123; sum + = get_ad(); delay(); &#125; return (char)(sum/N);&#125; 递推平均滤波法(又称滑动平均滤波法) 123456789101112131415#define N 12char value_buf[N];char i=0;char filter()&#123; char count; int sum=0; value_buf[i++] = get_ad(); if ( i == N ) i = 0; for ( count=0;count sum = value_buf[count]; return (char)(sum/N);&#125; 中位值平均滤波法(又称防脉冲干扰平均滤波法) 12345678910111213141516171819202122232425262728#define N 12char filter()&#123;char count,i,j;char value_buf[N];int sum=0;for (count=0;count&#123;value_buf[count] = get_ad();delay();&#125;for (j=0;j&#123;for (i=0;i&#123;if ( value_buf[i]&amp;gt;value_buf[i+1] )&#123;temp = value_buf[i];value_buf[i] = value_buf[i+1];value_buf[i+1] = temp;&#125;&#125;&#125;for(count=1;countsum += value[count];return (char)(sum/(N-2));&#125; 限幅平均滤波法 略 参考子程序1、3 一阶滞后滤波法 为加快程序处理速度假定基数为100,a=0~100 12345678910#define a 50char value;char filter()&#123;char new_value;new_value = get_ad();return (100-a)*value + a*new_value;&#125; 加权递推平均滤波法 code数组为加权系数表,存在程序存储区. 12345678910111213141516171819#define N 12char code coe[N] = &#123;1,2,3,4,5,6,7,8,9,10,11,12&#125;;char code sum_coe = 1+2+3+4+5+6+7+8+9+10+11+12;char filter()&#123;char count;char value_buf[N];int sum=0;for (count=0,count&#123;value_buf[count] = get_ad();delay();&#125;for (count=0,countsum += value_buf[count]*coe[count];return (char)(sum/sum_coe);&#125; 消抖滤波法 12345678910111213141516#define N 12char filter()&#123;char count=0;char new_value;new_value = get_ad();while (value !=new_value);&#123;count++;if (count&amp;gt;=N) return new_value;delay();new_value = get_ad();&#125;return value;&#125; 限幅消抖滤波法 略 参考子程序1、9 我是用了第五种滤波方法得到了比较稳定的距离。]]></content>
      <categories>
        <category>智能小车</category>
      </categories>
      <tags>
        <tag>滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 14.04 LTS下安装apache+php+mysql+phpmyadmin]]></title>
    <url>%2F2016%2F06%2F24%2Fubuntu-14-04%2F</url>
    <content type="text"><![CDATA[##ubuntu 14.04 LTS下安装apache+php+mysql+phpmyadmin 转自某博，很好用： 最近重装了ubuntu12.04 LTS，今天也重装了web服务器，顺带记录一下安装过程。 ###环境：ubuntu 12.04 LTS ###详细步骤： 首先以管理员的身份登录。 1sudo su 安装mysql5（既是数据库） 1apt-get install mysql-server mysql-client 注：安装过程中会提示输入密码，记得设置密码再确定。当然，不想设置的话直接过就行了 安装phpMyAdmin 1apt-get install phpmyadmin （ 话说这种方法安装会自动把下面我介绍到的apache2,php5附带安装） 注：phpmyadmin会自动安装在/usr/share/phpMyAdmin下，需要将 phpMyAdmin文件夹拷贝到/var/www/html目录下面 (14.04是放在/var/www/html/下，非常重要，不然后面测试不成功) 故使用 1sudo cp /usr/share/phpmyadmin/ /var/www/ -a 把文件夹phpmyadmin搬到/var/www/html目录下即可 或者推荐下面这种用法 (链接目录，用如下命令 1sudo ln -s /usr/share/phpmyadmin/ /var/www/html/ 注意上面那个不是IN 而是小写的L。就不用移动文件了) 安装apache服务器 1apt-get install apache2 注：Apache的默认文档根目录是在Ubuntu上的/var/www目录，配置文件是/ etc/apache2/apache2.conf。配置存储在的子目录在/etc/apache2目录。一般的网页文件可以直接丢进/var/www目录下，在浏览器就可以访问了。默认的是index.html，所以在浏览器地址栏输入127.0.0.1或localhost就可以访问了 安装PHP5和Apache的PHP5的模块 1apt-get install php5 libapache2-mod-php5 安装完后重启服务器， 1/etc/init.d/apache2 restart 此时可以测试php环境， 1gedit /var/www/info.php， 在弹出的文本编辑器里面写入： 1&lt;?php phpinfo(); ?&gt; 然后直接在浏览器输入127.0.0.1/info.php,就可以看到php的信息了，说明安装成功了 让php5获得数据库mysql的支持 1apt-get install php5-mysql php5-curl php5-gd php5-idn php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl 然后重启服务器， 1/etc/init.d/apache2 restart 安装phpMyAdmin 1apt-get install phpmyadmin 浏览器输入127.0.0.1/phpmyadmin就可以看到管理数据库的界面了。 补充：今天发现不知是不是我乱改了密码还是怎样发现登录不了phpmyadmin，后来找到配置文件/var/www/phpmyadmin/config.default.php,打开这个配置文件把里面的密码和是否允许空密码登录（改为true）就行了，具体的情况稍微看下这个配置文件就行了，很简单的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派无路由器连接]]></title>
    <url>%2F2016%2F06%2F24%2Fraspberry-without-routet%2F</url>
    <content type="text"><![CDATA[##树莓派+一根网线直连笔记本电脑 用网线直连电脑，不经过路由器。这个方法最大的特点用最少的工具玩树莓派。 一、 材料：树莓派一部、网线一根，笔记本电脑一台。 树莓派：带供电系统和烧好Raspbian系统的SD卡； 网线：交叉或直连； 笔记本电脑：双网卡，现在应该都是这个配置的。 二、操作步骤。 连线。 树莓派接好供电线； 将网线一端接到树莓派，另一端接到笔记本。 注意：先连接WiFi，再进行其他配置 共享互联网。 如果现在笔记本已经通过WIFI连接到互联网，可以将无线网卡的互联网资源共享给本地连接。以win7系统为例，开始——控制面板——网络和Internet——网络和共享中心——查看网络状态和任务——更改适配器设置，找到无线网络连接右键“属性”，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接（N）”选项，点确定。 查找树莓派的IP地址。 运行DOS窗口，输入arp -a，在接口192.168.137.1下的为动态类型的IP地址就是树莓派的地址 三、问题一大堆 为什么是接口192.168.137.1的呢？因为上部共享互联网的时候已把“本地连接”的IP地址自动设置成静态IP192.168.137.1了，当然这个IP地址也可以自己设置成其他自己常用的静态IP地址。因为此时树莓派的IP地址是动态的，只能用此方法查找。也可以通过修改SD卡中的cmdline.txt文件（在里面加入语句ip=...），将树莓派设置成静态IP地址，但此时只有将电脑的“本地连接”的静态IP地址设置成与树莓派静态IP地址同一号段才能成功连接。 本文来自：树莓派实验室链接地址：http://shumeipai.nxez.com/2013/10/15/raspberry-pi-and-a-network-cable-directly-connected-laptop.html]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进入树莓派图形化界面]]></title>
    <url>%2F2016%2F06%2F24%2Fwindows-in-raspberry%2F</url>
    <content type="text"><![CDATA[一. 必要程序安装 1. 先在树莓派的机器上安装tightvncserver sudo apt-get install tightvncserver 2\. 开启tightvncserver服务 tightvncserver 要输入树莓派的密码,然后问你要不要设置一个独立密码,我选择n 3\. 在另一台机器(要访问树莓派的机器)上安装xtightvncviewer sudo apt-get install xtightvncviewer 4\. 在另一台机器上连接(在步骤2完成后,在~/.vnc目录下有个aborn:1.pid,所以下面的号对应为1) xtightvncviewer 192.168.1.153（树莓派的ip）:1 成功连接到树莓派图形化界面。 二. 再次启动树莓派 1\. 树莓派控制端Xshell启动tightvncserver tightvncserver 2\. 访问机启动xtightvncviewer xtightvncviewer 192.168.1.153（树莓派IP）:1]]></content>
      <categories>
        <category>树莓派</category>
      </categories>
      <tags>
        <tag>树莓派图形化界面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu解压缩zip,tar,tar.gz,tar.bz2]]></title>
    <url>%2F2016%2F06%2F24%2Funzip-in-ubuntu%2F</url>
    <content type="text"><![CDATA[zipzip可能是目前使用得最多的文档压缩格式。它最大的优点就是在不同的操作系统平台，比如Linux， Windows以及Mac OS，上使用。缺点就是支持的压缩率不是很高，而tar.gz和tar.gz2在压缩率方面做得非常好。闲话少说，我们步入正题吧： 我们可以使用下列的命令压缩一个目录：1zip -r archive_name.zip directory_to_compress 下面是如果解压一个zip文档：1unzip archive_name.zip TARTar是在Linux中使用得非常广泛的文档打包格式。它的好处就是它只消耗非常少的CPU以及时间去打包文件，他仅仅只是一个打包工具，并不负责压缩。下面是如何打包一个目录：1tar -cvf archive_name.tar directory_to_compress 如何解包：1tar -xvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：1tar -xvf archive_name.tar -C /tmp/extract_here/ TAR.GZ这种格式是我使用得最多的压缩格式。它在压缩时不会占用太多CPU的，而且可以得到一个非常理想的压缩率。使用下面这种格式去压缩一个目录：1tar -zcvf archive_name.tar.gz directory_to_compress 解压缩：1tar -zxvf archive_name.tar.gz 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：1tar -zxvf archive_name.tar.gz -C /tmp/extract_here/ TAR.BZ2这种压缩格式是我们提到的所有方式中压缩率最好的。当然，这也就意味着，它比前面的方式要占用更多的CPU与时间。这个就是你如何使用tar.bz2进行压缩。1tar -jcvf archive_name.tar.bz2 directory_to_compress 上面这个解包命令将会将文档解开在当前目录下面。当然，你也可以用这个命令来捏住解包的路径：1tar -jxvf archive_name.tar.bz2 -C /tmp/extract_here/ rar12sudo apt-get install unrarsudo unrar x name.rar 来源：http://www.linuxidc.com/Linux/2012-08/68122.htm]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>解压</tag>
      </tags>
  </entry>
</search>
